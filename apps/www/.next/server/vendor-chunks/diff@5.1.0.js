"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/diff@5.1.0";
exports.ids = ["vendor-chunks/diff@5.1.0"];
exports.modules = {

/***/ "(rsc)/../../node_modules/.pnpm/diff@5.1.0/node_modules/diff/lib/index.mjs":
/*!***************************************************************************!*\
  !*** ../../node_modules/.pnpm/diff@5.1.0/node_modules/diff/lib/index.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Diff: () => (/* binding */ Diff),\n/* harmony export */   applyPatch: () => (/* binding */ applyPatch),\n/* harmony export */   applyPatches: () => (/* binding */ applyPatches),\n/* harmony export */   canonicalize: () => (/* binding */ canonicalize),\n/* harmony export */   convertChangesToDMP: () => (/* binding */ convertChangesToDMP),\n/* harmony export */   convertChangesToXML: () => (/* binding */ convertChangesToXML),\n/* harmony export */   createPatch: () => (/* binding */ createPatch),\n/* harmony export */   createTwoFilesPatch: () => (/* binding */ createTwoFilesPatch),\n/* harmony export */   diffArrays: () => (/* binding */ diffArrays),\n/* harmony export */   diffChars: () => (/* binding */ diffChars),\n/* harmony export */   diffCss: () => (/* binding */ diffCss),\n/* harmony export */   diffJson: () => (/* binding */ diffJson),\n/* harmony export */   diffLines: () => (/* binding */ diffLines),\n/* harmony export */   diffSentences: () => (/* binding */ diffSentences),\n/* harmony export */   diffTrimmedLines: () => (/* binding */ diffTrimmedLines),\n/* harmony export */   diffWords: () => (/* binding */ diffWords),\n/* harmony export */   diffWordsWithSpace: () => (/* binding */ diffWordsWithSpace),\n/* harmony export */   merge: () => (/* binding */ merge),\n/* harmony export */   parsePatch: () => (/* binding */ parsePatch),\n/* harmony export */   structuredPatch: () => (/* binding */ structuredPatch)\n/* harmony export */ });\nfunction Diff() {}\nDiff.prototype = {\n    diff: function diff(oldString, newString) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var callback = options.callback;\n        if (typeof options === \"function\") {\n            callback = options;\n            options = {};\n        }\n        this.options = options;\n        var self = this;\n        function done(value) {\n            if (callback) {\n                setTimeout(function() {\n                    callback(undefined, value);\n                }, 0);\n                return true;\n            } else {\n                return value;\n            }\n        } // Allow subclasses to massage the input prior to running\n        oldString = this.castInput(oldString);\n        newString = this.castInput(newString);\n        oldString = this.removeEmpty(this.tokenize(oldString));\n        newString = this.removeEmpty(this.tokenize(newString));\n        var newLen = newString.length, oldLen = oldString.length;\n        var editLength = 1;\n        var maxEditLength = newLen + oldLen;\n        if (options.maxEditLength) {\n            maxEditLength = Math.min(maxEditLength, options.maxEditLength);\n        }\n        var bestPath = [\n            {\n                newPos: -1,\n                components: []\n            }\n        ]; // Seed editLength = 0, i.e. the content starts with the same values\n        var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n        if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n            // Identity per the equality and tokenizer\n            return done([\n                {\n                    value: this.join(newString),\n                    count: newString.length\n                }\n            ]);\n        } // Main worker method. checks all permutations of a given edit length for acceptance.\n        function execEditLength() {\n            for(var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2){\n                var basePath = void 0;\n                var addPath = bestPath[diagonalPath - 1], removePath = bestPath[diagonalPath + 1], _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n                if (addPath) {\n                    // No one else is going to attempt to use this value, clear it\n                    bestPath[diagonalPath - 1] = undefined;\n                }\n                var canAdd = addPath && addPath.newPos + 1 < newLen, canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;\n                if (!canAdd && !canRemove) {\n                    // If this path is a terminal then prune\n                    bestPath[diagonalPath] = undefined;\n                    continue;\n                } // Select the diagonal that we want to branch from. We select the prior\n                // path whose position in the new string is the farthest from the origin\n                // and does not pass the bounds of the diff graph\n                if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {\n                    basePath = clonePath(removePath);\n                    self.pushComponent(basePath.components, undefined, true);\n                } else {\n                    basePath = addPath; // No need to clone, we've pulled it from the list\n                    basePath.newPos++;\n                    self.pushComponent(basePath.components, true, undefined);\n                }\n                _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath); // If we have hit the end of both strings, then we are done\n                if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {\n                    return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));\n                } else {\n                    // Otherwise track this path as a potential candidate and continue.\n                    bestPath[diagonalPath] = basePath;\n                }\n            }\n            editLength++;\n        } // Performs the length of edit iteration. Is a bit fugly as this has to support the\n        // sync and async mode which is never fun. Loops over execEditLength until a value\n        // is produced, or until the edit length exceeds options.maxEditLength (if given),\n        // in which case it will return undefined.\n        if (callback) {\n            (function exec() {\n                setTimeout(function() {\n                    if (editLength > maxEditLength) {\n                        return callback();\n                    }\n                    if (!execEditLength()) {\n                        exec();\n                    }\n                }, 0);\n            })();\n        } else {\n            while(editLength <= maxEditLength){\n                var ret = execEditLength();\n                if (ret) {\n                    return ret;\n                }\n            }\n        }\n    },\n    pushComponent: function pushComponent(components, added, removed) {\n        var last = components[components.length - 1];\n        if (last && last.added === added && last.removed === removed) {\n            // We need to clone here as the component clone operation is just\n            // as shallow array clone\n            components[components.length - 1] = {\n                count: last.count + 1,\n                added: added,\n                removed: removed\n            };\n        } else {\n            components.push({\n                count: 1,\n                added: added,\n                removed: removed\n            });\n        }\n    },\n    extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {\n        var newLen = newString.length, oldLen = oldString.length, newPos = basePath.newPos, oldPos = newPos - diagonalPath, commonCount = 0;\n        while(newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])){\n            newPos++;\n            oldPos++;\n            commonCount++;\n        }\n        if (commonCount) {\n            basePath.components.push({\n                count: commonCount\n            });\n        }\n        basePath.newPos = newPos;\n        return oldPos;\n    },\n    equals: function equals(left, right) {\n        if (this.options.comparator) {\n            return this.options.comparator(left, right);\n        } else {\n            return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();\n        }\n    },\n    removeEmpty: function removeEmpty(array) {\n        var ret = [];\n        for(var i = 0; i < array.length; i++){\n            if (array[i]) {\n                ret.push(array[i]);\n            }\n        }\n        return ret;\n    },\n    castInput: function castInput(value) {\n        return value;\n    },\n    tokenize: function tokenize(value) {\n        return value.split(\"\");\n    },\n    join: function join(chars) {\n        return chars.join(\"\");\n    }\n};\nfunction buildValues(diff, components, newString, oldString, useLongestToken) {\n    var componentPos = 0, componentLen = components.length, newPos = 0, oldPos = 0;\n    for(; componentPos < componentLen; componentPos++){\n        var component = components[componentPos];\n        if (!component.removed) {\n            if (!component.added && useLongestToken) {\n                var value = newString.slice(newPos, newPos + component.count);\n                value = value.map(function(value, i) {\n                    var oldValue = oldString[oldPos + i];\n                    return oldValue.length > value.length ? oldValue : value;\n                });\n                component.value = diff.join(value);\n            } else {\n                component.value = diff.join(newString.slice(newPos, newPos + component.count));\n            }\n            newPos += component.count; // Common case\n            if (!component.added) {\n                oldPos += component.count;\n            }\n        } else {\n            component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));\n            oldPos += component.count; // Reverse add and remove so removes are output first to match common convention\n            // The diffing algorithm is tied to add then remove output and this is the simplest\n            // route to get the desired output with minimal overhead.\n            if (componentPos && components[componentPos - 1].added) {\n                var tmp = components[componentPos - 1];\n                components[componentPos - 1] = components[componentPos];\n                components[componentPos] = tmp;\n            }\n        }\n    } // Special case handle for when one terminal is ignored (i.e. whitespace).\n    // For this case we merge the terminal into the prior string and drop the change.\n    // This is only available for string mode.\n    var lastComponent = components[componentLen - 1];\n    if (componentLen > 1 && typeof lastComponent.value === \"string\" && (lastComponent.added || lastComponent.removed) && diff.equals(\"\", lastComponent.value)) {\n        components[componentLen - 2].value += lastComponent.value;\n        components.pop();\n    }\n    return components;\n}\nfunction clonePath(path) {\n    return {\n        newPos: path.newPos,\n        components: path.components.slice(0)\n    };\n}\nvar characterDiff = new Diff();\nfunction diffChars(oldStr, newStr, options) {\n    return characterDiff.diff(oldStr, newStr, options);\n}\nfunction generateOptions(options, defaults) {\n    if (typeof options === \"function\") {\n        defaults.callback = options;\n    } else if (options) {\n        for(var name in options){\n            /* istanbul ignore else */ if (options.hasOwnProperty(name)) {\n                defaults[name] = options[name];\n            }\n        }\n    }\n    return defaults;\n}\n//\n// Ranges and exceptions:\n// Latin-1 Supplement, 0080–00FF\n//  - U+00D7  × Multiplication sign\n//  - U+00F7  ÷ Division sign\n// Latin Extended-A, 0100–017F\n// Latin Extended-B, 0180–024F\n// IPA Extensions, 0250–02AF\n// Spacing Modifier Letters, 02B0–02FF\n//  - U+02C7  ˇ &#711;  Caron\n//  - U+02D8  ˘ &#728;  Breve\n//  - U+02D9  ˙ &#729;  Dot Above\n//  - U+02DA  ˚ &#730;  Ring Above\n//  - U+02DB  ˛ &#731;  Ogonek\n//  - U+02DC  ˜ &#732;  Small Tilde\n//  - U+02DD  ˝ &#733;  Double Acute Accent\n// Latin Extended Additional, 1E00–1EFF\nvar extendedWordChars = /^[A-Za-z\\xC0-\\u02C6\\u02C8-\\u02D7\\u02DE-\\u02FF\\u1E00-\\u1EFF]+$/;\nvar reWhitespace = /\\S/;\nvar wordDiff = new Diff();\nwordDiff.equals = function(left, right) {\n    if (this.options.ignoreCase) {\n        left = left.toLowerCase();\n        right = right.toLowerCase();\n    }\n    return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);\n};\nwordDiff.tokenize = function(value) {\n    // All whitespace symbols except newline group into one token, each newline - in separate token\n    var tokens = value.split(/([^\\S\\r\\n]+|[()[\\]{}'\"\\r\\n]|\\b)/); // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.\n    for(var i = 0; i < tokens.length - 1; i++){\n        // If we have an empty string in the next field and we have only word chars before and after, merge\n        if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {\n            tokens[i] += tokens[i + 2];\n            tokens.splice(i + 1, 2);\n            i--;\n        }\n    }\n    return tokens;\n};\nfunction diffWords(oldStr, newStr, options) {\n    options = generateOptions(options, {\n        ignoreWhitespace: true\n    });\n    return wordDiff.diff(oldStr, newStr, options);\n}\nfunction diffWordsWithSpace(oldStr, newStr, options) {\n    return wordDiff.diff(oldStr, newStr, options);\n}\nvar lineDiff = new Diff();\nlineDiff.tokenize = function(value) {\n    var retLines = [], linesAndNewlines = value.split(/(\\n|\\r\\n)/); // Ignore the final empty token that occurs if the string ends with a new line\n    if (!linesAndNewlines[linesAndNewlines.length - 1]) {\n        linesAndNewlines.pop();\n    } // Merge the content and line separators into single tokens\n    for(var i = 0; i < linesAndNewlines.length; i++){\n        var line = linesAndNewlines[i];\n        if (i % 2 && !this.options.newlineIsToken) {\n            retLines[retLines.length - 1] += line;\n        } else {\n            if (this.options.ignoreWhitespace) {\n                line = line.trim();\n            }\n            retLines.push(line);\n        }\n    }\n    return retLines;\n};\nfunction diffLines(oldStr, newStr, callback) {\n    return lineDiff.diff(oldStr, newStr, callback);\n}\nfunction diffTrimmedLines(oldStr, newStr, callback) {\n    var options = generateOptions(callback, {\n        ignoreWhitespace: true\n    });\n    return lineDiff.diff(oldStr, newStr, options);\n}\nvar sentenceDiff = new Diff();\nsentenceDiff.tokenize = function(value) {\n    return value.split(/(\\S.+?[.!?])(?=\\s+|$)/);\n};\nfunction diffSentences(oldStr, newStr, callback) {\n    return sentenceDiff.diff(oldStr, newStr, callback);\n}\nvar cssDiff = new Diff();\ncssDiff.tokenize = function(value) {\n    return value.split(/([{}:;,]|\\s+)/);\n};\nfunction diffCss(oldStr, newStr, callback) {\n    return cssDiff.diff(oldStr, newStr, callback);\n}\nfunction _typeof(obj) {\n    \"@babel/helpers - typeof\";\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n        _typeof = function(obj) {\n            return typeof obj;\n        };\n    } else {\n        _typeof = function(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n        };\n    }\n    return _typeof(obj);\n}\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nvar objectPrototypeToString = Object.prototype.toString;\nvar jsonDiff = new Diff(); // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\n// dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\njsonDiff.useLongestToken = true;\njsonDiff.tokenize = lineDiff.tokenize;\njsonDiff.castInput = function(value) {\n    var _this$options = this.options, undefinedReplacement = _this$options.undefinedReplacement, _this$options$stringi = _this$options.stringifyReplacer, stringifyReplacer = _this$options$stringi === void 0 ? function(k, v) {\n        return typeof v === \"undefined\" ? undefinedReplacement : v;\n    } : _this$options$stringi;\n    return typeof value === \"string\" ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, \"  \");\n};\njsonDiff.equals = function(left, right) {\n    return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\\r\\n])/g, \"$1\"), right.replace(/,([\\r\\n])/g, \"$1\"));\n};\nfunction diffJson(oldObj, newObj, options) {\n    return jsonDiff.diff(oldObj, newObj, options);\n} // This function handles the presence of circular references by bailing out when encountering an\n// object that is already on the \"stack\" of items being processed. Accepts an optional replacer\nfunction canonicalize(obj, stack, replacementStack, replacer, key) {\n    stack = stack || [];\n    replacementStack = replacementStack || [];\n    if (replacer) {\n        obj = replacer(key, obj);\n    }\n    var i;\n    for(i = 0; i < stack.length; i += 1){\n        if (stack[i] === obj) {\n            return replacementStack[i];\n        }\n    }\n    var canonicalizedObj;\n    if (\"[object Array]\" === objectPrototypeToString.call(obj)) {\n        stack.push(obj);\n        canonicalizedObj = new Array(obj.length);\n        replacementStack.push(canonicalizedObj);\n        for(i = 0; i < obj.length; i += 1){\n            canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);\n        }\n        stack.pop();\n        replacementStack.pop();\n        return canonicalizedObj;\n    }\n    if (obj && obj.toJSON) {\n        obj = obj.toJSON();\n    }\n    if (_typeof(obj) === \"object\" && obj !== null) {\n        stack.push(obj);\n        canonicalizedObj = {};\n        replacementStack.push(canonicalizedObj);\n        var sortedKeys = [], _key;\n        for(_key in obj){\n            /* istanbul ignore else */ if (obj.hasOwnProperty(_key)) {\n                sortedKeys.push(_key);\n            }\n        }\n        sortedKeys.sort();\n        for(i = 0; i < sortedKeys.length; i += 1){\n            _key = sortedKeys[i];\n            canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);\n        }\n        stack.pop();\n        replacementStack.pop();\n    } else {\n        canonicalizedObj = obj;\n    }\n    return canonicalizedObj;\n}\nvar arrayDiff = new Diff();\narrayDiff.tokenize = function(value) {\n    return value.slice();\n};\narrayDiff.join = arrayDiff.removeEmpty = function(value) {\n    return value;\n};\nfunction diffArrays(oldArr, newArr, callback) {\n    return arrayDiff.diff(oldArr, newArr, callback);\n}\nfunction parsePatch(uniDiff) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var diffstr = uniDiff.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/), delimiters = uniDiff.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [], list = [], i = 0;\n    function parseIndex() {\n        var index = {};\n        list.push(index); // Parse diff metadata\n        while(i < diffstr.length){\n            var line = diffstr[i]; // File header found, end parsing diff metadata\n            if (/^(\\-\\-\\-|\\+\\+\\+|@@)\\s/.test(line)) {\n                break;\n            } // Diff index\n            var header = /^(?:Index:|diff(?: -r \\w+)+)\\s+(.+?)\\s*$/.exec(line);\n            if (header) {\n                index.index = header[1];\n            }\n            i++;\n        } // Parse file headers if they are defined. Unified diff requires them, but\n        // there's no technical issues to have an isolated hunk without file header\n        parseFileHeader(index);\n        parseFileHeader(index); // Parse hunks\n        index.hunks = [];\n        while(i < diffstr.length){\n            var _line = diffstr[i];\n            if (/^(Index:|diff|\\-\\-\\-|\\+\\+\\+)\\s/.test(_line)) {\n                break;\n            } else if (/^@@/.test(_line)) {\n                index.hunks.push(parseHunk());\n            } else if (_line && options.strict) {\n                // Ignore unexpected content unless in strict mode\n                throw new Error(\"Unknown line \" + (i + 1) + \" \" + JSON.stringify(_line));\n            } else {\n                i++;\n            }\n        }\n    } // Parses the --- and +++ headers, if none are found, no lines\n    // are consumed.\n    function parseFileHeader(index) {\n        var fileHeader = /^(---|\\+\\+\\+)\\s+(.*)$/.exec(diffstr[i]);\n        if (fileHeader) {\n            var keyPrefix = fileHeader[1] === \"---\" ? \"old\" : \"new\";\n            var data = fileHeader[2].split(\"\t\", 2);\n            var fileName = data[0].replace(/\\\\\\\\/g, \"\\\\\");\n            if (/^\".*\"$/.test(fileName)) {\n                fileName = fileName.substr(1, fileName.length - 2);\n            }\n            index[keyPrefix + \"FileName\"] = fileName;\n            index[keyPrefix + \"Header\"] = (data[1] || \"\").trim();\n            i++;\n        }\n    } // Parses a hunk\n    // This assumes that we are at the start of a hunk.\n    function parseHunk() {\n        var chunkHeaderIndex = i, chunkHeaderLine = diffstr[i++], chunkHeader = chunkHeaderLine.split(/@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@/);\n        var hunk = {\n            oldStart: +chunkHeader[1],\n            oldLines: typeof chunkHeader[2] === \"undefined\" ? 1 : +chunkHeader[2],\n            newStart: +chunkHeader[3],\n            newLines: typeof chunkHeader[4] === \"undefined\" ? 1 : +chunkHeader[4],\n            lines: [],\n            linedelimiters: []\n        }; // Unified Diff Format quirk: If the chunk size is 0,\n        // the first number is one lower than one would expect.\n        // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n        if (hunk.oldLines === 0) {\n            hunk.oldStart += 1;\n        }\n        if (hunk.newLines === 0) {\n            hunk.newStart += 1;\n        }\n        var addCount = 0, removeCount = 0;\n        for(; i < diffstr.length; i++){\n            // Lines starting with '---' could be mistaken for the \"remove line\" operation\n            // But they could be the header for the next file. Therefore prune such cases out.\n            if (diffstr[i].indexOf(\"--- \") === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf(\"+++ \") === 0 && diffstr[i + 2].indexOf(\"@@\") === 0) {\n                break;\n            }\n            var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? \" \" : diffstr[i][0];\n            if (operation === \"+\" || operation === \"-\" || operation === \" \" || operation === \"\\\\\") {\n                hunk.lines.push(diffstr[i]);\n                hunk.linedelimiters.push(delimiters[i] || \"\\n\");\n                if (operation === \"+\") {\n                    addCount++;\n                } else if (operation === \"-\") {\n                    removeCount++;\n                } else if (operation === \" \") {\n                    addCount++;\n                    removeCount++;\n                }\n            } else {\n                break;\n            }\n        } // Handle the empty block count case\n        if (!addCount && hunk.newLines === 1) {\n            hunk.newLines = 0;\n        }\n        if (!removeCount && hunk.oldLines === 1) {\n            hunk.oldLines = 0;\n        } // Perform optional sanity checking\n        if (options.strict) {\n            if (addCount !== hunk.newLines) {\n                throw new Error(\"Added line count did not match for hunk at line \" + (chunkHeaderIndex + 1));\n            }\n            if (removeCount !== hunk.oldLines) {\n                throw new Error(\"Removed line count did not match for hunk at line \" + (chunkHeaderIndex + 1));\n            }\n        }\n        return hunk;\n    }\n    while(i < diffstr.length){\n        parseIndex();\n    }\n    return list;\n}\n// Iterator that traverses in the range of [min, max], stepping\n// by distance from a given start position. I.e. for [0, 4], with\n// start of 2, this will iterate 2, 3, 1, 4, 0.\nfunction distanceIterator(start, minLine, maxLine) {\n    var wantForward = true, backwardExhausted = false, forwardExhausted = false, localOffset = 1;\n    return function iterator() {\n        if (wantForward && !forwardExhausted) {\n            if (backwardExhausted) {\n                localOffset++;\n            } else {\n                wantForward = false;\n            } // Check if trying to fit beyond text length, and if not, check it fits\n            // after offset location (or desired location on first iteration)\n            if (start + localOffset <= maxLine) {\n                return localOffset;\n            }\n            forwardExhausted = true;\n        }\n        if (!backwardExhausted) {\n            if (!forwardExhausted) {\n                wantForward = true;\n            } // Check if trying to fit before text beginning, and if not, check it fits\n            // before offset location\n            if (minLine <= start - localOffset) {\n                return -localOffset++;\n            }\n            backwardExhausted = true;\n            return iterator();\n        } // We tried to fit hunk before text beginning and beyond text length, then\n    // hunk can't fit on the text. Return undefined\n    };\n}\nfunction applyPatch(source, uniDiff) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (typeof uniDiff === \"string\") {\n        uniDiff = parsePatch(uniDiff);\n    }\n    if (Array.isArray(uniDiff)) {\n        if (uniDiff.length > 1) {\n            throw new Error(\"applyPatch only works with a single input.\");\n        }\n        uniDiff = uniDiff[0];\n    } // Apply the diff to the input\n    var lines = source.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/), delimiters = source.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [], hunks = uniDiff.hunks, compareLine = options.compareLine || function(lineNumber, line, operation, patchContent) {\n        return line === patchContent;\n    }, errorCount = 0, fuzzFactor = options.fuzzFactor || 0, minLine = 0, offset = 0, removeEOFNL, addEOFNL;\n    /**\n   * Checks if the hunk exactly fits on the provided location\n   */ function hunkFits(hunk, toPos) {\n        for(var j = 0; j < hunk.lines.length; j++){\n            var line = hunk.lines[j], operation = line.length > 0 ? line[0] : \" \", content = line.length > 0 ? line.substr(1) : line;\n            if (operation === \" \" || operation === \"-\") {\n                // Context sanity check\n                if (!compareLine(toPos + 1, lines[toPos], operation, content)) {\n                    errorCount++;\n                    if (errorCount > fuzzFactor) {\n                        return false;\n                    }\n                }\n                toPos++;\n            }\n        }\n        return true;\n    } // Search best fit offsets for each hunk based on the previous ones\n    for(var i = 0; i < hunks.length; i++){\n        var hunk = hunks[i], maxLine = lines.length - hunk.oldLines, localOffset = 0, toPos = offset + hunk.oldStart - 1;\n        var iterator = distanceIterator(toPos, minLine, maxLine);\n        for(; localOffset !== undefined; localOffset = iterator()){\n            if (hunkFits(hunk, toPos + localOffset)) {\n                hunk.offset = offset += localOffset;\n                break;\n            }\n        }\n        if (localOffset === undefined) {\n            return false;\n        } // Set lower text limit to end of the current hunk, so next ones don't try\n        // to fit over already patched text\n        minLine = hunk.offset + hunk.oldStart + hunk.oldLines;\n    } // Apply patch hunks\n    var diffOffset = 0;\n    for(var _i = 0; _i < hunks.length; _i++){\n        var _hunk = hunks[_i], _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;\n        diffOffset += _hunk.newLines - _hunk.oldLines;\n        for(var j = 0; j < _hunk.lines.length; j++){\n            var line = _hunk.lines[j], operation = line.length > 0 ? line[0] : \" \", content = line.length > 0 ? line.substr(1) : line, delimiter = _hunk.linedelimiters[j];\n            if (operation === \" \") {\n                _toPos++;\n            } else if (operation === \"-\") {\n                lines.splice(_toPos, 1);\n                delimiters.splice(_toPos, 1);\n            /* istanbul ignore else */ } else if (operation === \"+\") {\n                lines.splice(_toPos, 0, content);\n                delimiters.splice(_toPos, 0, delimiter);\n                _toPos++;\n            } else if (operation === \"\\\\\") {\n                var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;\n                if (previousOperation === \"+\") {\n                    removeEOFNL = true;\n                } else if (previousOperation === \"-\") {\n                    addEOFNL = true;\n                }\n            }\n        }\n    } // Handle EOFNL insertion/removal\n    if (removeEOFNL) {\n        while(!lines[lines.length - 1]){\n            lines.pop();\n            delimiters.pop();\n        }\n    } else if (addEOFNL) {\n        lines.push(\"\");\n        delimiters.push(\"\\n\");\n    }\n    for(var _k = 0; _k < lines.length - 1; _k++){\n        lines[_k] = lines[_k] + delimiters[_k];\n    }\n    return lines.join(\"\");\n} // Wrapper that supports multiple file patches via callbacks.\nfunction applyPatches(uniDiff, options) {\n    if (typeof uniDiff === \"string\") {\n        uniDiff = parsePatch(uniDiff);\n    }\n    var currentIndex = 0;\n    function processIndex() {\n        var index = uniDiff[currentIndex++];\n        if (!index) {\n            return options.complete();\n        }\n        options.loadFile(index, function(err, data) {\n            if (err) {\n                return options.complete(err);\n            }\n            var updatedContent = applyPatch(data, index, options);\n            options.patched(index, updatedContent, function(err) {\n                if (err) {\n                    return options.complete(err);\n                }\n                processIndex();\n            });\n        });\n    }\n    processIndex();\n}\nfunction structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n    if (!options) {\n        options = {};\n    }\n    if (typeof options.context === \"undefined\") {\n        options.context = 4;\n    }\n    var diff = diffLines(oldStr, newStr, options);\n    if (!diff) {\n        return;\n    }\n    diff.push({\n        value: \"\",\n        lines: []\n    }); // Append an empty value to make cleanup easier\n    function contextLines(lines) {\n        return lines.map(function(entry) {\n            return \" \" + entry;\n        });\n    }\n    var hunks = [];\n    var oldRangeStart = 0, newRangeStart = 0, curRange = [], oldLine = 1, newLine = 1;\n    var _loop = function _loop(i) {\n        var current = diff[i], lines = current.lines || current.value.replace(/\\n$/, \"\").split(\"\\n\");\n        current.lines = lines;\n        if (current.added || current.removed) {\n            var _curRange;\n            // If we have previous context, start with that\n            if (!oldRangeStart) {\n                var prev = diff[i - 1];\n                oldRangeStart = oldLine;\n                newRangeStart = newLine;\n                if (prev) {\n                    curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];\n                    oldRangeStart -= curRange.length;\n                    newRangeStart -= curRange.length;\n                }\n            } // Output our changes\n            (_curRange = curRange).push.apply(_curRange, _toConsumableArray(lines.map(function(entry) {\n                return (current.added ? \"+\" : \"-\") + entry;\n            }))); // Track the updated file position\n            if (current.added) {\n                newLine += lines.length;\n            } else {\n                oldLine += lines.length;\n            }\n        } else {\n            // Identical context lines. Track line changes\n            if (oldRangeStart) {\n                // Close out any changes that have been output (or join overlapping)\n                if (lines.length <= options.context * 2 && i < diff.length - 2) {\n                    var _curRange2;\n                    // Overlapping\n                    (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray(contextLines(lines)));\n                } else {\n                    var _curRange3;\n                    // end the range and output\n                    var contextSize = Math.min(lines.length, options.context);\n                    (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray(contextLines(lines.slice(0, contextSize))));\n                    var hunk = {\n                        oldStart: oldRangeStart,\n                        oldLines: oldLine - oldRangeStart + contextSize,\n                        newStart: newRangeStart,\n                        newLines: newLine - newRangeStart + contextSize,\n                        lines: curRange\n                    };\n                    if (i >= diff.length - 2 && lines.length <= options.context) {\n                        // EOF is inside this hunk\n                        var oldEOFNewline = /\\n$/.test(oldStr);\n                        var newEOFNewline = /\\n$/.test(newStr);\n                        var noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;\n                        if (!oldEOFNewline && noNlBeforeAdds && oldStr.length > 0) {\n                            // special case: old has no eol and no trailing context; no-nl can end up before adds\n                            // however, if the old file is empty, do not output the no-nl line\n                            curRange.splice(hunk.oldLines, 0, \"\\\\ No newline at end of file\");\n                        }\n                        if (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) {\n                            curRange.push(\"\\\\ No newline at end of file\");\n                        }\n                    }\n                    hunks.push(hunk);\n                    oldRangeStart = 0;\n                    newRangeStart = 0;\n                    curRange = [];\n                }\n            }\n            oldLine += lines.length;\n            newLine += lines.length;\n        }\n    };\n    for(var i = 0; i < diff.length; i++){\n        _loop(i);\n    }\n    return {\n        oldFileName: oldFileName,\n        newFileName: newFileName,\n        oldHeader: oldHeader,\n        newHeader: newHeader,\n        hunks: hunks\n    };\n}\nfunction formatPatch(diff) {\n    var ret = [];\n    if (diff.oldFileName == diff.newFileName) {\n        ret.push(\"Index: \" + diff.oldFileName);\n    }\n    ret.push(\"===================================================================\");\n    ret.push(\"--- \" + diff.oldFileName + (typeof diff.oldHeader === \"undefined\" ? \"\" : \"\t\" + diff.oldHeader));\n    ret.push(\"+++ \" + diff.newFileName + (typeof diff.newHeader === \"undefined\" ? \"\" : \"\t\" + diff.newHeader));\n    for(var i = 0; i < diff.hunks.length; i++){\n        var hunk = diff.hunks[i]; // Unified Diff Format quirk: If the chunk size is 0,\n        // the first number is one lower than one would expect.\n        // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n        if (hunk.oldLines === 0) {\n            hunk.oldStart -= 1;\n        }\n        if (hunk.newLines === 0) {\n            hunk.newStart -= 1;\n        }\n        ret.push(\"@@ -\" + hunk.oldStart + \",\" + hunk.oldLines + \" +\" + hunk.newStart + \",\" + hunk.newLines + \" @@\");\n        ret.push.apply(ret, hunk.lines);\n    }\n    return ret.join(\"\\n\") + \"\\n\";\n}\nfunction createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n    return formatPatch(structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options));\n}\nfunction createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {\n    return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);\n}\nfunction arrayEqual(a, b) {\n    if (a.length !== b.length) {\n        return false;\n    }\n    return arrayStartsWith(a, b);\n}\nfunction arrayStartsWith(array, start) {\n    if (start.length > array.length) {\n        return false;\n    }\n    for(var i = 0; i < start.length; i++){\n        if (start[i] !== array[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction calcLineCount(hunk) {\n    var _calcOldNewLineCount = calcOldNewLineCount(hunk.lines), oldLines = _calcOldNewLineCount.oldLines, newLines = _calcOldNewLineCount.newLines;\n    if (oldLines !== undefined) {\n        hunk.oldLines = oldLines;\n    } else {\n        delete hunk.oldLines;\n    }\n    if (newLines !== undefined) {\n        hunk.newLines = newLines;\n    } else {\n        delete hunk.newLines;\n    }\n}\nfunction merge(mine, theirs, base) {\n    mine = loadPatch(mine, base);\n    theirs = loadPatch(theirs, base);\n    var ret = {}; // For index we just let it pass through as it doesn't have any necessary meaning.\n    // Leaving sanity checks on this to the API consumer that may know more about the\n    // meaning in their own context.\n    if (mine.index || theirs.index) {\n        ret.index = mine.index || theirs.index;\n    }\n    if (mine.newFileName || theirs.newFileName) {\n        if (!fileNameChanged(mine)) {\n            // No header or no change in ours, use theirs (and ours if theirs does not exist)\n            ret.oldFileName = theirs.oldFileName || mine.oldFileName;\n            ret.newFileName = theirs.newFileName || mine.newFileName;\n            ret.oldHeader = theirs.oldHeader || mine.oldHeader;\n            ret.newHeader = theirs.newHeader || mine.newHeader;\n        } else if (!fileNameChanged(theirs)) {\n            // No header or no change in theirs, use ours\n            ret.oldFileName = mine.oldFileName;\n            ret.newFileName = mine.newFileName;\n            ret.oldHeader = mine.oldHeader;\n            ret.newHeader = mine.newHeader;\n        } else {\n            // Both changed... figure it out\n            ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);\n            ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);\n            ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);\n            ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);\n        }\n    }\n    ret.hunks = [];\n    var mineIndex = 0, theirsIndex = 0, mineOffset = 0, theirsOffset = 0;\n    while(mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length){\n        var mineCurrent = mine.hunks[mineIndex] || {\n            oldStart: Infinity\n        }, theirsCurrent = theirs.hunks[theirsIndex] || {\n            oldStart: Infinity\n        };\n        if (hunkBefore(mineCurrent, theirsCurrent)) {\n            // This patch does not overlap with any of the others, yay.\n            ret.hunks.push(cloneHunk(mineCurrent, mineOffset));\n            mineIndex++;\n            theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;\n        } else if (hunkBefore(theirsCurrent, mineCurrent)) {\n            // This patch does not overlap with any of the others, yay.\n            ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));\n            theirsIndex++;\n            mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;\n        } else {\n            // Overlap, merge as best we can\n            var mergedHunk = {\n                oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),\n                oldLines: 0,\n                newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),\n                newLines: 0,\n                lines: []\n            };\n            mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);\n            theirsIndex++;\n            mineIndex++;\n            ret.hunks.push(mergedHunk);\n        }\n    }\n    return ret;\n}\nfunction loadPatch(param, base) {\n    if (typeof param === \"string\") {\n        if (/^@@/m.test(param) || /^Index:/m.test(param)) {\n            return parsePatch(param)[0];\n        }\n        if (!base) {\n            throw new Error(\"Must provide a base reference or pass in a patch\");\n        }\n        return structuredPatch(undefined, undefined, base, param);\n    }\n    return param;\n}\nfunction fileNameChanged(patch) {\n    return patch.newFileName && patch.newFileName !== patch.oldFileName;\n}\nfunction selectField(index, mine, theirs) {\n    if (mine === theirs) {\n        return mine;\n    } else {\n        index.conflict = true;\n        return {\n            mine: mine,\n            theirs: theirs\n        };\n    }\n}\nfunction hunkBefore(test, check) {\n    return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;\n}\nfunction cloneHunk(hunk, offset) {\n    return {\n        oldStart: hunk.oldStart,\n        oldLines: hunk.oldLines,\n        newStart: hunk.newStart + offset,\n        newLines: hunk.newLines,\n        lines: hunk.lines\n    };\n}\nfunction mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {\n    // This will generally result in a conflicted hunk, but there are cases where the context\n    // is the only overlap where we can successfully merge the content here.\n    var mine = {\n        offset: mineOffset,\n        lines: mineLines,\n        index: 0\n    }, their = {\n        offset: theirOffset,\n        lines: theirLines,\n        index: 0\n    }; // Handle any leading content\n    insertLeading(hunk, mine, their);\n    insertLeading(hunk, their, mine); // Now in the overlap content. Scan through and select the best changes from each.\n    while(mine.index < mine.lines.length && their.index < their.lines.length){\n        var mineCurrent = mine.lines[mine.index], theirCurrent = their.lines[their.index];\n        if ((mineCurrent[0] === \"-\" || mineCurrent[0] === \"+\") && (theirCurrent[0] === \"-\" || theirCurrent[0] === \"+\")) {\n            // Both modified ...\n            mutualChange(hunk, mine, their);\n        } else if (mineCurrent[0] === \"+\" && theirCurrent[0] === \" \") {\n            var _hunk$lines;\n            // Mine inserted\n            (_hunk$lines = hunk.lines).push.apply(_hunk$lines, _toConsumableArray(collectChange(mine)));\n        } else if (theirCurrent[0] === \"+\" && mineCurrent[0] === \" \") {\n            var _hunk$lines2;\n            // Theirs inserted\n            (_hunk$lines2 = hunk.lines).push.apply(_hunk$lines2, _toConsumableArray(collectChange(their)));\n        } else if (mineCurrent[0] === \"-\" && theirCurrent[0] === \" \") {\n            // Mine removed or edited\n            removal(hunk, mine, their);\n        } else if (theirCurrent[0] === \"-\" && mineCurrent[0] === \" \") {\n            // Their removed or edited\n            removal(hunk, their, mine, true);\n        } else if (mineCurrent === theirCurrent) {\n            // Context identity\n            hunk.lines.push(mineCurrent);\n            mine.index++;\n            their.index++;\n        } else {\n            // Context mismatch\n            conflict(hunk, collectChange(mine), collectChange(their));\n        }\n    } // Now push anything that may be remaining\n    insertTrailing(hunk, mine);\n    insertTrailing(hunk, their);\n    calcLineCount(hunk);\n}\nfunction mutualChange(hunk, mine, their) {\n    var myChanges = collectChange(mine), theirChanges = collectChange(their);\n    if (allRemoves(myChanges) && allRemoves(theirChanges)) {\n        // Special case for remove changes that are supersets of one another\n        if (arrayStartsWith(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {\n            var _hunk$lines3;\n            (_hunk$lines3 = hunk.lines).push.apply(_hunk$lines3, _toConsumableArray(myChanges));\n            return;\n        } else if (arrayStartsWith(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {\n            var _hunk$lines4;\n            (_hunk$lines4 = hunk.lines).push.apply(_hunk$lines4, _toConsumableArray(theirChanges));\n            return;\n        }\n    } else if (arrayEqual(myChanges, theirChanges)) {\n        var _hunk$lines5;\n        (_hunk$lines5 = hunk.lines).push.apply(_hunk$lines5, _toConsumableArray(myChanges));\n        return;\n    }\n    conflict(hunk, myChanges, theirChanges);\n}\nfunction removal(hunk, mine, their, swap) {\n    var myChanges = collectChange(mine), theirChanges = collectContext(their, myChanges);\n    if (theirChanges.merged) {\n        var _hunk$lines6;\n        (_hunk$lines6 = hunk.lines).push.apply(_hunk$lines6, _toConsumableArray(theirChanges.merged));\n    } else {\n        conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);\n    }\n}\nfunction conflict(hunk, mine, their) {\n    hunk.conflict = true;\n    hunk.lines.push({\n        conflict: true,\n        mine: mine,\n        theirs: their\n    });\n}\nfunction insertLeading(hunk, insert, their) {\n    while(insert.offset < their.offset && insert.index < insert.lines.length){\n        var line = insert.lines[insert.index++];\n        hunk.lines.push(line);\n        insert.offset++;\n    }\n}\nfunction insertTrailing(hunk, insert) {\n    while(insert.index < insert.lines.length){\n        var line = insert.lines[insert.index++];\n        hunk.lines.push(line);\n    }\n}\nfunction collectChange(state) {\n    var ret = [], operation = state.lines[state.index][0];\n    while(state.index < state.lines.length){\n        var line = state.lines[state.index]; // Group additions that are immediately after subtractions and treat them as one \"atomic\" modify change.\n        if (operation === \"-\" && line[0] === \"+\") {\n            operation = \"+\";\n        }\n        if (operation === line[0]) {\n            ret.push(line);\n            state.index++;\n        } else {\n            break;\n        }\n    }\n    return ret;\n}\nfunction collectContext(state, matchChanges) {\n    var changes = [], merged = [], matchIndex = 0, contextChanges = false, conflicted = false;\n    while(matchIndex < matchChanges.length && state.index < state.lines.length){\n        var change = state.lines[state.index], match = matchChanges[matchIndex]; // Once we've hit our add, then we are done\n        if (match[0] === \"+\") {\n            break;\n        }\n        contextChanges = contextChanges || change[0] !== \" \";\n        merged.push(match);\n        matchIndex++; // Consume any additions in the other block as a conflict to attempt\n        // to pull in the remaining context after this\n        if (change[0] === \"+\") {\n            conflicted = true;\n            while(change[0] === \"+\"){\n                changes.push(change);\n                change = state.lines[++state.index];\n            }\n        }\n        if (match.substr(1) === change.substr(1)) {\n            changes.push(change);\n            state.index++;\n        } else {\n            conflicted = true;\n        }\n    }\n    if ((matchChanges[matchIndex] || \"\")[0] === \"+\" && contextChanges) {\n        conflicted = true;\n    }\n    if (conflicted) {\n        return changes;\n    }\n    while(matchIndex < matchChanges.length){\n        merged.push(matchChanges[matchIndex++]);\n    }\n    return {\n        merged: merged,\n        changes: changes\n    };\n}\nfunction allRemoves(changes) {\n    return changes.reduce(function(prev, change) {\n        return prev && change[0] === \"-\";\n    }, true);\n}\nfunction skipRemoveSuperset(state, removeChanges, delta) {\n    for(var i = 0; i < delta; i++){\n        var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);\n        if (state.lines[state.index + i] !== \" \" + changeContent) {\n            return false;\n        }\n    }\n    state.index += delta;\n    return true;\n}\nfunction calcOldNewLineCount(lines) {\n    var oldLines = 0;\n    var newLines = 0;\n    lines.forEach(function(line) {\n        if (typeof line !== \"string\") {\n            var myCount = calcOldNewLineCount(line.mine);\n            var theirCount = calcOldNewLineCount(line.theirs);\n            if (oldLines !== undefined) {\n                if (myCount.oldLines === theirCount.oldLines) {\n                    oldLines += myCount.oldLines;\n                } else {\n                    oldLines = undefined;\n                }\n            }\n            if (newLines !== undefined) {\n                if (myCount.newLines === theirCount.newLines) {\n                    newLines += myCount.newLines;\n                } else {\n                    newLines = undefined;\n                }\n            }\n        } else {\n            if (newLines !== undefined && (line[0] === \"+\" || line[0] === \" \")) {\n                newLines++;\n            }\n            if (oldLines !== undefined && (line[0] === \"-\" || line[0] === \" \")) {\n                oldLines++;\n            }\n        }\n    });\n    return {\n        oldLines: oldLines,\n        newLines: newLines\n    };\n}\n// See: http://code.google.com/p/google-diff-match-patch/wiki/API\nfunction convertChangesToDMP(changes) {\n    var ret = [], change, operation;\n    for(var i = 0; i < changes.length; i++){\n        change = changes[i];\n        if (change.added) {\n            operation = 1;\n        } else if (change.removed) {\n            operation = -1;\n        } else {\n            operation = 0;\n        }\n        ret.push([\n            operation,\n            change.value\n        ]);\n    }\n    return ret;\n}\nfunction convertChangesToXML(changes) {\n    var ret = [];\n    for(var i = 0; i < changes.length; i++){\n        var change = changes[i];\n        if (change.added) {\n            ret.push(\"<ins>\");\n        } else if (change.removed) {\n            ret.push(\"<del>\");\n        }\n        ret.push(escapeHTML(change.value));\n        if (change.added) {\n            ret.push(\"</ins>\");\n        } else if (change.removed) {\n            ret.push(\"</del>\");\n        }\n    }\n    return ret.join(\"\");\n}\nfunction escapeHTML(s) {\n    var n = s;\n    n = n.replace(/&/g, \"&amp;\");\n    n = n.replace(/</g, \"&lt;\");\n    n = n.replace(/>/g, \"&gt;\");\n    n = n.replace(/\"/g, \"&quot;\");\n    return n;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2RpZmZANS4xLjAvbm9kZV9tb2R1bGVzL2RpZmYvbGliL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLFNBQVNBLFFBQVE7QUFDakJBLEtBQUtDLFNBQVMsR0FBRztJQUNmQyxNQUFNLFNBQVNBLEtBQUtDLFNBQVMsRUFBRUMsU0FBUztRQUN0QyxJQUFJQyxVQUFVQyxVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBS0UsWUFBWUYsU0FBUyxDQUFDLEVBQUUsR0FBRyxDQUFDO1FBQ25GLElBQUlHLFdBQVdKLFFBQVFJLFFBQVE7UUFFL0IsSUFBSSxPQUFPSixZQUFZLFlBQVk7WUFDakNJLFdBQVdKO1lBQ1hBLFVBQVUsQ0FBQztRQUNiO1FBRUEsSUFBSSxDQUFDQSxPQUFPLEdBQUdBO1FBQ2YsSUFBSUssT0FBTyxJQUFJO1FBRWYsU0FBU0MsS0FBS0MsS0FBSztZQUNqQixJQUFJSCxVQUFVO2dCQUNaSSxXQUFXO29CQUNUSixTQUFTRCxXQUFXSTtnQkFDdEIsR0FBRztnQkFDSCxPQUFPO1lBQ1QsT0FBTztnQkFDTCxPQUFPQTtZQUNUO1FBQ0YsRUFBRSx5REFBeUQ7UUFHM0RULFlBQVksSUFBSSxDQUFDVyxTQUFTLENBQUNYO1FBQzNCQyxZQUFZLElBQUksQ0FBQ1UsU0FBUyxDQUFDVjtRQUMzQkQsWUFBWSxJQUFJLENBQUNZLFdBQVcsQ0FBQyxJQUFJLENBQUNDLFFBQVEsQ0FBQ2I7UUFDM0NDLFlBQVksSUFBSSxDQUFDVyxXQUFXLENBQUMsSUFBSSxDQUFDQyxRQUFRLENBQUNaO1FBQzNDLElBQUlhLFNBQVNiLFVBQVVHLE1BQU0sRUFDekJXLFNBQVNmLFVBQVVJLE1BQU07UUFDN0IsSUFBSVksYUFBYTtRQUNqQixJQUFJQyxnQkFBZ0JILFNBQVNDO1FBRTdCLElBQUliLFFBQVFlLGFBQWEsRUFBRTtZQUN6QkEsZ0JBQWdCQyxLQUFLQyxH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QUFPeFEsS0FBSyxFQUFFO1lBQ2hCRCxJQUFJSSxJQUFJLENBQUM7UUFDWCxPQUFPLElBQUlxUSxPQUFPdlEsT0FBTyxFQUFFO1lBQ3pCRixJQUFJSSxJQUFJLENBQUM7UUFDWDtJQUNGO0lBRUEsT0FBT0osSUFBSWYsSUFBSSxDQUFDO0FBQ2xCO0FBRUEsU0FBU2tTLFdBQVdDLENBQUM7SUFDbkIsSUFBSTFNLElBQUkwTTtJQUNSMU0sSUFBSUEsRUFBRWlCLE9BQU8sQ0FBQyxNQUFNO0lBQ3BCakIsSUFBSUEsRUFBRWlCLE9BQU8sQ0FBQyxNQUFNO0lBQ3BCakIsSUFBSUEsRUFBRWlCLE9BQU8sQ0FBQyxNQUFNO0lBQ3BCakIsSUFBSUEsRUFBRWlCLE9BQU8sQ0FBQyxNQUFNO0lBQ3BCLE9BQU9qQjtBQUNUO0FBRTZSIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGF3YS1kb2NzLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9kaWZmQDUuMS4wL25vZGVfbW9kdWxlcy9kaWZmL2xpYi9pbmRleC5tanM/MGRkNyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBEaWZmKCkge31cbkRpZmYucHJvdG90eXBlID0ge1xuICBkaWZmOiBmdW5jdGlvbiBkaWZmKG9sZFN0cmluZywgbmV3U3RyaW5nKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2s7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGZ1bmN0aW9uIGRvbmUodmFsdWUpIHtcbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjYWxsYmFjayh1bmRlZmluZWQsIHZhbHVlKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH0gLy8gQWxsb3cgc3ViY2xhc3NlcyB0byBtYXNzYWdlIHRoZSBpbnB1dCBwcmlvciB0byBydW5uaW5nXG5cblxuICAgIG9sZFN0cmluZyA9IHRoaXMuY2FzdElucHV0KG9sZFN0cmluZyk7XG4gICAgbmV3U3RyaW5nID0gdGhpcy5jYXN0SW5wdXQobmV3U3RyaW5nKTtcbiAgICBvbGRTdHJpbmcgPSB0aGlzLnJlbW92ZUVtcHR5KHRoaXMudG9rZW5pemUob2xkU3RyaW5nKSk7XG4gICAgbmV3U3RyaW5nID0gdGhpcy5yZW1vdmVFbXB0eSh0aGlzLnRva2VuaXplKG5ld1N0cmluZykpO1xuICAgIHZhciBuZXdMZW4gPSBuZXdTdHJpbmcubGVuZ3RoLFxuICAgICAgICBvbGRMZW4gPSBvbGRTdHJpbmcubGVuZ3RoO1xuICAgIHZhciBlZGl0TGVuZ3RoID0gMTtcbiAgICB2YXIgbWF4RWRpdExlbmd0aCA9IG5ld0xlbiArIG9sZExlbjtcblxuICAgIGlmIChvcHRpb25zLm1heEVkaXRMZW5ndGgpIHtcbiAgICAgIG1heEVkaXRMZW5ndGggPSBNYXRoLm1pbihtYXhFZGl0TGVuZ3RoLCBvcHRpb25zLm1heEVkaXRMZW5ndGgpO1xuICAgIH1cblxuICAgIHZhciBiZXN0UGF0aCA9IFt7XG4gICAgICBuZXdQb3M6IC0xLFxuICAgICAgY29tcG9uZW50czogW11cbiAgICB9XTsgLy8gU2VlZCBlZGl0TGVuZ3RoID0gMCwgaS5lLiB0aGUgY29udGVudCBzdGFydHMgd2l0aCB0aGUgc2FtZSB2YWx1ZXNcblxuICAgIHZhciBvbGRQb3MgPSB0aGlzLmV4dHJhY3RDb21tb24oYmVzdFBhdGhbMF0sIG5ld1N0cmluZywgb2xkU3RyaW5nLCAwKTtcblxuICAgIGlmIChiZXN0UGF0aFswXS5uZXdQb3MgKyAxID49IG5ld0xlbiAmJiBvbGRQb3MgKyAxID49IG9sZExlbikge1xuICAgICAgLy8gSWRlbnRpdHkgcGVyIHRoZSBlcXVhbGl0eSBhbmQgdG9rZW5pemVyXG4gICAgICByZXR1cm4gZG9uZShbe1xuICAgICAgICB2YWx1ZTogdGhpcy5qb2luKG5ld1N0cmluZyksXG4gICAgICAgIGNvdW50OiBuZXdTdHJpbmcubGVuZ3RoXG4gICAgICB9XSk7XG4gICAgfSAvLyBNYWluIHdvcmtlciBtZXRob2QuIGNoZWNrcyBhbGwgcGVybXV0YXRpb25zIG9mIGEgZ2l2ZW4gZWRpdCBsZW5ndGggZm9yIGFjY2VwdGFuY2UuXG5cblxuICAgIGZ1bmN0aW9uIGV4ZWNFZGl0TGVuZ3RoKCkge1xuICAgICAgZm9yICh2YXIgZGlhZ29uYWxQYXRoID0gLTEgKiBlZGl0TGVuZ3RoOyBkaWFnb25hbFBhdGggPD0gZWRpdExlbmd0aDsgZGlhZ29uYWxQYXRoICs9IDIpIHtcbiAgICAgICAgdmFyIGJhc2VQYXRoID0gdm9pZCAwO1xuXG4gICAgICAgIHZhciBhZGRQYXRoID0gYmVzdFBhdGhbZGlhZ29uYWxQYXRoIC0gMV0sXG4gICAgICAgICAgICByZW1vdmVQYXRoID0gYmVzdFBhdGhbZGlhZ29uYWxQYXRoICsgMV0sXG4gICAgICAgICAgICBfb2xkUG9zID0gKHJlbW92ZVBhdGggPyByZW1vdmVQYXRoLm5ld1BvcyA6IDApIC0gZGlhZ29uYWxQYXRoO1xuXG4gICAgICAgIGlmIChhZGRQYXRoKSB7XG4gICAgICAgICAgLy8gTm8gb25lIGVsc2UgaXMgZ29pbmcgdG8gYXR0ZW1wdCB0byB1c2UgdGhpcyB2YWx1ZSwgY2xlYXIgaXRcbiAgICAgICAgICBiZXN0UGF0aFtkaWFnb25hbFBhdGggLSAxXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjYW5BZGQgPSBhZGRQYXRoICYmIGFkZFBhdGgubmV3UG9zICsgMSA8IG5ld0xlbixcbiAgICAgICAgICAgIGNhblJlbW92ZSA9IHJlbW92ZVBhdGggJiYgMCA8PSBfb2xkUG9zICYmIF9vbGRQb3MgPCBvbGRMZW47XG5cbiAgICAgICAgaWYgKCFjYW5BZGQgJiYgIWNhblJlbW92ZSkge1xuICAgICAgICAgIC8vIElmIHRoaXMgcGF0aCBpcyBhIHRlcm1pbmFsIHRoZW4gcHJ1bmVcbiAgICAgICAgICBiZXN0UGF0aFtkaWFnb25hbFBhdGhdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIFNlbGVjdCB0aGUgZGlhZ29uYWwgdGhhdCB3ZSB3YW50IHRvIGJyYW5jaCBmcm9tLiBXZSBzZWxlY3QgdGhlIHByaW9yXG4gICAgICAgIC8vIHBhdGggd2hvc2UgcG9zaXRpb24gaW4gdGhlIG5ldyBzdHJpbmcgaXMgdGhlIGZhcnRoZXN0IGZyb20gdGhlIG9yaWdpblxuICAgICAgICAvLyBhbmQgZG9lcyBub3QgcGFzcyB0aGUgYm91bmRzIG9mIHRoZSBkaWZmIGdyYXBoXG5cblxuICAgICAgICBpZiAoIWNhbkFkZCB8fCBjYW5SZW1vdmUgJiYgYWRkUGF0aC5uZXdQb3MgPCByZW1vdmVQYXRoLm5ld1Bvcykge1xuICAgICAgICAgIGJhc2VQYXRoID0gY2xvbmVQYXRoKHJlbW92ZVBhdGgpO1xuICAgICAgICAgIHNlbGYucHVzaENvbXBvbmVudChiYXNlUGF0aC5jb21wb25lbnRzLCB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJhc2VQYXRoID0gYWRkUGF0aDsgLy8gTm8gbmVlZCB0byBjbG9uZSwgd2UndmUgcHVsbGVkIGl0IGZyb20gdGhlIGxpc3RcblxuICAgICAgICAgIGJhc2VQYXRoLm5ld1BvcysrO1xuICAgICAgICAgIHNlbGYucHVzaENvbXBvbmVudChiYXNlUGF0aC5jb21wb25lbnRzLCB0cnVlLCB1bmRlZmluZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgX29sZFBvcyA9IHNlbGYuZXh0cmFjdENvbW1vbihiYXNlUGF0aCwgbmV3U3RyaW5nLCBvbGRTdHJpbmcsIGRpYWdvbmFsUGF0aCk7IC8vIElmIHdlIGhhdmUgaGl0IHRoZSBlbmQgb2YgYm90aCBzdHJpbmdzLCB0aGVuIHdlIGFyZSBkb25lXG5cbiAgICAgICAgaWYgKGJhc2VQYXRoLm5ld1BvcyArIDEgPj0gbmV3TGVuICYmIF9vbGRQb3MgKyAxID49IG9sZExlbikge1xuICAgICAgICAgIHJldHVybiBkb25lKGJ1aWxkVmFsdWVzKHNlbGYsIGJhc2VQYXRoLmNvbXBvbmVudHMsIG5ld1N0cmluZywgb2xkU3RyaW5nLCBzZWxmLnVzZUxvbmdlc3RUb2tlbikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE90aGVyd2lzZSB0cmFjayB0aGlzIHBhdGggYXMgYSBwb3RlbnRpYWwgY2FuZGlkYXRlIGFuZCBjb250aW51ZS5cbiAgICAgICAgICBiZXN0UGF0aFtkaWFnb25hbFBhdGhdID0gYmFzZVBhdGg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZWRpdExlbmd0aCsrO1xuICAgIH0gLy8gUGVyZm9ybXMgdGhlIGxlbmd0aCBvZiBlZGl0IGl0ZXJhdGlvbi4gSXMgYSBiaXQgZnVnbHkgYXMgdGhpcyBoYXMgdG8gc3VwcG9ydCB0aGVcbiAgICAvLyBzeW5jIGFuZCBhc3luYyBtb2RlIHdoaWNoIGlzIG5ldmVyIGZ1bi4gTG9vcHMgb3ZlciBleGVjRWRpdExlbmd0aCB1bnRpbCBhIHZhbHVlXG4gICAgLy8gaXMgcHJvZHVjZWQsIG9yIHVudGlsIHRoZSBlZGl0IGxlbmd0aCBleGNlZWRzIG9wdGlvbnMubWF4RWRpdExlbmd0aCAoaWYgZ2l2ZW4pLFxuICAgIC8vIGluIHdoaWNoIGNhc2UgaXQgd2lsbCByZXR1cm4gdW5kZWZpbmVkLlxuXG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIChmdW5jdGlvbiBleGVjKCkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoZWRpdExlbmd0aCA+IG1heEVkaXRMZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghZXhlY0VkaXRMZW5ndGgoKSkge1xuICAgICAgICAgICAgZXhlYygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMCk7XG4gICAgICB9KSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAoZWRpdExlbmd0aCA8PSBtYXhFZGl0TGVuZ3RoKSB7XG4gICAgICAgIHZhciByZXQgPSBleGVjRWRpdExlbmd0aCgpO1xuXG4gICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwdXNoQ29tcG9uZW50OiBmdW5jdGlvbiBwdXNoQ29tcG9uZW50KGNvbXBvbmVudHMsIGFkZGVkLCByZW1vdmVkKSB7XG4gICAgdmFyIGxhc3QgPSBjb21wb25lbnRzW2NvbXBvbmVudHMubGVuZ3RoIC0gMV07XG5cbiAgICBpZiAobGFzdCAmJiBsYXN0LmFkZGVkID09PSBhZGRlZCAmJiBsYXN0LnJlbW92ZWQgPT09IHJlbW92ZWQpIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gY2xvbmUgaGVyZSBhcyB0aGUgY29tcG9uZW50IGNsb25lIG9wZXJhdGlvbiBpcyBqdXN0XG4gICAgICAvLyBhcyBzaGFsbG93IGFycmF5IGNsb25lXG4gICAgICBjb21wb25lbnRzW2NvbXBvbmVudHMubGVuZ3RoIC0gMV0gPSB7XG4gICAgICAgIGNvdW50OiBsYXN0LmNvdW50ICsgMSxcbiAgICAgICAgYWRkZWQ6IGFkZGVkLFxuICAgICAgICByZW1vdmVkOiByZW1vdmVkXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21wb25lbnRzLnB1c2goe1xuICAgICAgICBjb3VudDogMSxcbiAgICAgICAgYWRkZWQ6IGFkZGVkLFxuICAgICAgICByZW1vdmVkOiByZW1vdmVkXG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIGV4dHJhY3RDb21tb246IGZ1bmN0aW9uIGV4dHJhY3RDb21tb24oYmFzZVBhdGgsIG5ld1N0cmluZywgb2xkU3RyaW5nLCBkaWFnb25hbFBhdGgpIHtcbiAgICB2YXIgbmV3TGVuID0gbmV3U3RyaW5nLmxlbmd0aCxcbiAgICAgICAgb2xkTGVuID0gb2xkU3RyaW5nLmxlbmd0aCxcbiAgICAgICAgbmV3UG9zID0gYmFzZVBhdGgubmV3UG9zLFxuICAgICAgICBvbGRQb3MgPSBuZXdQb3MgLSBkaWFnb25hbFBhdGgsXG4gICAgICAgIGNvbW1vbkNvdW50ID0gMDtcblxuICAgIHdoaWxlIChuZXdQb3MgKyAxIDwgbmV3TGVuICYmIG9sZFBvcyArIDEgPCBvbGRMZW4gJiYgdGhpcy5lcXVhbHMobmV3U3RyaW5nW25ld1BvcyArIDFdLCBvbGRTdHJpbmdbb2xkUG9zICsgMV0pKSB7XG4gICAgICBuZXdQb3MrKztcbiAgICAgIG9sZFBvcysrO1xuICAgICAgY29tbW9uQ291bnQrKztcbiAgICB9XG5cbiAgICBpZiAoY29tbW9uQ291bnQpIHtcbiAgICAgIGJhc2VQYXRoLmNvbXBvbmVudHMucHVzaCh7XG4gICAgICAgIGNvdW50OiBjb21tb25Db3VudFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgYmFzZVBhdGgubmV3UG9zID0gbmV3UG9zO1xuICAgIHJldHVybiBvbGRQb3M7XG4gIH0sXG4gIGVxdWFsczogZnVuY3Rpb24gZXF1YWxzKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5jb21wYXJhdG9yKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmNvbXBhcmF0b3IobGVmdCwgcmlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbGVmdCA9PT0gcmlnaHQgfHwgdGhpcy5vcHRpb25zLmlnbm9yZUNhc2UgJiYgbGVmdC50b0xvd2VyQ2FzZSgpID09PSByaWdodC50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgfSxcbiAgcmVtb3ZlRW1wdHk6IGZ1bmN0aW9uIHJlbW92ZUVtcHR5KGFycmF5KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFycmF5W2ldKSB7XG4gICAgICAgIHJldC5wdXNoKGFycmF5W2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9LFxuICBjYXN0SW5wdXQ6IGZ1bmN0aW9uIGNhc3RJbnB1dCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSxcbiAgdG9rZW5pemU6IGZ1bmN0aW9uIHRva2VuaXplKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnNwbGl0KCcnKTtcbiAgfSxcbiAgam9pbjogZnVuY3Rpb24gam9pbihjaGFycykge1xuICAgIHJldHVybiBjaGFycy5qb2luKCcnKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gYnVpbGRWYWx1ZXMoZGlmZiwgY29tcG9uZW50cywgbmV3U3RyaW5nLCBvbGRTdHJpbmcsIHVzZUxvbmdlc3RUb2tlbikge1xuICB2YXIgY29tcG9uZW50UG9zID0gMCxcbiAgICAgIGNvbXBvbmVudExlbiA9IGNvbXBvbmVudHMubGVuZ3RoLFxuICAgICAgbmV3UG9zID0gMCxcbiAgICAgIG9sZFBvcyA9IDA7XG5cbiAgZm9yICg7IGNvbXBvbmVudFBvcyA8IGNvbXBvbmVudExlbjsgY29tcG9uZW50UG9zKyspIHtcbiAgICB2YXIgY29tcG9uZW50ID0gY29tcG9uZW50c1tjb21wb25lbnRQb3NdO1xuXG4gICAgaWYgKCFjb21wb25lbnQucmVtb3ZlZCkge1xuICAgICAgaWYgKCFjb21wb25lbnQuYWRkZWQgJiYgdXNlTG9uZ2VzdFRva2VuKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG5ld1N0cmluZy5zbGljZShuZXdQb3MsIG5ld1BvcyArIGNvbXBvbmVudC5jb3VudCk7XG4gICAgICAgIHZhbHVlID0gdmFsdWUubWFwKGZ1bmN0aW9uICh2YWx1ZSwgaSkge1xuICAgICAgICAgIHZhciBvbGRWYWx1ZSA9IG9sZFN0cmluZ1tvbGRQb3MgKyBpXTtcbiAgICAgICAgICByZXR1cm4gb2xkVmFsdWUubGVuZ3RoID4gdmFsdWUubGVuZ3RoID8gb2xkVmFsdWUgOiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbXBvbmVudC52YWx1ZSA9IGRpZmYuam9pbih2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21wb25lbnQudmFsdWUgPSBkaWZmLmpvaW4obmV3U3RyaW5nLnNsaWNlKG5ld1BvcywgbmV3UG9zICsgY29tcG9uZW50LmNvdW50KSk7XG4gICAgICB9XG5cbiAgICAgIG5ld1BvcyArPSBjb21wb25lbnQuY291bnQ7IC8vIENvbW1vbiBjYXNlXG5cbiAgICAgIGlmICghY29tcG9uZW50LmFkZGVkKSB7XG4gICAgICAgIG9sZFBvcyArPSBjb21wb25lbnQuY291bnQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXBvbmVudC52YWx1ZSA9IGRpZmYuam9pbihvbGRTdHJpbmcuc2xpY2Uob2xkUG9zLCBvbGRQb3MgKyBjb21wb25lbnQuY291bnQpKTtcbiAgICAgIG9sZFBvcyArPSBjb21wb25lbnQuY291bnQ7IC8vIFJldmVyc2UgYWRkIGFuZCByZW1vdmUgc28gcmVtb3ZlcyBhcmUgb3V0cHV0IGZpcnN0IHRvIG1hdGNoIGNvbW1vbiBjb252ZW50aW9uXG4gICAgICAvLyBUaGUgZGlmZmluZyBhbGdvcml0aG0gaXMgdGllZCB0byBhZGQgdGhlbiByZW1vdmUgb3V0cHV0IGFuZCB0aGlzIGlzIHRoZSBzaW1wbGVzdFxuICAgICAgLy8gcm91dGUgdG8gZ2V0IHRoZSBkZXNpcmVkIG91dHB1dCB3aXRoIG1pbmltYWwgb3ZlcmhlYWQuXG5cbiAgICAgIGlmIChjb21wb25lbnRQb3MgJiYgY29tcG9uZW50c1tjb21wb25lbnRQb3MgLSAxXS5hZGRlZCkge1xuICAgICAgICB2YXIgdG1wID0gY29tcG9uZW50c1tjb21wb25lbnRQb3MgLSAxXTtcbiAgICAgICAgY29tcG9uZW50c1tjb21wb25lbnRQb3MgLSAxXSA9IGNvbXBvbmVudHNbY29tcG9uZW50UG9zXTtcbiAgICAgICAgY29tcG9uZW50c1tjb21wb25lbnRQb3NdID0gdG1wO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBTcGVjaWFsIGNhc2UgaGFuZGxlIGZvciB3aGVuIG9uZSB0ZXJtaW5hbCBpcyBpZ25vcmVkIChpLmUuIHdoaXRlc3BhY2UpLlxuICAvLyBGb3IgdGhpcyBjYXNlIHdlIG1lcmdlIHRoZSB0ZXJtaW5hbCBpbnRvIHRoZSBwcmlvciBzdHJpbmcgYW5kIGRyb3AgdGhlIGNoYW5nZS5cbiAgLy8gVGhpcyBpcyBvbmx5IGF2YWlsYWJsZSBmb3Igc3RyaW5nIG1vZGUuXG5cblxuICB2YXIgbGFzdENvbXBvbmVudCA9IGNvbXBvbmVudHNbY29tcG9uZW50TGVuIC0gMV07XG5cbiAgaWYgKGNvbXBvbmVudExlbiA+IDEgJiYgdHlwZW9mIGxhc3RDb21wb25lbnQudmFsdWUgPT09ICdzdHJpbmcnICYmIChsYXN0Q29tcG9uZW50LmFkZGVkIHx8IGxhc3RDb21wb25lbnQucmVtb3ZlZCkgJiYgZGlmZi5lcXVhbHMoJycsIGxhc3RDb21wb25lbnQudmFsdWUpKSB7XG4gICAgY29tcG9uZW50c1tjb21wb25lbnRMZW4gLSAyXS52YWx1ZSArPSBsYXN0Q29tcG9uZW50LnZhbHVlO1xuICAgIGNvbXBvbmVudHMucG9wKCk7XG4gIH1cblxuICByZXR1cm4gY29tcG9uZW50cztcbn1cblxuZnVuY3Rpb24gY2xvbmVQYXRoKHBhdGgpIHtcbiAgcmV0dXJuIHtcbiAgICBuZXdQb3M6IHBhdGgubmV3UG9zLFxuICAgIGNvbXBvbmVudHM6IHBhdGguY29tcG9uZW50cy5zbGljZSgwKVxuICB9O1xufVxuXG52YXIgY2hhcmFjdGVyRGlmZiA9IG5ldyBEaWZmKCk7XG5mdW5jdGlvbiBkaWZmQ2hhcnMob2xkU3RyLCBuZXdTdHIsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGNoYXJhY3RlckRpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlT3B0aW9ucyhvcHRpb25zLCBkZWZhdWx0cykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBkZWZhdWx0cy5jYWxsYmFjayA9IG9wdGlvbnM7XG4gIH0gZWxzZSBpZiAob3B0aW9ucykge1xuICAgIGZvciAodmFyIG5hbWUgaW4gb3B0aW9ucykge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIGRlZmF1bHRzW25hbWVdID0gb3B0aW9uc1tuYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGVmYXVsdHM7XG59XG5cbi8vXG4vLyBSYW5nZXMgYW5kIGV4Y2VwdGlvbnM6XG4vLyBMYXRpbi0xIFN1cHBsZW1lbnQsIDAwODDigJMwMEZGXG4vLyAgLSBVKzAwRDcgIMOXIE11bHRpcGxpY2F0aW9uIHNpZ25cbi8vICAtIFUrMDBGNyAgw7cgRGl2aXNpb24gc2lnblxuLy8gTGF0aW4gRXh0ZW5kZWQtQSwgMDEwMOKAkzAxN0Zcbi8vIExhdGluIEV4dGVuZGVkLUIsIDAxODDigJMwMjRGXG4vLyBJUEEgRXh0ZW5zaW9ucywgMDI1MOKAkzAyQUZcbi8vIFNwYWNpbmcgTW9kaWZpZXIgTGV0dGVycywgMDJCMOKAkzAyRkZcbi8vICAtIFUrMDJDNyAgy4cgJiM3MTE7ICBDYXJvblxuLy8gIC0gVSswMkQ4ICDLmCAmIzcyODsgIEJyZXZlXG4vLyAgLSBVKzAyRDkgIMuZICYjNzI5OyAgRG90IEFib3ZlXG4vLyAgLSBVKzAyREEgIMuaICYjNzMwOyAgUmluZyBBYm92ZVxuLy8gIC0gVSswMkRCICDLmyAmIzczMTsgIE9nb25la1xuLy8gIC0gVSswMkRDICDLnCAmIzczMjsgIFNtYWxsIFRpbGRlXG4vLyAgLSBVKzAyREQgIMudICYjNzMzOyAgRG91YmxlIEFjdXRlIEFjY2VudFxuLy8gTGF0aW4gRXh0ZW5kZWQgQWRkaXRpb25hbCwgMUUwMOKAkzFFRkZcblxudmFyIGV4dGVuZGVkV29yZENoYXJzID0gL15bQS1aYS16XFx4QzAtXFx1MDJDNlxcdTAyQzgtXFx1MDJEN1xcdTAyREUtXFx1MDJGRlxcdTFFMDAtXFx1MUVGRl0rJC87XG52YXIgcmVXaGl0ZXNwYWNlID0gL1xcUy87XG52YXIgd29yZERpZmYgPSBuZXcgRGlmZigpO1xuXG53b3JkRGlmZi5lcXVhbHMgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5pZ25vcmVDYXNlKSB7XG4gICAgbGVmdCA9IGxlZnQudG9Mb3dlckNhc2UoKTtcbiAgICByaWdodCA9IHJpZ2h0LnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICByZXR1cm4gbGVmdCA9PT0gcmlnaHQgfHwgdGhpcy5vcHRpb25zLmlnbm9yZVdoaXRlc3BhY2UgJiYgIXJlV2hpdGVzcGFjZS50ZXN0KGxlZnQpICYmICFyZVdoaXRlc3BhY2UudGVzdChyaWdodCk7XG59O1xuXG53b3JkRGlmZi50b2tlbml6ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAvLyBBbGwgd2hpdGVzcGFjZSBzeW1ib2xzIGV4Y2VwdCBuZXdsaW5lIGdyb3VwIGludG8gb25lIHRva2VuLCBlYWNoIG5ld2xpbmUgLSBpbiBzZXBhcmF0ZSB0b2tlblxuICB2YXIgdG9rZW5zID0gdmFsdWUuc3BsaXQoLyhbXlxcU1xcclxcbl0rfFsoKVtcXF17fSdcIlxcclxcbl18XFxiKS8pOyAvLyBKb2luIHRoZSBib3VuZGFyeSBzcGxpdHMgdGhhdCB3ZSBkbyBub3QgY29uc2lkZXIgdG8gYmUgYm91bmRhcmllcy4gVGhpcyBpcyBwcmltYXJpbHkgdGhlIGV4dGVuZGVkIExhdGluIGNoYXJhY3RlciBzZXQuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBhbiBlbXB0eSBzdHJpbmcgaW4gdGhlIG5leHQgZmllbGQgYW5kIHdlIGhhdmUgb25seSB3b3JkIGNoYXJzIGJlZm9yZSBhbmQgYWZ0ZXIsIG1lcmdlXG4gICAgaWYgKCF0b2tlbnNbaSArIDFdICYmIHRva2Vuc1tpICsgMl0gJiYgZXh0ZW5kZWRXb3JkQ2hhcnMudGVzdCh0b2tlbnNbaV0pICYmIGV4dGVuZGVkV29yZENoYXJzLnRlc3QodG9rZW5zW2kgKyAyXSkpIHtcbiAgICAgIHRva2Vuc1tpXSArPSB0b2tlbnNbaSArIDJdO1xuICAgICAgdG9rZW5zLnNwbGljZShpICsgMSwgMik7XG4gICAgICBpLS07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRva2Vucztcbn07XG5cbmZ1bmN0aW9uIGRpZmZXb3JkcyhvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucykge1xuICBvcHRpb25zID0gZ2VuZXJhdGVPcHRpb25zKG9wdGlvbnMsIHtcbiAgICBpZ25vcmVXaGl0ZXNwYWNlOiB0cnVlXG4gIH0pO1xuICByZXR1cm4gd29yZERpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBkaWZmV29yZHNXaXRoU3BhY2Uob2xkU3RyLCBuZXdTdHIsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHdvcmREaWZmLmRpZmYob2xkU3RyLCBuZXdTdHIsIG9wdGlvbnMpO1xufVxuXG52YXIgbGluZURpZmYgPSBuZXcgRGlmZigpO1xuXG5saW5lRGlmZi50b2tlbml6ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB2YXIgcmV0TGluZXMgPSBbXSxcbiAgICAgIGxpbmVzQW5kTmV3bGluZXMgPSB2YWx1ZS5zcGxpdCgvKFxcbnxcXHJcXG4pLyk7IC8vIElnbm9yZSB0aGUgZmluYWwgZW1wdHkgdG9rZW4gdGhhdCBvY2N1cnMgaWYgdGhlIHN0cmluZyBlbmRzIHdpdGggYSBuZXcgbGluZVxuXG4gIGlmICghbGluZXNBbmROZXdsaW5lc1tsaW5lc0FuZE5ld2xpbmVzLmxlbmd0aCAtIDFdKSB7XG4gICAgbGluZXNBbmROZXdsaW5lcy5wb3AoKTtcbiAgfSAvLyBNZXJnZSB0aGUgY29udGVudCBhbmQgbGluZSBzZXBhcmF0b3JzIGludG8gc2luZ2xlIHRva2Vuc1xuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lc0FuZE5ld2xpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGxpbmUgPSBsaW5lc0FuZE5ld2xpbmVzW2ldO1xuXG4gICAgaWYgKGkgJSAyICYmICF0aGlzLm9wdGlvbnMubmV3bGluZUlzVG9rZW4pIHtcbiAgICAgIHJldExpbmVzW3JldExpbmVzLmxlbmd0aCAtIDFdICs9IGxpbmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaWdub3JlV2hpdGVzcGFjZSkge1xuICAgICAgICBsaW5lID0gbGluZS50cmltKCk7XG4gICAgICB9XG5cbiAgICAgIHJldExpbmVzLnB1c2gobGluZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldExpbmVzO1xufTtcblxuZnVuY3Rpb24gZGlmZkxpbmVzKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjaykge1xuICByZXR1cm4gbGluZURpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spO1xufVxuZnVuY3Rpb24gZGlmZlRyaW1tZWRMaW5lcyhvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spIHtcbiAgdmFyIG9wdGlvbnMgPSBnZW5lcmF0ZU9wdGlvbnMoY2FsbGJhY2ssIHtcbiAgICBpZ25vcmVXaGl0ZXNwYWNlOiB0cnVlXG4gIH0pO1xuICByZXR1cm4gbGluZURpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucyk7XG59XG5cbnZhciBzZW50ZW5jZURpZmYgPSBuZXcgRGlmZigpO1xuXG5zZW50ZW5jZURpZmYudG9rZW5pemUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLnNwbGl0KC8oXFxTLis/Wy4hP10pKD89XFxzK3wkKS8pO1xufTtcblxuZnVuY3Rpb24gZGlmZlNlbnRlbmNlcyhvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHNlbnRlbmNlRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjayk7XG59XG5cbnZhciBjc3NEaWZmID0gbmV3IERpZmYoKTtcblxuY3NzRGlmZi50b2tlbml6ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUuc3BsaXQoLyhbe306OyxdfFxccyspLyk7XG59O1xuXG5mdW5jdGlvbiBkaWZmQ3NzKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjaykge1xuICByZXR1cm4gY3NzRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTtcbn1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICByZXR1cm4gYXJyMjtcbn1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxudmFyIG9iamVjdFByb3RvdHlwZVRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBqc29uRGlmZiA9IG5ldyBEaWZmKCk7IC8vIERpc2NyaW1pbmF0ZSBiZXR3ZWVuIHR3byBsaW5lcyBvZiBwcmV0dHktcHJpbnRlZCwgc2VyaWFsaXplZCBKU09OIHdoZXJlIG9uZSBvZiB0aGVtIGhhcyBhXG4vLyBkYW5nbGluZyBjb21tYSBhbmQgdGhlIG90aGVyIGRvZXNuJ3QuIFR1cm5zIG91dCBpbmNsdWRpbmcgdGhlIGRhbmdsaW5nIGNvbW1hIHlpZWxkcyB0aGUgbmljZXN0IG91dHB1dDpcblxuanNvbkRpZmYudXNlTG9uZ2VzdFRva2VuID0gdHJ1ZTtcbmpzb25EaWZmLnRva2VuaXplID0gbGluZURpZmYudG9rZW5pemU7XG5cbmpzb25EaWZmLmNhc3RJbnB1dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB2YXIgX3RoaXMkb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgIHVuZGVmaW5lZFJlcGxhY2VtZW50ID0gX3RoaXMkb3B0aW9ucy51bmRlZmluZWRSZXBsYWNlbWVudCxcbiAgICAgIF90aGlzJG9wdGlvbnMkc3RyaW5naSA9IF90aGlzJG9wdGlvbnMuc3RyaW5naWZ5UmVwbGFjZXIsXG4gICAgICBzdHJpbmdpZnlSZXBsYWNlciA9IF90aGlzJG9wdGlvbnMkc3RyaW5naSA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKGssIHYpIHtcbiAgICByZXR1cm4gdHlwZW9mIHYgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkUmVwbGFjZW1lbnQgOiB2O1xuICB9IDogX3RoaXMkb3B0aW9ucyRzdHJpbmdpO1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHZhbHVlIDogSlNPTi5zdHJpbmdpZnkoY2Fub25pY2FsaXplKHZhbHVlLCBudWxsLCBudWxsLCBzdHJpbmdpZnlSZXBsYWNlciksIHN0cmluZ2lmeVJlcGxhY2VyLCAnICAnKTtcbn07XG5cbmpzb25EaWZmLmVxdWFscyA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xuICByZXR1cm4gRGlmZi5wcm90b3R5cGUuZXF1YWxzLmNhbGwoanNvbkRpZmYsIGxlZnQucmVwbGFjZSgvLChbXFxyXFxuXSkvZywgJyQxJyksIHJpZ2h0LnJlcGxhY2UoLywoW1xcclxcbl0pL2csICckMScpKTtcbn07XG5cbmZ1bmN0aW9uIGRpZmZKc29uKG9sZE9iaiwgbmV3T2JqLCBvcHRpb25zKSB7XG4gIHJldHVybiBqc29uRGlmZi5kaWZmKG9sZE9iaiwgbmV3T2JqLCBvcHRpb25zKTtcbn0gLy8gVGhpcyBmdW5jdGlvbiBoYW5kbGVzIHRoZSBwcmVzZW5jZSBvZiBjaXJjdWxhciByZWZlcmVuY2VzIGJ5IGJhaWxpbmcgb3V0IHdoZW4gZW5jb3VudGVyaW5nIGFuXG4vLyBvYmplY3QgdGhhdCBpcyBhbHJlYWR5IG9uIHRoZSBcInN0YWNrXCIgb2YgaXRlbXMgYmVpbmcgcHJvY2Vzc2VkLiBBY2NlcHRzIGFuIG9wdGlvbmFsIHJlcGxhY2VyXG5cbmZ1bmN0aW9uIGNhbm9uaWNhbGl6ZShvYmosIHN0YWNrLCByZXBsYWNlbWVudFN0YWNrLCByZXBsYWNlciwga2V5KSB7XG4gIHN0YWNrID0gc3RhY2sgfHwgW107XG4gIHJlcGxhY2VtZW50U3RhY2sgPSByZXBsYWNlbWVudFN0YWNrIHx8IFtdO1xuXG4gIGlmIChyZXBsYWNlcikge1xuICAgIG9iaiA9IHJlcGxhY2VyKGtleSwgb2JqKTtcbiAgfVxuXG4gIHZhciBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGlmIChzdGFja1tpXSA9PT0gb2JqKSB7XG4gICAgICByZXR1cm4gcmVwbGFjZW1lbnRTdGFja1tpXTtcbiAgICB9XG4gIH1cblxuICB2YXIgY2Fub25pY2FsaXplZE9iajtcblxuICBpZiAoJ1tvYmplY3QgQXJyYXldJyA9PT0gb2JqZWN0UHJvdG90eXBlVG9TdHJpbmcuY2FsbChvYmopKSB7XG4gICAgc3RhY2sucHVzaChvYmopO1xuICAgIGNhbm9uaWNhbGl6ZWRPYmogPSBuZXcgQXJyYXkob2JqLmxlbmd0aCk7XG4gICAgcmVwbGFjZW1lbnRTdGFjay5wdXNoKGNhbm9uaWNhbGl6ZWRPYmopO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgY2Fub25pY2FsaXplZE9ialtpXSA9IGNhbm9uaWNhbGl6ZShvYmpbaV0sIHN0YWNrLCByZXBsYWNlbWVudFN0YWNrLCByZXBsYWNlciwga2V5KTtcbiAgICB9XG5cbiAgICBzdGFjay5wb3AoKTtcbiAgICByZXBsYWNlbWVudFN0YWNrLnBvcCgpO1xuICAgIHJldHVybiBjYW5vbmljYWxpemVkT2JqO1xuICB9XG5cbiAgaWYgKG9iaiAmJiBvYmoudG9KU09OKSB7XG4gICAgb2JqID0gb2JqLnRvSlNPTigpO1xuICB9XG5cbiAgaWYgKF90eXBlb2Yob2JqKSA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsKSB7XG4gICAgc3RhY2sucHVzaChvYmopO1xuICAgIGNhbm9uaWNhbGl6ZWRPYmogPSB7fTtcbiAgICByZXBsYWNlbWVudFN0YWNrLnB1c2goY2Fub25pY2FsaXplZE9iaik7XG5cbiAgICB2YXIgc29ydGVkS2V5cyA9IFtdLFxuICAgICAgICBfa2V5O1xuXG4gICAgZm9yIChfa2V5IGluIG9iaikge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoX2tleSkpIHtcbiAgICAgICAgc29ydGVkS2V5cy5wdXNoKF9rZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNvcnRlZEtleXMuc29ydCgpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHNvcnRlZEtleXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIF9rZXkgPSBzb3J0ZWRLZXlzW2ldO1xuICAgICAgY2Fub25pY2FsaXplZE9ialtfa2V5XSA9IGNhbm9uaWNhbGl6ZShvYmpbX2tleV0sIHN0YWNrLCByZXBsYWNlbWVudFN0YWNrLCByZXBsYWNlciwgX2tleSk7XG4gICAgfVxuXG4gICAgc3RhY2sucG9wKCk7XG4gICAgcmVwbGFjZW1lbnRTdGFjay5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBjYW5vbmljYWxpemVkT2JqID0gb2JqO1xuICB9XG5cbiAgcmV0dXJuIGNhbm9uaWNhbGl6ZWRPYmo7XG59XG5cbnZhciBhcnJheURpZmYgPSBuZXcgRGlmZigpO1xuXG5hcnJheURpZmYudG9rZW5pemUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLnNsaWNlKCk7XG59O1xuXG5hcnJheURpZmYuam9pbiA9IGFycmF5RGlmZi5yZW1vdmVFbXB0eSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59O1xuXG5mdW5jdGlvbiBkaWZmQXJyYXlzKG9sZEFyciwgbmV3QXJyLCBjYWxsYmFjaykge1xuICByZXR1cm4gYXJyYXlEaWZmLmRpZmYob2xkQXJyLCBuZXdBcnIsIGNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VQYXRjaCh1bmlEaWZmKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgdmFyIGRpZmZzdHIgPSB1bmlEaWZmLnNwbGl0KC9cXHJcXG58W1xcblxcdlxcZlxcclxceDg1XS8pLFxuICAgICAgZGVsaW1pdGVycyA9IHVuaURpZmYubWF0Y2goL1xcclxcbnxbXFxuXFx2XFxmXFxyXFx4ODVdL2cpIHx8IFtdLFxuICAgICAgbGlzdCA9IFtdLFxuICAgICAgaSA9IDA7XG5cbiAgZnVuY3Rpb24gcGFyc2VJbmRleCgpIHtcbiAgICB2YXIgaW5kZXggPSB7fTtcbiAgICBsaXN0LnB1c2goaW5kZXgpOyAvLyBQYXJzZSBkaWZmIG1ldGFkYXRhXG5cbiAgICB3aGlsZSAoaSA8IGRpZmZzdHIubGVuZ3RoKSB7XG4gICAgICB2YXIgbGluZSA9IGRpZmZzdHJbaV07IC8vIEZpbGUgaGVhZGVyIGZvdW5kLCBlbmQgcGFyc2luZyBkaWZmIG1ldGFkYXRhXG5cbiAgICAgIGlmICgvXihcXC1cXC1cXC18XFwrXFwrXFwrfEBAKVxccy8udGVzdChsaW5lKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gLy8gRGlmZiBpbmRleFxuXG5cbiAgICAgIHZhciBoZWFkZXIgPSAvXig/OkluZGV4OnxkaWZmKD86IC1yIFxcdyspKylcXHMrKC4rPylcXHMqJC8uZXhlYyhsaW5lKTtcblxuICAgICAgaWYgKGhlYWRlcikge1xuICAgICAgICBpbmRleC5pbmRleCA9IGhlYWRlclsxXTtcbiAgICAgIH1cblxuICAgICAgaSsrO1xuICAgIH0gLy8gUGFyc2UgZmlsZSBoZWFkZXJzIGlmIHRoZXkgYXJlIGRlZmluZWQuIFVuaWZpZWQgZGlmZiByZXF1aXJlcyB0aGVtLCBidXRcbiAgICAvLyB0aGVyZSdzIG5vIHRlY2huaWNhbCBpc3N1ZXMgdG8gaGF2ZSBhbiBpc29sYXRlZCBodW5rIHdpdGhvdXQgZmlsZSBoZWFkZXJcblxuXG4gICAgcGFyc2VGaWxlSGVhZGVyKGluZGV4KTtcbiAgICBwYXJzZUZpbGVIZWFkZXIoaW5kZXgpOyAvLyBQYXJzZSBodW5rc1xuXG4gICAgaW5kZXguaHVua3MgPSBbXTtcblxuICAgIHdoaWxlIChpIDwgZGlmZnN0ci5sZW5ndGgpIHtcbiAgICAgIHZhciBfbGluZSA9IGRpZmZzdHJbaV07XG5cbiAgICAgIGlmICgvXihJbmRleDp8ZGlmZnxcXC1cXC1cXC18XFwrXFwrXFwrKVxccy8udGVzdChfbGluZSkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKC9eQEAvLnRlc3QoX2xpbmUpKSB7XG4gICAgICAgIGluZGV4Lmh1bmtzLnB1c2gocGFyc2VIdW5rKCkpO1xuICAgICAgfSBlbHNlIGlmIChfbGluZSAmJiBvcHRpb25zLnN0cmljdCkge1xuICAgICAgICAvLyBJZ25vcmUgdW5leHBlY3RlZCBjb250ZW50IHVubGVzcyBpbiBzdHJpY3QgbW9kZVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbGluZSAnICsgKGkgKyAxKSArICcgJyArIEpTT04uc3RyaW5naWZ5KF9saW5lKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFBhcnNlcyB0aGUgLS0tIGFuZCArKysgaGVhZGVycywgaWYgbm9uZSBhcmUgZm91bmQsIG5vIGxpbmVzXG4gIC8vIGFyZSBjb25zdW1lZC5cblxuXG4gIGZ1bmN0aW9uIHBhcnNlRmlsZUhlYWRlcihpbmRleCkge1xuICAgIHZhciBmaWxlSGVhZGVyID0gL14oLS0tfFxcK1xcK1xcKylcXHMrKC4qKSQvLmV4ZWMoZGlmZnN0cltpXSk7XG5cbiAgICBpZiAoZmlsZUhlYWRlcikge1xuICAgICAgdmFyIGtleVByZWZpeCA9IGZpbGVIZWFkZXJbMV0gPT09ICctLS0nID8gJ29sZCcgOiAnbmV3JztcbiAgICAgIHZhciBkYXRhID0gZmlsZUhlYWRlclsyXS5zcGxpdCgnXFx0JywgMik7XG4gICAgICB2YXIgZmlsZU5hbWUgPSBkYXRhWzBdLnJlcGxhY2UoL1xcXFxcXFxcL2csICdcXFxcJyk7XG5cbiAgICAgIGlmICgvXlwiLipcIiQvLnRlc3QoZmlsZU5hbWUpKSB7XG4gICAgICAgIGZpbGVOYW1lID0gZmlsZU5hbWUuc3Vic3RyKDEsIGZpbGVOYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgfVxuXG4gICAgICBpbmRleFtrZXlQcmVmaXggKyAnRmlsZU5hbWUnXSA9IGZpbGVOYW1lO1xuICAgICAgaW5kZXhba2V5UHJlZml4ICsgJ0hlYWRlciddID0gKGRhdGFbMV0gfHwgJycpLnRyaW0oKTtcbiAgICAgIGkrKztcbiAgICB9XG4gIH0gLy8gUGFyc2VzIGEgaHVua1xuICAvLyBUaGlzIGFzc3VtZXMgdGhhdCB3ZSBhcmUgYXQgdGhlIHN0YXJ0IG9mIGEgaHVuay5cblxuXG4gIGZ1bmN0aW9uIHBhcnNlSHVuaygpIHtcbiAgICB2YXIgY2h1bmtIZWFkZXJJbmRleCA9IGksXG4gICAgICAgIGNodW5rSGVhZGVyTGluZSA9IGRpZmZzdHJbaSsrXSxcbiAgICAgICAgY2h1bmtIZWFkZXIgPSBjaHVua0hlYWRlckxpbmUuc3BsaXQoL0BAIC0oXFxkKykoPzosKFxcZCspKT8gXFwrKFxcZCspKD86LChcXGQrKSk/IEBALyk7XG4gICAgdmFyIGh1bmsgPSB7XG4gICAgICBvbGRTdGFydDogK2NodW5rSGVhZGVyWzFdLFxuICAgICAgb2xkTGluZXM6IHR5cGVvZiBjaHVua0hlYWRlclsyXSA9PT0gJ3VuZGVmaW5lZCcgPyAxIDogK2NodW5rSGVhZGVyWzJdLFxuICAgICAgbmV3U3RhcnQ6ICtjaHVua0hlYWRlclszXSxcbiAgICAgIG5ld0xpbmVzOiB0eXBlb2YgY2h1bmtIZWFkZXJbNF0gPT09ICd1bmRlZmluZWQnID8gMSA6ICtjaHVua0hlYWRlcls0XSxcbiAgICAgIGxpbmVzOiBbXSxcbiAgICAgIGxpbmVkZWxpbWl0ZXJzOiBbXVxuICAgIH07IC8vIFVuaWZpZWQgRGlmZiBGb3JtYXQgcXVpcms6IElmIHRoZSBjaHVuayBzaXplIGlzIDAsXG4gICAgLy8gdGhlIGZpcnN0IG51bWJlciBpcyBvbmUgbG93ZXIgdGhhbiBvbmUgd291bGQgZXhwZWN0LlxuICAgIC8vIGh0dHBzOi8vd3d3LmFydGltYS5jb20vd2VibG9ncy92aWV3cG9zdC5qc3A/dGhyZWFkPTE2NDI5M1xuXG4gICAgaWYgKGh1bmsub2xkTGluZXMgPT09IDApIHtcbiAgICAgIGh1bmsub2xkU3RhcnQgKz0gMTtcbiAgICB9XG5cbiAgICBpZiAoaHVuay5uZXdMaW5lcyA9PT0gMCkge1xuICAgICAgaHVuay5uZXdTdGFydCArPSAxO1xuICAgIH1cblxuICAgIHZhciBhZGRDb3VudCA9IDAsXG4gICAgICAgIHJlbW92ZUNvdW50ID0gMDtcblxuICAgIGZvciAoOyBpIDwgZGlmZnN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gTGluZXMgc3RhcnRpbmcgd2l0aCAnLS0tJyBjb3VsZCBiZSBtaXN0YWtlbiBmb3IgdGhlIFwicmVtb3ZlIGxpbmVcIiBvcGVyYXRpb25cbiAgICAgIC8vIEJ1dCB0aGV5IGNvdWxkIGJlIHRoZSBoZWFkZXIgZm9yIHRoZSBuZXh0IGZpbGUuIFRoZXJlZm9yZSBwcnVuZSBzdWNoIGNhc2VzIG91dC5cbiAgICAgIGlmIChkaWZmc3RyW2ldLmluZGV4T2YoJy0tLSAnKSA9PT0gMCAmJiBpICsgMiA8IGRpZmZzdHIubGVuZ3RoICYmIGRpZmZzdHJbaSArIDFdLmluZGV4T2YoJysrKyAnKSA9PT0gMCAmJiBkaWZmc3RyW2kgKyAyXS5pbmRleE9mKCdAQCcpID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3BlcmF0aW9uID0gZGlmZnN0cltpXS5sZW5ndGggPT0gMCAmJiBpICE9IGRpZmZzdHIubGVuZ3RoIC0gMSA/ICcgJyA6IGRpZmZzdHJbaV1bMF07XG5cbiAgICAgIGlmIChvcGVyYXRpb24gPT09ICcrJyB8fCBvcGVyYXRpb24gPT09ICctJyB8fCBvcGVyYXRpb24gPT09ICcgJyB8fCBvcGVyYXRpb24gPT09ICdcXFxcJykge1xuICAgICAgICBodW5rLmxpbmVzLnB1c2goZGlmZnN0cltpXSk7XG4gICAgICAgIGh1bmsubGluZWRlbGltaXRlcnMucHVzaChkZWxpbWl0ZXJzW2ldIHx8ICdcXG4nKTtcblxuICAgICAgICBpZiAob3BlcmF0aW9uID09PSAnKycpIHtcbiAgICAgICAgICBhZGRDb3VudCsrO1xuICAgICAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbiA9PT0gJy0nKSB7XG4gICAgICAgICAgcmVtb3ZlQ291bnQrKztcbiAgICAgICAgfSBlbHNlIGlmIChvcGVyYXRpb24gPT09ICcgJykge1xuICAgICAgICAgIGFkZENvdW50Kys7XG4gICAgICAgICAgcmVtb3ZlQ291bnQrKztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSAvLyBIYW5kbGUgdGhlIGVtcHR5IGJsb2NrIGNvdW50IGNhc2VcblxuXG4gICAgaWYgKCFhZGRDb3VudCAmJiBodW5rLm5ld0xpbmVzID09PSAxKSB7XG4gICAgICBodW5rLm5ld0xpbmVzID0gMDtcbiAgICB9XG5cbiAgICBpZiAoIXJlbW92ZUNvdW50ICYmIGh1bmsub2xkTGluZXMgPT09IDEpIHtcbiAgICAgIGh1bmsub2xkTGluZXMgPSAwO1xuICAgIH0gLy8gUGVyZm9ybSBvcHRpb25hbCBzYW5pdHkgY2hlY2tpbmdcblxuXG4gICAgaWYgKG9wdGlvbnMuc3RyaWN0KSB7XG4gICAgICBpZiAoYWRkQ291bnQgIT09IGh1bmsubmV3TGluZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBZGRlZCBsaW5lIGNvdW50IGRpZCBub3QgbWF0Y2ggZm9yIGh1bmsgYXQgbGluZSAnICsgKGNodW5rSGVhZGVySW5kZXggKyAxKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZW1vdmVDb3VudCAhPT0gaHVuay5vbGRMaW5lcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlbW92ZWQgbGluZSBjb3VudCBkaWQgbm90IG1hdGNoIGZvciBodW5rIGF0IGxpbmUgJyArIChjaHVua0hlYWRlckluZGV4ICsgMSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBodW5rO1xuICB9XG5cbiAgd2hpbGUgKGkgPCBkaWZmc3RyLmxlbmd0aCkge1xuICAgIHBhcnNlSW5kZXgoKTtcbiAgfVxuXG4gIHJldHVybiBsaXN0O1xufVxuXG4vLyBJdGVyYXRvciB0aGF0IHRyYXZlcnNlcyBpbiB0aGUgcmFuZ2Ugb2YgW21pbiwgbWF4XSwgc3RlcHBpbmdcbi8vIGJ5IGRpc3RhbmNlIGZyb20gYSBnaXZlbiBzdGFydCBwb3NpdGlvbi4gSS5lLiBmb3IgWzAsIDRdLCB3aXRoXG4vLyBzdGFydCBvZiAyLCB0aGlzIHdpbGwgaXRlcmF0ZSAyLCAzLCAxLCA0LCAwLlxuZnVuY3Rpb24gZGlzdGFuY2VJdGVyYXRvciAoc3RhcnQsIG1pbkxpbmUsIG1heExpbmUpIHtcbiAgdmFyIHdhbnRGb3J3YXJkID0gdHJ1ZSxcbiAgICAgIGJhY2t3YXJkRXhoYXVzdGVkID0gZmFsc2UsXG4gICAgICBmb3J3YXJkRXhoYXVzdGVkID0gZmFsc2UsXG4gICAgICBsb2NhbE9mZnNldCA9IDE7XG4gIHJldHVybiBmdW5jdGlvbiBpdGVyYXRvcigpIHtcbiAgICBpZiAod2FudEZvcndhcmQgJiYgIWZvcndhcmRFeGhhdXN0ZWQpIHtcbiAgICAgIGlmIChiYWNrd2FyZEV4aGF1c3RlZCkge1xuICAgICAgICBsb2NhbE9mZnNldCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FudEZvcndhcmQgPSBmYWxzZTtcbiAgICAgIH0gLy8gQ2hlY2sgaWYgdHJ5aW5nIHRvIGZpdCBiZXlvbmQgdGV4dCBsZW5ndGgsIGFuZCBpZiBub3QsIGNoZWNrIGl0IGZpdHNcbiAgICAgIC8vIGFmdGVyIG9mZnNldCBsb2NhdGlvbiAob3IgZGVzaXJlZCBsb2NhdGlvbiBvbiBmaXJzdCBpdGVyYXRpb24pXG5cblxuICAgICAgaWYgKHN0YXJ0ICsgbG9jYWxPZmZzZXQgPD0gbWF4TGluZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxPZmZzZXQ7XG4gICAgICB9XG5cbiAgICAgIGZvcndhcmRFeGhhdXN0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICghYmFja3dhcmRFeGhhdXN0ZWQpIHtcbiAgICAgIGlmICghZm9yd2FyZEV4aGF1c3RlZCkge1xuICAgICAgICB3YW50Rm9yd2FyZCA9IHRydWU7XG4gICAgICB9IC8vIENoZWNrIGlmIHRyeWluZyB0byBmaXQgYmVmb3JlIHRleHQgYmVnaW5uaW5nLCBhbmQgaWYgbm90LCBjaGVjayBpdCBmaXRzXG4gICAgICAvLyBiZWZvcmUgb2Zmc2V0IGxvY2F0aW9uXG5cblxuICAgICAgaWYgKG1pbkxpbmUgPD0gc3RhcnQgLSBsb2NhbE9mZnNldCkge1xuICAgICAgICByZXR1cm4gLWxvY2FsT2Zmc2V0Kys7XG4gICAgICB9XG5cbiAgICAgIGJhY2t3YXJkRXhoYXVzdGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBpdGVyYXRvcigpO1xuICAgIH0gLy8gV2UgdHJpZWQgdG8gZml0IGh1bmsgYmVmb3JlIHRleHQgYmVnaW5uaW5nIGFuZCBiZXlvbmQgdGV4dCBsZW5ndGgsIHRoZW5cbiAgICAvLyBodW5rIGNhbid0IGZpdCBvbiB0aGUgdGV4dC4gUmV0dXJuIHVuZGVmaW5lZFxuXG4gIH07XG59XG5cbmZ1bmN0aW9uIGFwcGx5UGF0Y2goc291cmNlLCB1bmlEaWZmKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICBpZiAodHlwZW9mIHVuaURpZmYgPT09ICdzdHJpbmcnKSB7XG4gICAgdW5pRGlmZiA9IHBhcnNlUGF0Y2godW5pRGlmZik7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh1bmlEaWZmKSkge1xuICAgIGlmICh1bmlEaWZmLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYXBwbHlQYXRjaCBvbmx5IHdvcmtzIHdpdGggYSBzaW5nbGUgaW5wdXQuJyk7XG4gICAgfVxuXG4gICAgdW5pRGlmZiA9IHVuaURpZmZbMF07XG4gIH0gLy8gQXBwbHkgdGhlIGRpZmYgdG8gdGhlIGlucHV0XG5cblxuICB2YXIgbGluZXMgPSBzb3VyY2Uuc3BsaXQoL1xcclxcbnxbXFxuXFx2XFxmXFxyXFx4ODVdLyksXG4gICAgICBkZWxpbWl0ZXJzID0gc291cmNlLm1hdGNoKC9cXHJcXG58W1xcblxcdlxcZlxcclxceDg1XS9nKSB8fCBbXSxcbiAgICAgIGh1bmtzID0gdW5pRGlmZi5odW5rcyxcbiAgICAgIGNvbXBhcmVMaW5lID0gb3B0aW9ucy5jb21wYXJlTGluZSB8fCBmdW5jdGlvbiAobGluZU51bWJlciwgbGluZSwgb3BlcmF0aW9uLCBwYXRjaENvbnRlbnQpIHtcbiAgICByZXR1cm4gbGluZSA9PT0gcGF0Y2hDb250ZW50O1xuICB9LFxuICAgICAgZXJyb3JDb3VudCA9IDAsXG4gICAgICBmdXp6RmFjdG9yID0gb3B0aW9ucy5mdXp6RmFjdG9yIHx8IDAsXG4gICAgICBtaW5MaW5lID0gMCxcbiAgICAgIG9mZnNldCA9IDAsXG4gICAgICByZW1vdmVFT0ZOTCxcbiAgICAgIGFkZEVPRk5MO1xuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBodW5rIGV4YWN0bHkgZml0cyBvbiB0aGUgcHJvdmlkZWQgbG9jYXRpb25cbiAgICovXG5cblxuICBmdW5jdGlvbiBodW5rRml0cyhodW5rLCB0b1Bvcykge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgaHVuay5saW5lcy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIGxpbmUgPSBodW5rLmxpbmVzW2pdLFxuICAgICAgICAgIG9wZXJhdGlvbiA9IGxpbmUubGVuZ3RoID4gMCA/IGxpbmVbMF0gOiAnICcsXG4gICAgICAgICAgY29udGVudCA9IGxpbmUubGVuZ3RoID4gMCA/IGxpbmUuc3Vic3RyKDEpIDogbGluZTtcblxuICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gJyAnIHx8IG9wZXJhdGlvbiA9PT0gJy0nKSB7XG4gICAgICAgIC8vIENvbnRleHQgc2FuaXR5IGNoZWNrXG4gICAgICAgIGlmICghY29tcGFyZUxpbmUodG9Qb3MgKyAxLCBsaW5lc1t0b1Bvc10sIG9wZXJhdGlvbiwgY29udGVudCkpIHtcbiAgICAgICAgICBlcnJvckNvdW50Kys7XG5cbiAgICAgICAgICBpZiAoZXJyb3JDb3VudCA+IGZ1enpGYWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0b1BvcysrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIFNlYXJjaCBiZXN0IGZpdCBvZmZzZXRzIGZvciBlYWNoIGh1bmsgYmFzZWQgb24gdGhlIHByZXZpb3VzIG9uZXNcblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaHVuayA9IGh1bmtzW2ldLFxuICAgICAgICBtYXhMaW5lID0gbGluZXMubGVuZ3RoIC0gaHVuay5vbGRMaW5lcyxcbiAgICAgICAgbG9jYWxPZmZzZXQgPSAwLFxuICAgICAgICB0b1BvcyA9IG9mZnNldCArIGh1bmsub2xkU3RhcnQgLSAxO1xuICAgIHZhciBpdGVyYXRvciA9IGRpc3RhbmNlSXRlcmF0b3IodG9Qb3MsIG1pbkxpbmUsIG1heExpbmUpO1xuXG4gICAgZm9yICg7IGxvY2FsT2Zmc2V0ICE9PSB1bmRlZmluZWQ7IGxvY2FsT2Zmc2V0ID0gaXRlcmF0b3IoKSkge1xuICAgICAgaWYgKGh1bmtGaXRzKGh1bmssIHRvUG9zICsgbG9jYWxPZmZzZXQpKSB7XG4gICAgICAgIGh1bmsub2Zmc2V0ID0gb2Zmc2V0ICs9IGxvY2FsT2Zmc2V0O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobG9jYWxPZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gU2V0IGxvd2VyIHRleHQgbGltaXQgdG8gZW5kIG9mIHRoZSBjdXJyZW50IGh1bmssIHNvIG5leHQgb25lcyBkb24ndCB0cnlcbiAgICAvLyB0byBmaXQgb3ZlciBhbHJlYWR5IHBhdGNoZWQgdGV4dFxuXG5cbiAgICBtaW5MaW5lID0gaHVuay5vZmZzZXQgKyBodW5rLm9sZFN0YXJ0ICsgaHVuay5vbGRMaW5lcztcbiAgfSAvLyBBcHBseSBwYXRjaCBodW5rc1xuXG5cbiAgdmFyIGRpZmZPZmZzZXQgPSAwO1xuXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBodW5rcy5sZW5ndGg7IF9pKyspIHtcbiAgICB2YXIgX2h1bmsgPSBodW5rc1tfaV0sXG4gICAgICAgIF90b1BvcyA9IF9odW5rLm9sZFN0YXJ0ICsgX2h1bmsub2Zmc2V0ICsgZGlmZk9mZnNldCAtIDE7XG5cbiAgICBkaWZmT2Zmc2V0ICs9IF9odW5rLm5ld0xpbmVzIC0gX2h1bmsub2xkTGluZXM7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IF9odW5rLmxpbmVzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgbGluZSA9IF9odW5rLmxpbmVzW2pdLFxuICAgICAgICAgIG9wZXJhdGlvbiA9IGxpbmUubGVuZ3RoID4gMCA/IGxpbmVbMF0gOiAnICcsXG4gICAgICAgICAgY29udGVudCA9IGxpbmUubGVuZ3RoID4gMCA/IGxpbmUuc3Vic3RyKDEpIDogbGluZSxcbiAgICAgICAgICBkZWxpbWl0ZXIgPSBfaHVuay5saW5lZGVsaW1pdGVyc1tqXTtcblxuICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gJyAnKSB7XG4gICAgICAgIF90b1BvcysrO1xuICAgICAgfSBlbHNlIGlmIChvcGVyYXRpb24gPT09ICctJykge1xuICAgICAgICBsaW5lcy5zcGxpY2UoX3RvUG9zLCAxKTtcbiAgICAgICAgZGVsaW1pdGVycy5zcGxpY2UoX3RvUG9zLCAxKTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIH0gZWxzZSBpZiAob3BlcmF0aW9uID09PSAnKycpIHtcbiAgICAgICAgbGluZXMuc3BsaWNlKF90b1BvcywgMCwgY29udGVudCk7XG4gICAgICAgIGRlbGltaXRlcnMuc3BsaWNlKF90b1BvcywgMCwgZGVsaW1pdGVyKTtcbiAgICAgICAgX3RvUG9zKys7XG4gICAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbiA9PT0gJ1xcXFwnKSB7XG4gICAgICAgIHZhciBwcmV2aW91c09wZXJhdGlvbiA9IF9odW5rLmxpbmVzW2ogLSAxXSA/IF9odW5rLmxpbmVzW2ogLSAxXVswXSA6IG51bGw7XG5cbiAgICAgICAgaWYgKHByZXZpb3VzT3BlcmF0aW9uID09PSAnKycpIHtcbiAgICAgICAgICByZW1vdmVFT0ZOTCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAocHJldmlvdXNPcGVyYXRpb24gPT09ICctJykge1xuICAgICAgICAgIGFkZEVPRk5MID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSAvLyBIYW5kbGUgRU9GTkwgaW5zZXJ0aW9uL3JlbW92YWxcblxuXG4gIGlmIChyZW1vdmVFT0ZOTCkge1xuICAgIHdoaWxlICghbGluZXNbbGluZXMubGVuZ3RoIC0gMV0pIHtcbiAgICAgIGxpbmVzLnBvcCgpO1xuICAgICAgZGVsaW1pdGVycy5wb3AoKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYWRkRU9GTkwpIHtcbiAgICBsaW5lcy5wdXNoKCcnKTtcbiAgICBkZWxpbWl0ZXJzLnB1c2goJ1xcbicpO1xuICB9XG5cbiAgZm9yICh2YXIgX2sgPSAwOyBfayA8IGxpbmVzLmxlbmd0aCAtIDE7IF9rKyspIHtcbiAgICBsaW5lc1tfa10gPSBsaW5lc1tfa10gKyBkZWxpbWl0ZXJzW19rXTtcbiAgfVxuXG4gIHJldHVybiBsaW5lcy5qb2luKCcnKTtcbn0gLy8gV3JhcHBlciB0aGF0IHN1cHBvcnRzIG11bHRpcGxlIGZpbGUgcGF0Y2hlcyB2aWEgY2FsbGJhY2tzLlxuXG5mdW5jdGlvbiBhcHBseVBhdGNoZXModW5pRGlmZiwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHVuaURpZmYgPT09ICdzdHJpbmcnKSB7XG4gICAgdW5pRGlmZiA9IHBhcnNlUGF0Y2godW5pRGlmZik7XG4gIH1cblxuICB2YXIgY3VycmVudEluZGV4ID0gMDtcblxuICBmdW5jdGlvbiBwcm9jZXNzSW5kZXgoKSB7XG4gICAgdmFyIGluZGV4ID0gdW5pRGlmZltjdXJyZW50SW5kZXgrK107XG5cbiAgICBpZiAoIWluZGV4KSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5jb21wbGV0ZSgpO1xuICAgIH1cblxuICAgIG9wdGlvbnMubG9hZEZpbGUoaW5kZXgsIGZ1bmN0aW9uIChlcnIsIGRhdGEpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuY29tcGxldGUoZXJyKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHVwZGF0ZWRDb250ZW50ID0gYXBwbHlQYXRjaChkYXRhLCBpbmRleCwgb3B0aW9ucyk7XG4gICAgICBvcHRpb25zLnBhdGNoZWQoaW5kZXgsIHVwZGF0ZWRDb250ZW50LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gb3B0aW9ucy5jb21wbGV0ZShlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvY2Vzc0luZGV4KCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHByb2Nlc3NJbmRleCgpO1xufVxuXG5mdW5jdGlvbiBzdHJ1Y3R1cmVkUGF0Y2gob2xkRmlsZU5hbWUsIG5ld0ZpbGVOYW1lLCBvbGRTdHIsIG5ld1N0ciwgb2xkSGVhZGVyLCBuZXdIZWFkZXIsIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zLmNvbnRleHQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgb3B0aW9ucy5jb250ZXh0ID0gNDtcbiAgfVxuXG4gIHZhciBkaWZmID0gZGlmZkxpbmVzKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKTtcblxuICBpZiAoIWRpZmYpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBkaWZmLnB1c2goe1xuICAgIHZhbHVlOiAnJyxcbiAgICBsaW5lczogW11cbiAgfSk7IC8vIEFwcGVuZCBhbiBlbXB0eSB2YWx1ZSB0byBtYWtlIGNsZWFudXAgZWFzaWVyXG5cbiAgZnVuY3Rpb24gY29udGV4dExpbmVzKGxpbmVzKSB7XG4gICAgcmV0dXJuIGxpbmVzLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgIHJldHVybiAnICcgKyBlbnRyeTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBodW5rcyA9IFtdO1xuICB2YXIgb2xkUmFuZ2VTdGFydCA9IDAsXG4gICAgICBuZXdSYW5nZVN0YXJ0ID0gMCxcbiAgICAgIGN1clJhbmdlID0gW10sXG4gICAgICBvbGRMaW5lID0gMSxcbiAgICAgIG5ld0xpbmUgPSAxO1xuXG4gIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKGkpIHtcbiAgICB2YXIgY3VycmVudCA9IGRpZmZbaV0sXG4gICAgICAgIGxpbmVzID0gY3VycmVudC5saW5lcyB8fCBjdXJyZW50LnZhbHVlLnJlcGxhY2UoL1xcbiQvLCAnJykuc3BsaXQoJ1xcbicpO1xuICAgIGN1cnJlbnQubGluZXMgPSBsaW5lcztcblxuICAgIGlmIChjdXJyZW50LmFkZGVkIHx8IGN1cnJlbnQucmVtb3ZlZCkge1xuICAgICAgdmFyIF9jdXJSYW5nZTtcblxuICAgICAgLy8gSWYgd2UgaGF2ZSBwcmV2aW91cyBjb250ZXh0LCBzdGFydCB3aXRoIHRoYXRcbiAgICAgIGlmICghb2xkUmFuZ2VTdGFydCkge1xuICAgICAgICB2YXIgcHJldiA9IGRpZmZbaSAtIDFdO1xuICAgICAgICBvbGRSYW5nZVN0YXJ0ID0gb2xkTGluZTtcbiAgICAgICAgbmV3UmFuZ2VTdGFydCA9IG5ld0xpbmU7XG5cbiAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICBjdXJSYW5nZSA9IG9wdGlvbnMuY29udGV4dCA+IDAgPyBjb250ZXh0TGluZXMocHJldi5saW5lcy5zbGljZSgtb3B0aW9ucy5jb250ZXh0KSkgOiBbXTtcbiAgICAgICAgICBvbGRSYW5nZVN0YXJ0IC09IGN1clJhbmdlLmxlbmd0aDtcbiAgICAgICAgICBuZXdSYW5nZVN0YXJ0IC09IGN1clJhbmdlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfSAvLyBPdXRwdXQgb3VyIGNoYW5nZXNcblxuXG4gICAgICAoX2N1clJhbmdlID0gY3VyUmFuZ2UpLnB1c2guYXBwbHkoX2N1clJhbmdlLCBfdG9Db25zdW1hYmxlQXJyYXkobGluZXMubWFwKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICByZXR1cm4gKGN1cnJlbnQuYWRkZWQgPyAnKycgOiAnLScpICsgZW50cnk7XG4gICAgICB9KSkpOyAvLyBUcmFjayB0aGUgdXBkYXRlZCBmaWxlIHBvc2l0aW9uXG5cblxuICAgICAgaWYgKGN1cnJlbnQuYWRkZWQpIHtcbiAgICAgICAgbmV3TGluZSArPSBsaW5lcy5sZW5ndGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvbGRMaW5lICs9IGxpbmVzLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWRlbnRpY2FsIGNvbnRleHQgbGluZXMuIFRyYWNrIGxpbmUgY2hhbmdlc1xuICAgICAgaWYgKG9sZFJhbmdlU3RhcnQpIHtcbiAgICAgICAgLy8gQ2xvc2Ugb3V0IGFueSBjaGFuZ2VzIHRoYXQgaGF2ZSBiZWVuIG91dHB1dCAob3Igam9pbiBvdmVybGFwcGluZylcbiAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA8PSBvcHRpb25zLmNvbnRleHQgKiAyICYmIGkgPCBkaWZmLmxlbmd0aCAtIDIpIHtcbiAgICAgICAgICB2YXIgX2N1clJhbmdlMjtcblxuICAgICAgICAgIC8vIE92ZXJsYXBwaW5nXG4gICAgICAgICAgKF9jdXJSYW5nZTIgPSBjdXJSYW5nZSkucHVzaC5hcHBseShfY3VyUmFuZ2UyLCBfdG9Db25zdW1hYmxlQXJyYXkoY29udGV4dExpbmVzKGxpbmVzKSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfY3VyUmFuZ2UzO1xuXG4gICAgICAgICAgLy8gZW5kIHRoZSByYW5nZSBhbmQgb3V0cHV0XG4gICAgICAgICAgdmFyIGNvbnRleHRTaXplID0gTWF0aC5taW4obGluZXMubGVuZ3RoLCBvcHRpb25zLmNvbnRleHQpO1xuXG4gICAgICAgICAgKF9jdXJSYW5nZTMgPSBjdXJSYW5nZSkucHVzaC5hcHBseShfY3VyUmFuZ2UzLCBfdG9Db25zdW1hYmxlQXJyYXkoY29udGV4dExpbmVzKGxpbmVzLnNsaWNlKDAsIGNvbnRleHRTaXplKSkpKTtcblxuICAgICAgICAgIHZhciBodW5rID0ge1xuICAgICAgICAgICAgb2xkU3RhcnQ6IG9sZFJhbmdlU3RhcnQsXG4gICAgICAgICAgICBvbGRMaW5lczogb2xkTGluZSAtIG9sZFJhbmdlU3RhcnQgKyBjb250ZXh0U2l6ZSxcbiAgICAgICAgICAgIG5ld1N0YXJ0OiBuZXdSYW5nZVN0YXJ0LFxuICAgICAgICAgICAgbmV3TGluZXM6IG5ld0xpbmUgLSBuZXdSYW5nZVN0YXJ0ICsgY29udGV4dFNpemUsXG4gICAgICAgICAgICBsaW5lczogY3VyUmFuZ2VcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKGkgPj0gZGlmZi5sZW5ndGggLSAyICYmIGxpbmVzLmxlbmd0aCA8PSBvcHRpb25zLmNvbnRleHQpIHtcbiAgICAgICAgICAgIC8vIEVPRiBpcyBpbnNpZGUgdGhpcyBodW5rXG4gICAgICAgICAgICB2YXIgb2xkRU9GTmV3bGluZSA9IC9cXG4kLy50ZXN0KG9sZFN0cik7XG4gICAgICAgICAgICB2YXIgbmV3RU9GTmV3bGluZSA9IC9cXG4kLy50ZXN0KG5ld1N0cik7XG4gICAgICAgICAgICB2YXIgbm9ObEJlZm9yZUFkZHMgPSBsaW5lcy5sZW5ndGggPT0gMCAmJiBjdXJSYW5nZS5sZW5ndGggPiBodW5rLm9sZExpbmVzO1xuXG4gICAgICAgICAgICBpZiAoIW9sZEVPRk5ld2xpbmUgJiYgbm9ObEJlZm9yZUFkZHMgJiYgb2xkU3RyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgLy8gc3BlY2lhbCBjYXNlOiBvbGQgaGFzIG5vIGVvbCBhbmQgbm8gdHJhaWxpbmcgY29udGV4dDsgbm8tbmwgY2FuIGVuZCB1cCBiZWZvcmUgYWRkc1xuICAgICAgICAgICAgICAvLyBob3dldmVyLCBpZiB0aGUgb2xkIGZpbGUgaXMgZW1wdHksIGRvIG5vdCBvdXRwdXQgdGhlIG5vLW5sIGxpbmVcbiAgICAgICAgICAgICAgY3VyUmFuZ2Uuc3BsaWNlKGh1bmsub2xkTGluZXMsIDAsICdcXFxcIE5vIG5ld2xpbmUgYXQgZW5kIG9mIGZpbGUnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFvbGRFT0ZOZXdsaW5lICYmICFub05sQmVmb3JlQWRkcyB8fCAhbmV3RU9GTmV3bGluZSkge1xuICAgICAgICAgICAgICBjdXJSYW5nZS5wdXNoKCdcXFxcIE5vIG5ld2xpbmUgYXQgZW5kIG9mIGZpbGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBodW5rcy5wdXNoKGh1bmspO1xuICAgICAgICAgIG9sZFJhbmdlU3RhcnQgPSAwO1xuICAgICAgICAgIG5ld1JhbmdlU3RhcnQgPSAwO1xuICAgICAgICAgIGN1clJhbmdlID0gW107XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgb2xkTGluZSArPSBsaW5lcy5sZW5ndGg7XG4gICAgICBuZXdMaW5lICs9IGxpbmVzLmxlbmd0aDtcbiAgICB9XG4gIH07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaWZmLmxlbmd0aDsgaSsrKSB7XG4gICAgX2xvb3AoaSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG9sZEZpbGVOYW1lOiBvbGRGaWxlTmFtZSxcbiAgICBuZXdGaWxlTmFtZTogbmV3RmlsZU5hbWUsXG4gICAgb2xkSGVhZGVyOiBvbGRIZWFkZXIsXG4gICAgbmV3SGVhZGVyOiBuZXdIZWFkZXIsXG4gICAgaHVua3M6IGh1bmtzXG4gIH07XG59XG5mdW5jdGlvbiBmb3JtYXRQYXRjaChkaWZmKSB7XG4gIHZhciByZXQgPSBbXTtcblxuICBpZiAoZGlmZi5vbGRGaWxlTmFtZSA9PSBkaWZmLm5ld0ZpbGVOYW1lKSB7XG4gICAgcmV0LnB1c2goJ0luZGV4OiAnICsgZGlmZi5vbGRGaWxlTmFtZSk7XG4gIH1cblxuICByZXQucHVzaCgnPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PScpO1xuICByZXQucHVzaCgnLS0tICcgKyBkaWZmLm9sZEZpbGVOYW1lICsgKHR5cGVvZiBkaWZmLm9sZEhlYWRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnJyA6ICdcXHQnICsgZGlmZi5vbGRIZWFkZXIpKTtcbiAgcmV0LnB1c2goJysrKyAnICsgZGlmZi5uZXdGaWxlTmFtZSArICh0eXBlb2YgZGlmZi5uZXdIZWFkZXIgPT09ICd1bmRlZmluZWQnID8gJycgOiAnXFx0JyArIGRpZmYubmV3SGVhZGVyKSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaWZmLmh1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGh1bmsgPSBkaWZmLmh1bmtzW2ldOyAvLyBVbmlmaWVkIERpZmYgRm9ybWF0IHF1aXJrOiBJZiB0aGUgY2h1bmsgc2l6ZSBpcyAwLFxuICAgIC8vIHRoZSBmaXJzdCBudW1iZXIgaXMgb25lIGxvd2VyIHRoYW4gb25lIHdvdWxkIGV4cGVjdC5cbiAgICAvLyBodHRwczovL3d3dy5hcnRpbWEuY29tL3dlYmxvZ3Mvdmlld3Bvc3QuanNwP3RocmVhZD0xNjQyOTNcblxuICAgIGlmIChodW5rLm9sZExpbmVzID09PSAwKSB7XG4gICAgICBodW5rLm9sZFN0YXJ0IC09IDE7XG4gICAgfVxuXG4gICAgaWYgKGh1bmsubmV3TGluZXMgPT09IDApIHtcbiAgICAgIGh1bmsubmV3U3RhcnQgLT0gMTtcbiAgICB9XG5cbiAgICByZXQucHVzaCgnQEAgLScgKyBodW5rLm9sZFN0YXJ0ICsgJywnICsgaHVuay5vbGRMaW5lcyArICcgKycgKyBodW5rLm5ld1N0YXJ0ICsgJywnICsgaHVuay5uZXdMaW5lcyArICcgQEAnKTtcbiAgICByZXQucHVzaC5hcHBseShyZXQsIGh1bmsubGluZXMpO1xuICB9XG5cbiAgcmV0dXJuIHJldC5qb2luKCdcXG4nKSArICdcXG4nO1xufVxuZnVuY3Rpb24gY3JlYXRlVHdvRmlsZXNQYXRjaChvbGRGaWxlTmFtZSwgbmV3RmlsZU5hbWUsIG9sZFN0ciwgbmV3U3RyLCBvbGRIZWFkZXIsIG5ld0hlYWRlciwgb3B0aW9ucykge1xuICByZXR1cm4gZm9ybWF0UGF0Y2goc3RydWN0dXJlZFBhdGNoKG9sZEZpbGVOYW1lLCBuZXdGaWxlTmFtZSwgb2xkU3RyLCBuZXdTdHIsIG9sZEhlYWRlciwgbmV3SGVhZGVyLCBvcHRpb25zKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVQYXRjaChmaWxlTmFtZSwgb2xkU3RyLCBuZXdTdHIsIG9sZEhlYWRlciwgbmV3SGVhZGVyLCBvcHRpb25zKSB7XG4gIHJldHVybiBjcmVhdGVUd29GaWxlc1BhdGNoKGZpbGVOYW1lLCBmaWxlTmFtZSwgb2xkU3RyLCBuZXdTdHIsIG9sZEhlYWRlciwgbmV3SGVhZGVyLCBvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gYXJyYXlFcXVhbChhLCBiKSB7XG4gIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gYXJyYXlTdGFydHNXaXRoKGEsIGIpO1xufVxuZnVuY3Rpb24gYXJyYXlTdGFydHNXaXRoKGFycmF5LCBzdGFydCkge1xuICBpZiAoc3RhcnQubGVuZ3RoID4gYXJyYXkubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFydC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzdGFydFtpXSAhPT0gYXJyYXlbaV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY2FsY0xpbmVDb3VudChodW5rKSB7XG4gIHZhciBfY2FsY09sZE5ld0xpbmVDb3VudCA9IGNhbGNPbGROZXdMaW5lQ291bnQoaHVuay5saW5lcyksXG4gICAgICBvbGRMaW5lcyA9IF9jYWxjT2xkTmV3TGluZUNvdW50Lm9sZExpbmVzLFxuICAgICAgbmV3TGluZXMgPSBfY2FsY09sZE5ld0xpbmVDb3VudC5uZXdMaW5lcztcblxuICBpZiAob2xkTGluZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIGh1bmsub2xkTGluZXMgPSBvbGRMaW5lcztcbiAgfSBlbHNlIHtcbiAgICBkZWxldGUgaHVuay5vbGRMaW5lcztcbiAgfVxuXG4gIGlmIChuZXdMaW5lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaHVuay5uZXdMaW5lcyA9IG5ld0xpbmVzO1xuICB9IGVsc2Uge1xuICAgIGRlbGV0ZSBodW5rLm5ld0xpbmVzO1xuICB9XG59XG5mdW5jdGlvbiBtZXJnZShtaW5lLCB0aGVpcnMsIGJhc2UpIHtcbiAgbWluZSA9IGxvYWRQYXRjaChtaW5lLCBiYXNlKTtcbiAgdGhlaXJzID0gbG9hZFBhdGNoKHRoZWlycywgYmFzZSk7XG4gIHZhciByZXQgPSB7fTsgLy8gRm9yIGluZGV4IHdlIGp1c3QgbGV0IGl0IHBhc3MgdGhyb3VnaCBhcyBpdCBkb2Vzbid0IGhhdmUgYW55IG5lY2Vzc2FyeSBtZWFuaW5nLlxuICAvLyBMZWF2aW5nIHNhbml0eSBjaGVja3Mgb24gdGhpcyB0byB0aGUgQVBJIGNvbnN1bWVyIHRoYXQgbWF5IGtub3cgbW9yZSBhYm91dCB0aGVcbiAgLy8gbWVhbmluZyBpbiB0aGVpciBvd24gY29udGV4dC5cblxuICBpZiAobWluZS5pbmRleCB8fCB0aGVpcnMuaW5kZXgpIHtcbiAgICByZXQuaW5kZXggPSBtaW5lLmluZGV4IHx8IHRoZWlycy5pbmRleDtcbiAgfVxuXG4gIGlmIChtaW5lLm5ld0ZpbGVOYW1lIHx8IHRoZWlycy5uZXdGaWxlTmFtZSkge1xuICAgIGlmICghZmlsZU5hbWVDaGFuZ2VkKG1pbmUpKSB7XG4gICAgICAvLyBObyBoZWFkZXIgb3Igbm8gY2hhbmdlIGluIG91cnMsIHVzZSB0aGVpcnMgKGFuZCBvdXJzIGlmIHRoZWlycyBkb2VzIG5vdCBleGlzdClcbiAgICAgIHJldC5vbGRGaWxlTmFtZSA9IHRoZWlycy5vbGRGaWxlTmFtZSB8fCBtaW5lLm9sZEZpbGVOYW1lO1xuICAgICAgcmV0Lm5ld0ZpbGVOYW1lID0gdGhlaXJzLm5ld0ZpbGVOYW1lIHx8IG1pbmUubmV3RmlsZU5hbWU7XG4gICAgICByZXQub2xkSGVhZGVyID0gdGhlaXJzLm9sZEhlYWRlciB8fCBtaW5lLm9sZEhlYWRlcjtcbiAgICAgIHJldC5uZXdIZWFkZXIgPSB0aGVpcnMubmV3SGVhZGVyIHx8IG1pbmUubmV3SGVhZGVyO1xuICAgIH0gZWxzZSBpZiAoIWZpbGVOYW1lQ2hhbmdlZCh0aGVpcnMpKSB7XG4gICAgICAvLyBObyBoZWFkZXIgb3Igbm8gY2hhbmdlIGluIHRoZWlycywgdXNlIG91cnNcbiAgICAgIHJldC5vbGRGaWxlTmFtZSA9IG1pbmUub2xkRmlsZU5hbWU7XG4gICAgICByZXQubmV3RmlsZU5hbWUgPSBtaW5lLm5ld0ZpbGVOYW1lO1xuICAgICAgcmV0Lm9sZEhlYWRlciA9IG1pbmUub2xkSGVhZGVyO1xuICAgICAgcmV0Lm5ld0hlYWRlciA9IG1pbmUubmV3SGVhZGVyO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBCb3RoIGNoYW5nZWQuLi4gZmlndXJlIGl0IG91dFxuICAgICAgcmV0Lm9sZEZpbGVOYW1lID0gc2VsZWN0RmllbGQocmV0LCBtaW5lLm9sZEZpbGVOYW1lLCB0aGVpcnMub2xkRmlsZU5hbWUpO1xuICAgICAgcmV0Lm5ld0ZpbGVOYW1lID0gc2VsZWN0RmllbGQocmV0LCBtaW5lLm5ld0ZpbGVOYW1lLCB0aGVpcnMubmV3RmlsZU5hbWUpO1xuICAgICAgcmV0Lm9sZEhlYWRlciA9IHNlbGVjdEZpZWxkKHJldCwgbWluZS5vbGRIZWFkZXIsIHRoZWlycy5vbGRIZWFkZXIpO1xuICAgICAgcmV0Lm5ld0hlYWRlciA9IHNlbGVjdEZpZWxkKHJldCwgbWluZS5uZXdIZWFkZXIsIHRoZWlycy5uZXdIZWFkZXIpO1xuICAgIH1cbiAgfVxuXG4gIHJldC5odW5rcyA9IFtdO1xuICB2YXIgbWluZUluZGV4ID0gMCxcbiAgICAgIHRoZWlyc0luZGV4ID0gMCxcbiAgICAgIG1pbmVPZmZzZXQgPSAwLFxuICAgICAgdGhlaXJzT2Zmc2V0ID0gMDtcblxuICB3aGlsZSAobWluZUluZGV4IDwgbWluZS5odW5rcy5sZW5ndGggfHwgdGhlaXJzSW5kZXggPCB0aGVpcnMuaHVua3MubGVuZ3RoKSB7XG4gICAgdmFyIG1pbmVDdXJyZW50ID0gbWluZS5odW5rc1ttaW5lSW5kZXhdIHx8IHtcbiAgICAgIG9sZFN0YXJ0OiBJbmZpbml0eVxuICAgIH0sXG4gICAgICAgIHRoZWlyc0N1cnJlbnQgPSB0aGVpcnMuaHVua3NbdGhlaXJzSW5kZXhdIHx8IHtcbiAgICAgIG9sZFN0YXJ0OiBJbmZpbml0eVxuICAgIH07XG5cbiAgICBpZiAoaHVua0JlZm9yZShtaW5lQ3VycmVudCwgdGhlaXJzQ3VycmVudCkpIHtcbiAgICAgIC8vIFRoaXMgcGF0Y2ggZG9lcyBub3Qgb3ZlcmxhcCB3aXRoIGFueSBvZiB0aGUgb3RoZXJzLCB5YXkuXG4gICAgICByZXQuaHVua3MucHVzaChjbG9uZUh1bmsobWluZUN1cnJlbnQsIG1pbmVPZmZzZXQpKTtcbiAgICAgIG1pbmVJbmRleCsrO1xuICAgICAgdGhlaXJzT2Zmc2V0ICs9IG1pbmVDdXJyZW50Lm5ld0xpbmVzIC0gbWluZUN1cnJlbnQub2xkTGluZXM7XG4gICAgfSBlbHNlIGlmIChodW5rQmVmb3JlKHRoZWlyc0N1cnJlbnQsIG1pbmVDdXJyZW50KSkge1xuICAgICAgLy8gVGhpcyBwYXRjaCBkb2VzIG5vdCBvdmVybGFwIHdpdGggYW55IG9mIHRoZSBvdGhlcnMsIHlheS5cbiAgICAgIHJldC5odW5rcy5wdXNoKGNsb25lSHVuayh0aGVpcnNDdXJyZW50LCB0aGVpcnNPZmZzZXQpKTtcbiAgICAgIHRoZWlyc0luZGV4Kys7XG4gICAgICBtaW5lT2Zmc2V0ICs9IHRoZWlyc0N1cnJlbnQubmV3TGluZXMgLSB0aGVpcnNDdXJyZW50Lm9sZExpbmVzO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPdmVybGFwLCBtZXJnZSBhcyBiZXN0IHdlIGNhblxuICAgICAgdmFyIG1lcmdlZEh1bmsgPSB7XG4gICAgICAgIG9sZFN0YXJ0OiBNYXRoLm1pbihtaW5lQ3VycmVudC5vbGRTdGFydCwgdGhlaXJzQ3VycmVudC5vbGRTdGFydCksXG4gICAgICAgIG9sZExpbmVzOiAwLFxuICAgICAgICBuZXdTdGFydDogTWF0aC5taW4obWluZUN1cnJlbnQubmV3U3RhcnQgKyBtaW5lT2Zmc2V0LCB0aGVpcnNDdXJyZW50Lm9sZFN0YXJ0ICsgdGhlaXJzT2Zmc2V0KSxcbiAgICAgICAgbmV3TGluZXM6IDAsXG4gICAgICAgIGxpbmVzOiBbXVxuICAgICAgfTtcbiAgICAgIG1lcmdlTGluZXMobWVyZ2VkSHVuaywgbWluZUN1cnJlbnQub2xkU3RhcnQsIG1pbmVDdXJyZW50LmxpbmVzLCB0aGVpcnNDdXJyZW50Lm9sZFN0YXJ0LCB0aGVpcnNDdXJyZW50LmxpbmVzKTtcbiAgICAgIHRoZWlyc0luZGV4Kys7XG4gICAgICBtaW5lSW5kZXgrKztcbiAgICAgIHJldC5odW5rcy5wdXNoKG1lcmdlZEh1bmspO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGxvYWRQYXRjaChwYXJhbSwgYmFzZSkge1xuICBpZiAodHlwZW9mIHBhcmFtID09PSAnc3RyaW5nJykge1xuICAgIGlmICgvXkBAL20udGVzdChwYXJhbSkgfHwgL15JbmRleDovbS50ZXN0KHBhcmFtKSkge1xuICAgICAgcmV0dXJuIHBhcnNlUGF0Y2gocGFyYW0pWzBdO1xuICAgIH1cblxuICAgIGlmICghYmFzZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHByb3ZpZGUgYSBiYXNlIHJlZmVyZW5jZSBvciBwYXNzIGluIGEgcGF0Y2gnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RydWN0dXJlZFBhdGNoKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBiYXNlLCBwYXJhbSk7XG4gIH1cblxuICByZXR1cm4gcGFyYW07XG59XG5cbmZ1bmN0aW9uIGZpbGVOYW1lQ2hhbmdlZChwYXRjaCkge1xuICByZXR1cm4gcGF0Y2gubmV3RmlsZU5hbWUgJiYgcGF0Y2gubmV3RmlsZU5hbWUgIT09IHBhdGNoLm9sZEZpbGVOYW1lO1xufVxuXG5mdW5jdGlvbiBzZWxlY3RGaWVsZChpbmRleCwgbWluZSwgdGhlaXJzKSB7XG4gIGlmIChtaW5lID09PSB0aGVpcnMpIHtcbiAgICByZXR1cm4gbWluZTtcbiAgfSBlbHNlIHtcbiAgICBpbmRleC5jb25mbGljdCA9IHRydWU7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbmU6IG1pbmUsXG4gICAgICB0aGVpcnM6IHRoZWlyc1xuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gaHVua0JlZm9yZSh0ZXN0LCBjaGVjaykge1xuICByZXR1cm4gdGVzdC5vbGRTdGFydCA8IGNoZWNrLm9sZFN0YXJ0ICYmIHRlc3Qub2xkU3RhcnQgKyB0ZXN0Lm9sZExpbmVzIDwgY2hlY2sub2xkU3RhcnQ7XG59XG5cbmZ1bmN0aW9uIGNsb25lSHVuayhodW5rLCBvZmZzZXQpIHtcbiAgcmV0dXJuIHtcbiAgICBvbGRTdGFydDogaHVuay5vbGRTdGFydCxcbiAgICBvbGRMaW5lczogaHVuay5vbGRMaW5lcyxcbiAgICBuZXdTdGFydDogaHVuay5uZXdTdGFydCArIG9mZnNldCxcbiAgICBuZXdMaW5lczogaHVuay5uZXdMaW5lcyxcbiAgICBsaW5lczogaHVuay5saW5lc1xuICB9O1xufVxuXG5mdW5jdGlvbiBtZXJnZUxpbmVzKGh1bmssIG1pbmVPZmZzZXQsIG1pbmVMaW5lcywgdGhlaXJPZmZzZXQsIHRoZWlyTGluZXMpIHtcbiAgLy8gVGhpcyB3aWxsIGdlbmVyYWxseSByZXN1bHQgaW4gYSBjb25mbGljdGVkIGh1bmssIGJ1dCB0aGVyZSBhcmUgY2FzZXMgd2hlcmUgdGhlIGNvbnRleHRcbiAgLy8gaXMgdGhlIG9ubHkgb3ZlcmxhcCB3aGVyZSB3ZSBjYW4gc3VjY2Vzc2Z1bGx5IG1lcmdlIHRoZSBjb250ZW50IGhlcmUuXG4gIHZhciBtaW5lID0ge1xuICAgIG9mZnNldDogbWluZU9mZnNldCxcbiAgICBsaW5lczogbWluZUxpbmVzLFxuICAgIGluZGV4OiAwXG4gIH0sXG4gICAgICB0aGVpciA9IHtcbiAgICBvZmZzZXQ6IHRoZWlyT2Zmc2V0LFxuICAgIGxpbmVzOiB0aGVpckxpbmVzLFxuICAgIGluZGV4OiAwXG4gIH07IC8vIEhhbmRsZSBhbnkgbGVhZGluZyBjb250ZW50XG5cbiAgaW5zZXJ0TGVhZGluZyhodW5rLCBtaW5lLCB0aGVpcik7XG4gIGluc2VydExlYWRpbmcoaHVuaywgdGhlaXIsIG1pbmUpOyAvLyBOb3cgaW4gdGhlIG92ZXJsYXAgY29udGVudC4gU2NhbiB0aHJvdWdoIGFuZCBzZWxlY3QgdGhlIGJlc3QgY2hhbmdlcyBmcm9tIGVhY2guXG5cbiAgd2hpbGUgKG1pbmUuaW5kZXggPCBtaW5lLmxpbmVzLmxlbmd0aCAmJiB0aGVpci5pbmRleCA8IHRoZWlyLmxpbmVzLmxlbmd0aCkge1xuICAgIHZhciBtaW5lQ3VycmVudCA9IG1pbmUubGluZXNbbWluZS5pbmRleF0sXG4gICAgICAgIHRoZWlyQ3VycmVudCA9IHRoZWlyLmxpbmVzW3RoZWlyLmluZGV4XTtcblxuICAgIGlmICgobWluZUN1cnJlbnRbMF0gPT09ICctJyB8fCBtaW5lQ3VycmVudFswXSA9PT0gJysnKSAmJiAodGhlaXJDdXJyZW50WzBdID09PSAnLScgfHwgdGhlaXJDdXJyZW50WzBdID09PSAnKycpKSB7XG4gICAgICAvLyBCb3RoIG1vZGlmaWVkIC4uLlxuICAgICAgbXV0dWFsQ2hhbmdlKGh1bmssIG1pbmUsIHRoZWlyKTtcbiAgICB9IGVsc2UgaWYgKG1pbmVDdXJyZW50WzBdID09PSAnKycgJiYgdGhlaXJDdXJyZW50WzBdID09PSAnICcpIHtcbiAgICAgIHZhciBfaHVuayRsaW5lcztcblxuICAgICAgLy8gTWluZSBpbnNlcnRlZFxuICAgICAgKF9odW5rJGxpbmVzID0gaHVuay5saW5lcykucHVzaC5hcHBseShfaHVuayRsaW5lcywgX3RvQ29uc3VtYWJsZUFycmF5KGNvbGxlY3RDaGFuZ2UobWluZSkpKTtcbiAgICB9IGVsc2UgaWYgKHRoZWlyQ3VycmVudFswXSA9PT0gJysnICYmIG1pbmVDdXJyZW50WzBdID09PSAnICcpIHtcbiAgICAgIHZhciBfaHVuayRsaW5lczI7XG5cbiAgICAgIC8vIFRoZWlycyBpbnNlcnRlZFxuICAgICAgKF9odW5rJGxpbmVzMiA9IGh1bmsubGluZXMpLnB1c2guYXBwbHkoX2h1bmskbGluZXMyLCBfdG9Db25zdW1hYmxlQXJyYXkoY29sbGVjdENoYW5nZSh0aGVpcikpKTtcbiAgICB9IGVsc2UgaWYgKG1pbmVDdXJyZW50WzBdID09PSAnLScgJiYgdGhlaXJDdXJyZW50WzBdID09PSAnICcpIHtcbiAgICAgIC8vIE1pbmUgcmVtb3ZlZCBvciBlZGl0ZWRcbiAgICAgIHJlbW92YWwoaHVuaywgbWluZSwgdGhlaXIpO1xuICAgIH0gZWxzZSBpZiAodGhlaXJDdXJyZW50WzBdID09PSAnLScgJiYgbWluZUN1cnJlbnRbMF0gPT09ICcgJykge1xuICAgICAgLy8gVGhlaXIgcmVtb3ZlZCBvciBlZGl0ZWRcbiAgICAgIHJlbW92YWwoaHVuaywgdGhlaXIsIG1pbmUsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAobWluZUN1cnJlbnQgPT09IHRoZWlyQ3VycmVudCkge1xuICAgICAgLy8gQ29udGV4dCBpZGVudGl0eVxuICAgICAgaHVuay5saW5lcy5wdXNoKG1pbmVDdXJyZW50KTtcbiAgICAgIG1pbmUuaW5kZXgrKztcbiAgICAgIHRoZWlyLmluZGV4Kys7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENvbnRleHQgbWlzbWF0Y2hcbiAgICAgIGNvbmZsaWN0KGh1bmssIGNvbGxlY3RDaGFuZ2UobWluZSksIGNvbGxlY3RDaGFuZ2UodGhlaXIpKTtcbiAgICB9XG4gIH0gLy8gTm93IHB1c2ggYW55dGhpbmcgdGhhdCBtYXkgYmUgcmVtYWluaW5nXG5cblxuICBpbnNlcnRUcmFpbGluZyhodW5rLCBtaW5lKTtcbiAgaW5zZXJ0VHJhaWxpbmcoaHVuaywgdGhlaXIpO1xuICBjYWxjTGluZUNvdW50KGh1bmspO1xufVxuXG5mdW5jdGlvbiBtdXR1YWxDaGFuZ2UoaHVuaywgbWluZSwgdGhlaXIpIHtcbiAgdmFyIG15Q2hhbmdlcyA9IGNvbGxlY3RDaGFuZ2UobWluZSksXG4gICAgICB0aGVpckNoYW5nZXMgPSBjb2xsZWN0Q2hhbmdlKHRoZWlyKTtcblxuICBpZiAoYWxsUmVtb3ZlcyhteUNoYW5nZXMpICYmIGFsbFJlbW92ZXModGhlaXJDaGFuZ2VzKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgcmVtb3ZlIGNoYW5nZXMgdGhhdCBhcmUgc3VwZXJzZXRzIG9mIG9uZSBhbm90aGVyXG4gICAgaWYgKGFycmF5U3RhcnRzV2l0aChteUNoYW5nZXMsIHRoZWlyQ2hhbmdlcykgJiYgc2tpcFJlbW92ZVN1cGVyc2V0KHRoZWlyLCBteUNoYW5nZXMsIG15Q2hhbmdlcy5sZW5ndGggLSB0aGVpckNoYW5nZXMubGVuZ3RoKSkge1xuICAgICAgdmFyIF9odW5rJGxpbmVzMztcblxuICAgICAgKF9odW5rJGxpbmVzMyA9IGh1bmsubGluZXMpLnB1c2guYXBwbHkoX2h1bmskbGluZXMzLCBfdG9Db25zdW1hYmxlQXJyYXkobXlDaGFuZ2VzKSk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKGFycmF5U3RhcnRzV2l0aCh0aGVpckNoYW5nZXMsIG15Q2hhbmdlcykgJiYgc2tpcFJlbW92ZVN1cGVyc2V0KG1pbmUsIHRoZWlyQ2hhbmdlcywgdGhlaXJDaGFuZ2VzLmxlbmd0aCAtIG15Q2hhbmdlcy5sZW5ndGgpKSB7XG4gICAgICB2YXIgX2h1bmskbGluZXM0O1xuXG4gICAgICAoX2h1bmskbGluZXM0ID0gaHVuay5saW5lcykucHVzaC5hcHBseShfaHVuayRsaW5lczQsIF90b0NvbnN1bWFibGVBcnJheSh0aGVpckNoYW5nZXMpKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhcnJheUVxdWFsKG15Q2hhbmdlcywgdGhlaXJDaGFuZ2VzKSkge1xuICAgIHZhciBfaHVuayRsaW5lczU7XG5cbiAgICAoX2h1bmskbGluZXM1ID0gaHVuay5saW5lcykucHVzaC5hcHBseShfaHVuayRsaW5lczUsIF90b0NvbnN1bWFibGVBcnJheShteUNoYW5nZXMpKTtcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbmZsaWN0KGh1bmssIG15Q2hhbmdlcywgdGhlaXJDaGFuZ2VzKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZhbChodW5rLCBtaW5lLCB0aGVpciwgc3dhcCkge1xuICB2YXIgbXlDaGFuZ2VzID0gY29sbGVjdENoYW5nZShtaW5lKSxcbiAgICAgIHRoZWlyQ2hhbmdlcyA9IGNvbGxlY3RDb250ZXh0KHRoZWlyLCBteUNoYW5nZXMpO1xuXG4gIGlmICh0aGVpckNoYW5nZXMubWVyZ2VkKSB7XG4gICAgdmFyIF9odW5rJGxpbmVzNjtcblxuICAgIChfaHVuayRsaW5lczYgPSBodW5rLmxpbmVzKS5wdXNoLmFwcGx5KF9odW5rJGxpbmVzNiwgX3RvQ29uc3VtYWJsZUFycmF5KHRoZWlyQ2hhbmdlcy5tZXJnZWQpKTtcbiAgfSBlbHNlIHtcbiAgICBjb25mbGljdChodW5rLCBzd2FwID8gdGhlaXJDaGFuZ2VzIDogbXlDaGFuZ2VzLCBzd2FwID8gbXlDaGFuZ2VzIDogdGhlaXJDaGFuZ2VzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb25mbGljdChodW5rLCBtaW5lLCB0aGVpcikge1xuICBodW5rLmNvbmZsaWN0ID0gdHJ1ZTtcbiAgaHVuay5saW5lcy5wdXNoKHtcbiAgICBjb25mbGljdDogdHJ1ZSxcbiAgICBtaW5lOiBtaW5lLFxuICAgIHRoZWlyczogdGhlaXJcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGluc2VydExlYWRpbmcoaHVuaywgaW5zZXJ0LCB0aGVpcikge1xuICB3aGlsZSAoaW5zZXJ0Lm9mZnNldCA8IHRoZWlyLm9mZnNldCAmJiBpbnNlcnQuaW5kZXggPCBpbnNlcnQubGluZXMubGVuZ3RoKSB7XG4gICAgdmFyIGxpbmUgPSBpbnNlcnQubGluZXNbaW5zZXJ0LmluZGV4KytdO1xuICAgIGh1bmsubGluZXMucHVzaChsaW5lKTtcbiAgICBpbnNlcnQub2Zmc2V0Kys7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5zZXJ0VHJhaWxpbmcoaHVuaywgaW5zZXJ0KSB7XG4gIHdoaWxlIChpbnNlcnQuaW5kZXggPCBpbnNlcnQubGluZXMubGVuZ3RoKSB7XG4gICAgdmFyIGxpbmUgPSBpbnNlcnQubGluZXNbaW5zZXJ0LmluZGV4KytdO1xuICAgIGh1bmsubGluZXMucHVzaChsaW5lKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb2xsZWN0Q2hhbmdlKHN0YXRlKSB7XG4gIHZhciByZXQgPSBbXSxcbiAgICAgIG9wZXJhdGlvbiA9IHN0YXRlLmxpbmVzW3N0YXRlLmluZGV4XVswXTtcblxuICB3aGlsZSAoc3RhdGUuaW5kZXggPCBzdGF0ZS5saW5lcy5sZW5ndGgpIHtcbiAgICB2YXIgbGluZSA9IHN0YXRlLmxpbmVzW3N0YXRlLmluZGV4XTsgLy8gR3JvdXAgYWRkaXRpb25zIHRoYXQgYXJlIGltbWVkaWF0ZWx5IGFmdGVyIHN1YnRyYWN0aW9ucyBhbmQgdHJlYXQgdGhlbSBhcyBvbmUgXCJhdG9taWNcIiBtb2RpZnkgY2hhbmdlLlxuXG4gICAgaWYgKG9wZXJhdGlvbiA9PT0gJy0nICYmIGxpbmVbMF0gPT09ICcrJykge1xuICAgICAgb3BlcmF0aW9uID0gJysnO1xuICAgIH1cblxuICAgIGlmIChvcGVyYXRpb24gPT09IGxpbmVbMF0pIHtcbiAgICAgIHJldC5wdXNoKGxpbmUpO1xuICAgICAgc3RhdGUuaW5kZXgrKztcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gY29sbGVjdENvbnRleHQoc3RhdGUsIG1hdGNoQ2hhbmdlcykge1xuICB2YXIgY2hhbmdlcyA9IFtdLFxuICAgICAgbWVyZ2VkID0gW10sXG4gICAgICBtYXRjaEluZGV4ID0gMCxcbiAgICAgIGNvbnRleHRDaGFuZ2VzID0gZmFsc2UsXG4gICAgICBjb25mbGljdGVkID0gZmFsc2U7XG5cbiAgd2hpbGUgKG1hdGNoSW5kZXggPCBtYXRjaENoYW5nZXMubGVuZ3RoICYmIHN0YXRlLmluZGV4IDwgc3RhdGUubGluZXMubGVuZ3RoKSB7XG4gICAgdmFyIGNoYW5nZSA9IHN0YXRlLmxpbmVzW3N0YXRlLmluZGV4XSxcbiAgICAgICAgbWF0Y2ggPSBtYXRjaENoYW5nZXNbbWF0Y2hJbmRleF07IC8vIE9uY2Ugd2UndmUgaGl0IG91ciBhZGQsIHRoZW4gd2UgYXJlIGRvbmVcblxuICAgIGlmIChtYXRjaFswXSA9PT0gJysnKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjb250ZXh0Q2hhbmdlcyA9IGNvbnRleHRDaGFuZ2VzIHx8IGNoYW5nZVswXSAhPT0gJyAnO1xuICAgIG1lcmdlZC5wdXNoKG1hdGNoKTtcbiAgICBtYXRjaEluZGV4Kys7IC8vIENvbnN1bWUgYW55IGFkZGl0aW9ucyBpbiB0aGUgb3RoZXIgYmxvY2sgYXMgYSBjb25mbGljdCB0byBhdHRlbXB0XG4gICAgLy8gdG8gcHVsbCBpbiB0aGUgcmVtYWluaW5nIGNvbnRleHQgYWZ0ZXIgdGhpc1xuXG4gICAgaWYgKGNoYW5nZVswXSA9PT0gJysnKSB7XG4gICAgICBjb25mbGljdGVkID0gdHJ1ZTtcblxuICAgICAgd2hpbGUgKGNoYW5nZVswXSA9PT0gJysnKSB7XG4gICAgICAgIGNoYW5nZXMucHVzaChjaGFuZ2UpO1xuICAgICAgICBjaGFuZ2UgPSBzdGF0ZS5saW5lc1srK3N0YXRlLmluZGV4XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobWF0Y2guc3Vic3RyKDEpID09PSBjaGFuZ2Uuc3Vic3RyKDEpKSB7XG4gICAgICBjaGFuZ2VzLnB1c2goY2hhbmdlKTtcbiAgICAgIHN0YXRlLmluZGV4Kys7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbmZsaWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICgobWF0Y2hDaGFuZ2VzW21hdGNoSW5kZXhdIHx8ICcnKVswXSA9PT0gJysnICYmIGNvbnRleHRDaGFuZ2VzKSB7XG4gICAgY29uZmxpY3RlZCA9IHRydWU7XG4gIH1cblxuICBpZiAoY29uZmxpY3RlZCkge1xuICAgIHJldHVybiBjaGFuZ2VzO1xuICB9XG5cbiAgd2hpbGUgKG1hdGNoSW5kZXggPCBtYXRjaENoYW5nZXMubGVuZ3RoKSB7XG4gICAgbWVyZ2VkLnB1c2gobWF0Y2hDaGFuZ2VzW21hdGNoSW5kZXgrK10pO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtZXJnZWQ6IG1lcmdlZCxcbiAgICBjaGFuZ2VzOiBjaGFuZ2VzXG4gIH07XG59XG5cbmZ1bmN0aW9uIGFsbFJlbW92ZXMoY2hhbmdlcykge1xuICByZXR1cm4gY2hhbmdlcy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGNoYW5nZSkge1xuICAgIHJldHVybiBwcmV2ICYmIGNoYW5nZVswXSA9PT0gJy0nO1xuICB9LCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gc2tpcFJlbW92ZVN1cGVyc2V0KHN0YXRlLCByZW1vdmVDaGFuZ2VzLCBkZWx0YSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRlbHRhOyBpKyspIHtcbiAgICB2YXIgY2hhbmdlQ29udGVudCA9IHJlbW92ZUNoYW5nZXNbcmVtb3ZlQ2hhbmdlcy5sZW5ndGggLSBkZWx0YSArIGldLnN1YnN0cigxKTtcblxuICAgIGlmIChzdGF0ZS5saW5lc1tzdGF0ZS5pbmRleCArIGldICE9PSAnICcgKyBjaGFuZ2VDb250ZW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgc3RhdGUuaW5kZXggKz0gZGVsdGE7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjYWxjT2xkTmV3TGluZUNvdW50KGxpbmVzKSB7XG4gIHZhciBvbGRMaW5lcyA9IDA7XG4gIHZhciBuZXdMaW5lcyA9IDA7XG4gIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICBpZiAodHlwZW9mIGxpbmUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgbXlDb3VudCA9IGNhbGNPbGROZXdMaW5lQ291bnQobGluZS5taW5lKTtcbiAgICAgIHZhciB0aGVpckNvdW50ID0gY2FsY09sZE5ld0xpbmVDb3VudChsaW5lLnRoZWlycyk7XG5cbiAgICAgIGlmIChvbGRMaW5lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChteUNvdW50Lm9sZExpbmVzID09PSB0aGVpckNvdW50Lm9sZExpbmVzKSB7XG4gICAgICAgICAgb2xkTGluZXMgKz0gbXlDb3VudC5vbGRMaW5lcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvbGRMaW5lcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobmV3TGluZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAobXlDb3VudC5uZXdMaW5lcyA9PT0gdGhlaXJDb3VudC5uZXdMaW5lcykge1xuICAgICAgICAgIG5ld0xpbmVzICs9IG15Q291bnQubmV3TGluZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3TGluZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG5ld0xpbmVzICE9PSB1bmRlZmluZWQgJiYgKGxpbmVbMF0gPT09ICcrJyB8fCBsaW5lWzBdID09PSAnICcpKSB7XG4gICAgICAgIG5ld0xpbmVzKys7XG4gICAgICB9XG5cbiAgICAgIGlmIChvbGRMaW5lcyAhPT0gdW5kZWZpbmVkICYmIChsaW5lWzBdID09PSAnLScgfHwgbGluZVswXSA9PT0gJyAnKSkge1xuICAgICAgICBvbGRMaW5lcysrO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7XG4gICAgb2xkTGluZXM6IG9sZExpbmVzLFxuICAgIG5ld0xpbmVzOiBuZXdMaW5lc1xuICB9O1xufVxuXG4vLyBTZWU6IGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9nb29nbGUtZGlmZi1tYXRjaC1wYXRjaC93aWtpL0FQSVxuZnVuY3Rpb24gY29udmVydENoYW5nZXNUb0RNUChjaGFuZ2VzKSB7XG4gIHZhciByZXQgPSBbXSxcbiAgICAgIGNoYW5nZSxcbiAgICAgIG9wZXJhdGlvbjtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjaGFuZ2UgPSBjaGFuZ2VzW2ldO1xuXG4gICAgaWYgKGNoYW5nZS5hZGRlZCkge1xuICAgICAgb3BlcmF0aW9uID0gMTtcbiAgICB9IGVsc2UgaWYgKGNoYW5nZS5yZW1vdmVkKSB7XG4gICAgICBvcGVyYXRpb24gPSAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3BlcmF0aW9uID0gMDtcbiAgICB9XG5cbiAgICByZXQucHVzaChbb3BlcmF0aW9uLCBjaGFuZ2UudmFsdWVdKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRDaGFuZ2VzVG9YTUwoY2hhbmdlcykge1xuICB2YXIgcmV0ID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNoYW5nZSA9IGNoYW5nZXNbaV07XG5cbiAgICBpZiAoY2hhbmdlLmFkZGVkKSB7XG4gICAgICByZXQucHVzaCgnPGlucz4nKTtcbiAgICB9IGVsc2UgaWYgKGNoYW5nZS5yZW1vdmVkKSB7XG4gICAgICByZXQucHVzaCgnPGRlbD4nKTtcbiAgICB9XG5cbiAgICByZXQucHVzaChlc2NhcGVIVE1MKGNoYW5nZS52YWx1ZSkpO1xuXG4gICAgaWYgKGNoYW5nZS5hZGRlZCkge1xuICAgICAgcmV0LnB1c2goJzwvaW5zPicpO1xuICAgIH0gZWxzZSBpZiAoY2hhbmdlLnJlbW92ZWQpIHtcbiAgICAgIHJldC5wdXNoKCc8L2RlbD4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0LmpvaW4oJycpO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVIVE1MKHMpIHtcbiAgdmFyIG4gPSBzO1xuICBuID0gbi5yZXBsYWNlKC8mL2csICcmYW1wOycpO1xuICBuID0gbi5yZXBsYWNlKC88L2csICcmbHQ7Jyk7XG4gIG4gPSBuLnJlcGxhY2UoLz4vZywgJyZndDsnKTtcbiAgbiA9IG4ucmVwbGFjZSgvXCIvZywgJyZxdW90OycpO1xuICByZXR1cm4gbjtcbn1cblxuZXhwb3J0IHsgRGlmZiwgYXBwbHlQYXRjaCwgYXBwbHlQYXRjaGVzLCBjYW5vbmljYWxpemUsIGNvbnZlcnRDaGFuZ2VzVG9ETVAsIGNvbnZlcnRDaGFuZ2VzVG9YTUwsIGNyZWF0ZVBhdGNoLCBjcmVhdGVUd29GaWxlc1BhdGNoLCBkaWZmQXJyYXlzLCBkaWZmQ2hhcnMsIGRpZmZDc3MsIGRpZmZKc29uLCBkaWZmTGluZXMsIGRpZmZTZW50ZW5jZXMsIGRpZmZUcmltbWVkTGluZXMsIGRpZmZXb3JkcywgZGlmZldvcmRzV2l0aFNwYWNlLCBtZXJnZSwgcGFyc2VQYXRjaCwgc3RydWN0dXJlZFBhdGNoIH07XG4iXSwibmFtZXMiOlsiRGlmZiIsInByb3RvdHlwZSIsImRpZmYiLCJvbGRTdHJpbmciLCJuZXdTdHJpbmciLCJvcHRpb25zIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwiY2FsbGJhY2siLCJzZWxmIiwiZG9uZSIsInZhbHVlIiwic2V0VGltZW91dCIsImNhc3RJbnB1dCIsInJlbW92ZUVtcHR5IiwidG9rZW5pemUiLCJuZXdMZW4iLCJvbGRMZW4iLCJlZGl0TGVuZ3RoIiwibWF4RWRpdExlbmd0aCIsIk1hdGgiLCJtaW4iLCJiZXN0UGF0aCIsIm5ld1BvcyIsImNvbXBvbmVudHMiLCJvbGRQb3MiLCJleHRyYWN0Q29tbW9uIiwiam9pbiIsImNvdW50IiwiZXhlY0VkaXRMZW5ndGgiLCJkaWFnb25hbFBhdGgiLCJiYXNlUGF0aCIsImFkZFBhdGgiLCJyZW1vdmVQYXRoIiwiX29sZFBvcyIsImNhbkFkZCIsImNhblJlbW92ZSIsImNsb25lUGF0aCIsInB1c2hDb21wb25lbnQiLCJidWlsZFZhbHVlcyIsInVzZUxvbmdlc3RUb2tlbiIsImV4ZWMiLCJyZXQiLCJhZGRlZCIsInJlbW92ZWQiLCJsYXN0IiwicHVzaCIsImNvbW1vbkNvdW50IiwiZXF1YWxzIiwibGVmdCIsInJpZ2h0IiwiY29tcGFyYXRvciIsImlnbm9yZUNhc2UiLCJ0b0xvd2VyQ2FzZSIsImFycmF5IiwiaSIsInNwbGl0IiwiY2hhcnMiLCJjb21wb25lbnRQb3MiLCJjb21wb25lbnRMZW4iLCJjb21wb25lbnQiLCJzbGljZSIsIm1hcCIsIm9sZFZhbHVlIiwidG1wIiwibGFzdENvbXBvbmVudCIsInBvcCIsInBhdGgiLCJjaGFyYWN0ZXJEaWZmIiwiZGlmZkNoYXJzIiwib2xkU3RyIiwibmV3U3RyIiwiZ2VuZXJhdGVPcHRpb25zIiwiZGVmYXVsdHMiLCJuYW1lIiwiaGFzT3duUHJvcGVydHkiLCJleHRlbmRlZFdvcmRDaGFycyIsInJlV2hpdGVzcGFjZSIsIndvcmREaWZmIiwiaWdub3JlV2hpdGVzcGFjZSIsInRlc3QiLCJ0b2tlbnMiLCJzcGxpY2UiLCJkaWZmV29yZHMiLCJkaWZmV29yZHNXaXRoU3BhY2UiLCJsaW5lRGlmZiIsInJldExpbmVzIiwibGluZXNBbmROZXdsaW5lcyIsImxpbmUiLCJuZXdsaW5lSXNUb2tlbiIsInRyaW0iLCJkaWZmTGluZXMiLCJkaWZmVHJpbW1lZExpbmVzIiwic2VudGVuY2VEaWZmIiwiZGlmZlNlbnRlbmNlcyIsImNzc0RpZmYiLCJkaWZmQ3NzIiwiX3R5cGVvZiIsIm9iaiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJhcnIiLCJfYXJyYXlXaXRob3V0SG9sZXMiLCJfaXRlcmFibGVUb0FycmF5IiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwiX25vbkl0ZXJhYmxlU3ByZWFkIiwiQXJyYXkiLCJpc0FycmF5IiwiX2FycmF5TGlrZVRvQXJyYXkiLCJpdGVyIiwiT2JqZWN0IiwiZnJvbSIsIm8iLCJtaW5MZW4iLCJuIiwidG9TdHJpbmciLCJjYWxsIiwibGVuIiwiYXJyMiIsIlR5cGVFcnJvciIsIm9iamVjdFByb3RvdHlwZVRvU3RyaW5nIiwianNvbkRpZmYiLCJfdGhpcyRvcHRpb25zIiwidW5kZWZpbmVkUmVwbGFjZW1lbnQiLCJfdGhpcyRvcHRpb25zJHN0cmluZ2kiLCJzdHJpbmdpZnlSZXBsYWNlciIsImsiLCJ2IiwiSlNPTiIsInN0cmluZ2lmeSIsImNhbm9uaWNhbGl6ZSIsInJlcGxhY2UiLCJkaWZmSnNvbiIsIm9sZE9iaiIsIm5ld09iaiIsInN0YWNrIiwicmVwbGFjZW1lbnRTdGFjayIsInJlcGxhY2VyIiwia2V5IiwiY2Fub25pY2FsaXplZE9iaiIsInRvSlNPTiIsInNvcnRlZEtleXMiLCJfa2V5Iiwic29ydCIsImFycmF5RGlmZiIsImRpZmZBcnJheXMiLCJvbGRBcnIiLCJuZXdBcnIiLCJwYXJzZVBhdGNoIiwidW5pRGlmZiIsImRpZmZzdHIiLCJkZWxpbWl0ZXJzIiwibWF0Y2giLCJsaXN0IiwicGFyc2VJbmRleCIsImluZGV4IiwiaGVhZGVyIiwicGFyc2VGaWxlSGVhZGVyIiwiaHVua3MiLCJfbGluZSIsInBhcnNlSHVuayIsInN0cmljdCIsIkVycm9yIiwiZmlsZUhlYWRlciIsImtleVByZWZpeCIsImRhdGEiLCJmaWxlTmFtZSIsInN1YnN0ciIsImNodW5rSGVhZGVySW5kZXgiLCJjaHVua0hlYWRlckxpbmUiLCJjaHVua0hlYWRlciIsImh1bmsiLCJvbGRTdGFydCIsIm9sZExpbmVzIiwibmV3U3RhcnQiLCJuZXdMaW5lcyIsImxpbmVzIiwibGluZWRlbGltaXRlcnMiLCJhZGRDb3VudCIsInJlbW92ZUNvdW50IiwiaW5kZXhPZiIsIm9wZXJhdGlvbiIsImRpc3RhbmNlSXRlcmF0b3IiLCJzdGFydCIsIm1pbkxpbmUiLCJtYXhMaW5lIiwid2FudEZvcndhcmQiLCJiYWNrd2FyZEV4aGF1c3RlZCIsImZvcndhcmRFeGhhdXN0ZWQiLCJsb2NhbE9mZnNldCIsImFwcGx5UGF0Y2giLCJzb3VyY2UiLCJjb21wYXJlTGluZSIsImxpbmVOdW1iZXIiLCJwYXRjaENvbnRlbnQiLCJlcnJvckNvdW50IiwiZnV6ekZhY3RvciIsIm9mZnNldCIsInJlbW92ZUVPRk5MIiwiYWRkRU9GTkwiLCJodW5rRml0cyIsInRvUG9zIiwiaiIsImNvbnRlbnQiLCJkaWZmT2Zmc2V0IiwiX2kiLCJfaHVuayIsIl90b1BvcyIsImRlbGltaXRlciIsInByZXZpb3VzT3BlcmF0aW9uIiwiX2siLCJhcHBseVBhdGNoZXMiLCJjdXJyZW50SW5kZXgiLCJwcm9jZXNzSW5kZXgiLCJjb21wbGV0ZSIsImxvYWRGaWxlIiwiZXJyIiwidXBkYXRlZENvbnRlbnQiLCJwYXRjaGVkIiwic3RydWN0dXJlZFBhdGNoIiwib2xkRmlsZU5hbWUiLCJuZXdGaWxlTmFtZSIsIm9sZEhlYWRlciIsIm5ld0hlYWRlciIsImNvbnRleHQiLCJjb250ZXh0TGluZXMiLCJlbnRyeSIsIm9sZFJhbmdlU3RhcnQiLCJuZXdSYW5nZVN0YXJ0IiwiY3VyUmFuZ2UiLCJvbGRMaW5lIiwibmV3TGluZSIsIl9sb29wIiwiY3VycmVudCIsIl9jdXJSYW5nZSIsInByZXYiLCJhcHBseSIsIl9jdXJSYW5nZTIiLCJfY3VyUmFuZ2UzIiwiY29udGV4dFNpemUiLCJvbGRFT0ZOZXdsaW5lIiwibmV3RU9GTmV3bGluZSIsIm5vTmxCZWZvcmVBZGRzIiwiZm9ybWF0UGF0Y2giLCJjcmVhdGVUd29GaWxlc1BhdGNoIiwiY3JlYXRlUGF0Y2giLCJhcnJheUVxdWFsIiwiYSIsImIiLCJhcnJheVN0YXJ0c1dpdGgiLCJjYWxjTGluZUNvdW50IiwiX2NhbGNPbGROZXdMaW5lQ291bnQiLCJjYWxjT2xkTmV3TGluZUNvdW50IiwibWVyZ2UiLCJtaW5lIiwidGhlaXJzIiwiYmFzZSIsImxvYWRQYXRjaCIsImZpbGVOYW1lQ2hhbmdlZCIsInNlbGVjdEZpZWxkIiwibWluZUluZGV4IiwidGhlaXJzSW5kZXgiLCJtaW5lT2Zmc2V0IiwidGhlaXJzT2Zmc2V0IiwibWluZUN1cnJlbnQiLCJJbmZpbml0eSIsInRoZWlyc0N1cnJlbnQiLCJodW5rQmVmb3JlIiwiY2xvbmVIdW5rIiwibWVyZ2VkSHVuayIsIm1lcmdlTGluZXMiLCJwYXJhbSIsInBhdGNoIiwiY29uZmxpY3QiLCJjaGVjayIsIm1pbmVMaW5lcyIsInRoZWlyT2Zmc2V0IiwidGhlaXJMaW5lcyIsInRoZWlyIiwiaW5zZXJ0TGVhZGluZyIsInRoZWlyQ3VycmVudCIsIm11dHVhbENoYW5nZSIsIl9odW5rJGxpbmVzIiwiY29sbGVjdENoYW5nZSIsIl9odW5rJGxpbmVzMiIsInJlbW92YWwiLCJpbnNlcnRUcmFpbGluZyIsIm15Q2hhbmdlcyIsInRoZWlyQ2hhbmdlcyIsImFsbFJlbW92ZXMiLCJza2lwUmVtb3ZlU3VwZXJzZXQiLCJfaHVuayRsaW5lczMiLCJfaHVuayRsaW5lczQiLCJfaHVuayRsaW5lczUiLCJzd2FwIiwiY29sbGVjdENvbnRleHQiLCJtZXJnZWQiLCJfaHVuayRsaW5lczYiLCJpbnNlcnQiLCJzdGF0ZSIsIm1hdGNoQ2hhbmdlcyIsImNoYW5nZXMiLCJtYXRjaEluZGV4IiwiY29udGV4dENoYW5nZXMiLCJjb25mbGljdGVkIiwiY2hhbmdlIiwicmVkdWNlIiwicmVtb3ZlQ2hhbmdlcyIsImRlbHRhIiwiY2hhbmdlQ29udGVudCIsImZvckVhY2giLCJteUNvdW50IiwidGhlaXJDb3VudCIsImNvbnZlcnRDaGFuZ2VzVG9ETVAiLCJjb252ZXJ0Q2hhbmdlc1RvWE1MIiwiZXNjYXBlSFRNTCIsInMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/diff@5.1.0/node_modules/diff/lib/index.mjs\n");

/***/ })

};
;