"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/embla-carousel@8.0.0-rc15";
exports.ids = ["vendor-chunks/embla-carousel@8.0.0-rc15"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/embla-carousel@8.0.0-rc15/node_modules/embla-carousel/esm/embla-carousel.esm.js":
/*!****************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/embla-carousel@8.0.0-rc15/node_modules/embla-carousel/esm/embla-carousel.esm.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ EmblaCarousel)\n/* harmony export */ });\nfunction isNumber(subject) {\n    return typeof subject === \"number\";\n}\nfunction isString(subject) {\n    return typeof subject === \"string\";\n}\nfunction isBoolean(subject) {\n    return typeof subject === \"boolean\";\n}\nfunction isObject(subject) {\n    return Object.prototype.toString.call(subject) === \"[object Object]\";\n}\nfunction mathAbs(n) {\n    return Math.abs(n);\n}\nfunction mathSign(n) {\n    return Math.sign(n);\n}\nfunction deltaAbs(valueB, valueA) {\n    return mathAbs(valueB - valueA);\n}\nfunction factorAbs(valueB, valueA) {\n    if (valueB === 0 || valueA === 0) return 0;\n    if (mathAbs(valueB) <= mathAbs(valueA)) return 0;\n    const diff = deltaAbs(mathAbs(valueB), mathAbs(valueA));\n    return mathAbs(diff / valueB);\n}\nfunction arrayKeys(array) {\n    return objectKeys(array).map(Number);\n}\nfunction arrayLast(array) {\n    return array[arrayLastIndex(array)];\n}\nfunction arrayLastIndex(array) {\n    return Math.max(0, array.length - 1);\n}\nfunction arrayIsLastIndex(array, index) {\n    return index === arrayLastIndex(array);\n}\nfunction arrayFromNumber(n, startAt = 0) {\n    return Array.from(Array(n), (_, i)=>startAt + i);\n}\nfunction objectKeys(object) {\n    return Object.keys(object);\n}\nfunction objectsMergeDeep(objectA, objectB) {\n    return [\n        objectA,\n        objectB\n    ].reduce((mergedObjects, currentObject)=>{\n        objectKeys(currentObject).forEach((key)=>{\n            const valueA = mergedObjects[key];\n            const valueB = currentObject[key];\n            const areObjects = isObject(valueA) && isObject(valueB);\n            mergedObjects[key] = areObjects ? objectsMergeDeep(valueA, valueB) : valueB;\n        });\n        return mergedObjects;\n    }, {});\n}\nfunction isMouseEvent(evt, ownerWindow) {\n    return typeof ownerWindow.MouseEvent !== \"undefined\" && evt instanceof ownerWindow.MouseEvent;\n}\nfunction Alignment(align, viewSize) {\n    const predefined = {\n        start,\n        center,\n        end\n    };\n    function start() {\n        return 0;\n    }\n    function center(n) {\n        return end(n) / 2;\n    }\n    function end(n) {\n        return viewSize - n;\n    }\n    function measure(n, index) {\n        if (isString(align)) return predefined[align](n);\n        return align(viewSize, n, index);\n    }\n    const self = {\n        measure\n    };\n    return self;\n}\nfunction Axis(axis, direction) {\n    const scroll = axis === \"y\" ? \"y\" : \"x\";\n    const cross = axis === \"y\" ? \"x\" : \"y\";\n    const startEdge = getStartEdge();\n    const endEdge = getEndEdge();\n    function measureSize(nodeRect) {\n        const { width, height } = nodeRect;\n        return scroll === \"x\" ? width : height;\n    }\n    function getStartEdge() {\n        if (scroll === \"y\") return \"top\";\n        return direction === \"rtl\" ? \"right\" : \"left\";\n    }\n    function getEndEdge() {\n        if (scroll === \"y\") return \"bottom\";\n        return direction === \"rtl\" ? \"left\" : \"right\";\n    }\n    const self = {\n        scroll,\n        cross,\n        startEdge,\n        endEdge,\n        measureSize\n    };\n    return self;\n}\nfunction Limit(min, max) {\n    const length = mathAbs(min - max);\n    function reachedMin(n) {\n        return n < min;\n    }\n    function reachedMax(n) {\n        return n > max;\n    }\n    function reachedAny(n) {\n        return reachedMin(n) || reachedMax(n);\n    }\n    function constrain(n) {\n        if (!reachedAny(n)) return n;\n        return reachedMin(n) ? min : max;\n    }\n    function removeOffset(n) {\n        if (!length) return n;\n        return n - length * Math.ceil((n - max) / length);\n    }\n    const self = {\n        length,\n        max,\n        min,\n        constrain,\n        reachedAny,\n        reachedMax,\n        reachedMin,\n        removeOffset\n    };\n    return self;\n}\nfunction Counter(max, start, loop) {\n    const { constrain } = Limit(0, max);\n    const loopEnd = max + 1;\n    let counter = withinLimit(start);\n    function withinLimit(n) {\n        return !loop ? constrain(n) : mathAbs((loopEnd + n) % loopEnd);\n    }\n    function get() {\n        return counter;\n    }\n    function set(n) {\n        counter = withinLimit(n);\n        return self;\n    }\n    function add(n) {\n        return clone().set(get() + n);\n    }\n    function clone() {\n        return Counter(max, get(), loop);\n    }\n    const self = {\n        get,\n        set,\n        add,\n        clone\n    };\n    return self;\n}\nfunction Direction(direction) {\n    const sign = direction === \"rtl\" ? -1 : 1;\n    function apply(n) {\n        return n * sign;\n    }\n    const self = {\n        apply\n    };\n    return self;\n}\nfunction EventStore() {\n    let listeners = [];\n    function add(node, type, handler, options = {\n        passive: true\n    }) {\n        let removeListener;\n        if (\"addEventListener\" in node) {\n            node.addEventListener(type, handler, options);\n            removeListener = ()=>node.removeEventListener(type, handler, options);\n        } else {\n            const legacyMediaQueryList = node;\n            legacyMediaQueryList.addListener(handler);\n            removeListener = ()=>legacyMediaQueryList.removeListener(handler);\n        }\n        listeners.push(removeListener);\n        return self;\n    }\n    function clear() {\n        listeners = listeners.filter((remove)=>remove());\n    }\n    const self = {\n        add,\n        clear\n    };\n    return self;\n}\nfunction DragHandler(axis, direction, rootNode, ownerDocument, ownerWindow, target, dragTracker, location, animation, scrollTo, scrollBody, scrollTarget, index, eventHandler, percentOfView, dragFree, dragThreshold, skipSnaps, baseFriction, watchDrag) {\n    const { cross: crossAxis } = axis;\n    const focusNodes = [\n        \"INPUT\",\n        \"SELECT\",\n        \"TEXTAREA\"\n    ];\n    const nonPassiveEvent = {\n        passive: false\n    };\n    const initEvents = EventStore();\n    const dragEvents = EventStore();\n    const goToNextThreshold = Limit(50, 225).constrain(percentOfView.measure(20));\n    const snapForceBoost = {\n        mouse: 300,\n        touch: 400\n    };\n    const freeForceBoost = {\n        mouse: 500,\n        touch: 600\n    };\n    const baseSpeed = dragFree ? 43 : 25;\n    let isMoving = false;\n    let startScroll = 0;\n    let startCross = 0;\n    let pointerIsDown = false;\n    let preventScroll = false;\n    let preventClick = false;\n    let isMouse = false;\n    function init(emblaApi) {\n        if (!watchDrag) return;\n        function downIfAllowed(evt) {\n            if (isBoolean(watchDrag) || watchDrag(emblaApi, evt)) down(evt);\n        }\n        const node = rootNode;\n        initEvents.add(node, \"dragstart\", (evt)=>evt.preventDefault(), nonPassiveEvent).add(node, \"touchmove\", ()=>undefined, nonPassiveEvent).add(node, \"touchend\", ()=>undefined).add(node, \"touchstart\", downIfAllowed).add(node, \"mousedown\", downIfAllowed).add(node, \"touchcancel\", up).add(node, \"contextmenu\", up).add(node, \"click\", click, true);\n    }\n    function destroy() {\n        initEvents.clear();\n        dragEvents.clear();\n    }\n    function addDragEvents() {\n        const node = isMouse ? ownerDocument : rootNode;\n        dragEvents.add(node, \"touchmove\", move, nonPassiveEvent).add(node, \"touchend\", up).add(node, \"mousemove\", move, nonPassiveEvent).add(node, \"mouseup\", up);\n    }\n    function isFocusNode(node) {\n        const nodeName = node.nodeName || \"\";\n        return focusNodes.includes(nodeName);\n    }\n    function forceBoost() {\n        const boost = dragFree ? freeForceBoost : snapForceBoost;\n        const type = isMouse ? \"mouse\" : \"touch\";\n        return boost[type];\n    }\n    function allowedForce(force, targetChanged) {\n        const next = index.add(mathSign(force) * -1);\n        const baseForce = scrollTarget.byDistance(force, !dragFree).distance;\n        if (dragFree || mathAbs(force) < goToNextThreshold) return baseForce;\n        if (skipSnaps && targetChanged) return baseForce * 0.5;\n        return scrollTarget.byIndex(next.get(), 0).distance;\n    }\n    function down(evt) {\n        const isMouseEvt = isMouseEvent(evt, ownerWindow);\n        isMouse = isMouseEvt;\n        if (isMouseEvt && evt.button !== 0) return;\n        if (isFocusNode(evt.target)) return;\n        preventClick = dragFree && isMouseEvt && !evt.buttons && isMoving;\n        isMoving = deltaAbs(target.get(), location.get()) >= 2;\n        pointerIsDown = true;\n        dragTracker.pointerDown(evt);\n        scrollBody.useFriction(0).useDuration(0);\n        target.set(location);\n        addDragEvents();\n        startScroll = dragTracker.readPoint(evt);\n        startCross = dragTracker.readPoint(evt, crossAxis);\n        eventHandler.emit(\"pointerDown\");\n    }\n    function move(evt) {\n        const lastScroll = dragTracker.readPoint(evt);\n        const lastCross = dragTracker.readPoint(evt, crossAxis);\n        const diffScroll = deltaAbs(lastScroll, startScroll);\n        const diffCross = deltaAbs(lastCross, startCross);\n        if (!preventScroll && !isMouse) {\n            if (!evt.cancelable) return up(evt);\n            preventScroll = diffScroll > diffCross;\n            if (!preventScroll) return up(evt);\n        }\n        const diff = dragTracker.pointerMove(evt);\n        if (diffScroll > dragThreshold) preventClick = true;\n        scrollBody.useFriction(0.3).useDuration(1);\n        animation.start();\n        target.add(direction.apply(diff));\n        evt.preventDefault();\n    }\n    function up(evt) {\n        const currentLocation = scrollTarget.byDistance(0, false);\n        const targetChanged = currentLocation.index !== index.get();\n        const rawForce = dragTracker.pointerUp(evt) * forceBoost();\n        const force = allowedForce(direction.apply(rawForce), targetChanged);\n        const forceFactor = factorAbs(rawForce, force);\n        const speed = baseSpeed - 10 * forceFactor;\n        const friction = baseFriction + forceFactor / 50;\n        preventScroll = false;\n        pointerIsDown = false;\n        dragEvents.clear();\n        scrollBody.useDuration(speed).useFriction(friction);\n        scrollTo.distance(force, !dragFree);\n        isMouse = false;\n        eventHandler.emit(\"pointerUp\");\n    }\n    function click(evt) {\n        if (preventClick) {\n            evt.stopPropagation();\n            evt.preventDefault();\n        }\n    }\n    function pointerDown() {\n        return pointerIsDown;\n    }\n    const self = {\n        init,\n        pointerDown,\n        destroy\n    };\n    return self;\n}\nfunction DragTracker(axis, ownerWindow) {\n    const logInterval = 170;\n    let startEvent;\n    let lastEvent;\n    function readTime(evt) {\n        return evt.timeStamp;\n    }\n    function readPoint(evt, evtAxis) {\n        const property = evtAxis || axis.scroll;\n        const coord = `client${property === \"x\" ? \"X\" : \"Y\"}`;\n        return (isMouseEvent(evt, ownerWindow) ? evt : evt.touches[0])[coord];\n    }\n    function pointerDown(evt) {\n        startEvent = evt;\n        lastEvent = evt;\n        return readPoint(evt);\n    }\n    function pointerMove(evt) {\n        const diff = readPoint(evt) - readPoint(lastEvent);\n        const expired = readTime(evt) - readTime(startEvent) > logInterval;\n        lastEvent = evt;\n        if (expired) startEvent = evt;\n        return diff;\n    }\n    function pointerUp(evt) {\n        if (!startEvent || !lastEvent) return 0;\n        const diffDrag = readPoint(lastEvent) - readPoint(startEvent);\n        const diffTime = readTime(evt) - readTime(startEvent);\n        const expired = readTime(evt) - readTime(lastEvent) > logInterval;\n        const force = diffDrag / diffTime;\n        const isFlick = diffTime && !expired && mathAbs(force) > 0.1;\n        return isFlick ? force : 0;\n    }\n    const self = {\n        pointerDown,\n        pointerMove,\n        pointerUp,\n        readPoint\n    };\n    return self;\n}\nfunction NodeRects() {\n    function measure(node) {\n        const { offsetTop, offsetLeft, offsetWidth, offsetHeight } = node;\n        const offset = {\n            top: offsetTop,\n            right: offsetLeft + offsetWidth,\n            bottom: offsetTop + offsetHeight,\n            left: offsetLeft,\n            width: offsetWidth,\n            height: offsetHeight\n        };\n        return offset;\n    }\n    const self = {\n        measure\n    };\n    return self;\n}\nfunction PercentOfView(viewSize) {\n    function measure(n) {\n        return viewSize * (n / 100);\n    }\n    const self = {\n        measure\n    };\n    return self;\n}\nfunction ResizeHandler(container, eventHandler, ownerWindow, slides, axis, watchResize, nodeRects) {\n    let resizeObserver;\n    let containerSize;\n    let slideSizes = [];\n    let destroyed = false;\n    function readSize(node) {\n        return axis.measureSize(nodeRects.measure(node));\n    }\n    function init(emblaApi) {\n        if (!watchResize) return;\n        containerSize = readSize(container);\n        slideSizes = slides.map(readSize);\n        function defaultCallback(entries) {\n            for (const entry of entries){\n                const isContainer = entry.target === container;\n                const slideIndex = slides.indexOf(entry.target);\n                const lastSize = isContainer ? containerSize : slideSizes[slideIndex];\n                const newSize = readSize(isContainer ? container : slides[slideIndex]);\n                const diffSize = mathAbs(newSize - lastSize);\n                if (diffSize >= 0.5) {\n                    ownerWindow.requestAnimationFrame(()=>{\n                        emblaApi.reInit();\n                        eventHandler.emit(\"resize\");\n                    });\n                    break;\n                }\n            }\n        }\n        resizeObserver = new ResizeObserver((entries)=>{\n            if (destroyed) return;\n            if (isBoolean(watchResize) || watchResize(emblaApi, entries)) {\n                defaultCallback(entries);\n            }\n        });\n        const observeNodes = [\n            container\n        ].concat(slides);\n        observeNodes.forEach((node)=>resizeObserver.observe(node));\n    }\n    function destroy() {\n        if (resizeObserver) resizeObserver.disconnect();\n        destroyed = true;\n    }\n    const self = {\n        init,\n        destroy\n    };\n    return self;\n}\nfunction ScrollBody(location, offsetLocation, target, baseDuration, baseFriction) {\n    let bodyVelocity = 0;\n    let scrollDirection = 0;\n    let scrollDuration = baseDuration;\n    let scrollFriction = baseFriction;\n    let rawLocation = location.get();\n    let rawLocationPrevious = 0;\n    function seek() {\n        const diff = target.get() - location.get();\n        const isInstant = !scrollDuration;\n        let directionDiff = 0;\n        if (isInstant) {\n            bodyVelocity = 0;\n            location.set(target);\n            directionDiff = diff;\n        } else {\n            bodyVelocity += diff / scrollDuration;\n            bodyVelocity *= scrollFriction;\n            rawLocation += bodyVelocity;\n            location.add(bodyVelocity);\n            directionDiff = rawLocation - rawLocationPrevious;\n        }\n        scrollDirection = mathSign(directionDiff);\n        rawLocationPrevious = rawLocation;\n        return self;\n    }\n    function settled() {\n        const diff = target.get() - offsetLocation.get();\n        return mathAbs(diff) < 0.001;\n    }\n    function duration() {\n        return scrollDuration;\n    }\n    function direction() {\n        return scrollDirection;\n    }\n    function velocity() {\n        return bodyVelocity;\n    }\n    function useBaseDuration() {\n        return useDuration(baseDuration);\n    }\n    function useBaseFriction() {\n        return useFriction(baseFriction);\n    }\n    function useDuration(n) {\n        scrollDuration = n;\n        return self;\n    }\n    function useFriction(n) {\n        scrollFriction = n;\n        return self;\n    }\n    const self = {\n        direction,\n        duration,\n        velocity,\n        seek,\n        settled,\n        useBaseFriction,\n        useBaseDuration,\n        useFriction,\n        useDuration\n    };\n    return self;\n}\nfunction ScrollBounds(limit, location, target, scrollBody, percentOfView) {\n    const pullBackThreshold = percentOfView.measure(10);\n    const edgeOffsetTolerance = percentOfView.measure(50);\n    const frictionLimit = Limit(0.1, 0.99);\n    let disabled = false;\n    function shouldConstrain() {\n        if (disabled) return false;\n        if (!limit.reachedAny(target.get())) return false;\n        if (!limit.reachedAny(location.get())) return false;\n        return true;\n    }\n    function constrain(pointerDown) {\n        if (!shouldConstrain()) return;\n        const edge = limit.reachedMin(location.get()) ? \"min\" : \"max\";\n        const diffToEdge = mathAbs(limit[edge] - location.get());\n        const diffToTarget = target.get() - location.get();\n        const friction = frictionLimit.constrain(diffToEdge / edgeOffsetTolerance);\n        target.subtract(diffToTarget * friction);\n        if (!pointerDown && mathAbs(diffToTarget) < pullBackThreshold) {\n            target.set(limit.constrain(target.get()));\n            scrollBody.useDuration(25).useBaseFriction();\n        }\n    }\n    function toggleActive(active) {\n        disabled = !active;\n    }\n    const self = {\n        constrain,\n        toggleActive\n    };\n    return self;\n}\nfunction ScrollContain(viewSize, contentSize, snapsAligned, containScroll) {\n    const scrollBounds = Limit(-contentSize + viewSize, 0);\n    const snapsBounded = measureBounded();\n    const scrollContainLimit = findScrollContainLimit();\n    const snapsContained = measureContained();\n    function findScrollContainLimit() {\n        const startSnap = snapsBounded[0];\n        const endSnap = arrayLast(snapsBounded);\n        const min = snapsBounded.lastIndexOf(startSnap);\n        const max = snapsBounded.indexOf(endSnap) + 1;\n        return Limit(min, max);\n    }\n    function measureBounded() {\n        return snapsAligned.map((snapAligned, index)=>{\n            const isFirst = !index;\n            const isLast = arrayIsLastIndex(snapsAligned, index);\n            if (isFirst) return scrollBounds.max;\n            if (isLast) return scrollBounds.min;\n            return scrollBounds.constrain(snapAligned);\n        }).map((scrollBound)=>parseFloat(scrollBound.toFixed(3)));\n    }\n    function measureContained() {\n        if (contentSize <= viewSize) return [\n            scrollBounds.max\n        ];\n        if (containScroll === \"keepSnaps\") return snapsBounded;\n        const { min, max } = scrollContainLimit;\n        return snapsBounded.slice(min, max);\n    }\n    const self = {\n        snapsContained,\n        scrollContainLimit\n    };\n    return self;\n}\nfunction ScrollLimit(contentSize, scrollSnaps, loop) {\n    const max = scrollSnaps[0];\n    const min = loop ? max - contentSize : arrayLast(scrollSnaps);\n    const limit = Limit(min, max);\n    const self = {\n        limit\n    };\n    return self;\n}\nfunction ScrollLooper(contentSize, limit, offsetLocation, vectors) {\n    const jointSafety = 0.1;\n    const min = limit.min + jointSafety;\n    const max = limit.max + jointSafety;\n    const { reachedMin, reachedMax } = Limit(min, max);\n    function shouldLoop(direction) {\n        if (direction === 1) return reachedMax(offsetLocation.get());\n        if (direction === -1) return reachedMin(offsetLocation.get());\n        return false;\n    }\n    function loop(direction) {\n        if (!shouldLoop(direction)) return;\n        const loopDistance = contentSize * (direction * -1);\n        vectors.forEach((v)=>v.add(loopDistance));\n    }\n    const self = {\n        loop\n    };\n    return self;\n}\nfunction ScrollProgress(limit) {\n    const { max, length } = limit;\n    function get(n) {\n        const currentLocation = n - max;\n        return length ? currentLocation / -length : 0;\n    }\n    const self = {\n        get\n    };\n    return self;\n}\nfunction ScrollSnaps(axis, alignment, containerRect, slideRects, slidesToScroll) {\n    const { startEdge, endEdge } = axis;\n    const { groupSlides } = slidesToScroll;\n    const alignments = measureSizes().map(alignment.measure);\n    const snaps = measureUnaligned();\n    const snapsAligned = measureAligned();\n    function measureSizes() {\n        return groupSlides(slideRects).map((rects)=>arrayLast(rects)[endEdge] - rects[0][startEdge]).map(mathAbs);\n    }\n    function measureUnaligned() {\n        return slideRects.map((rect)=>containerRect[startEdge] - rect[startEdge]).map((snap)=>-mathAbs(snap));\n    }\n    function measureAligned() {\n        return groupSlides(snaps).map((g)=>g[0]).map((snap, index)=>snap + alignments[index]);\n    }\n    const self = {\n        snaps,\n        snapsAligned\n    };\n    return self;\n}\nfunction SlideRegistry(viewSize, contentSize, containSnaps, containScroll, scrollContainLimit, slidesToScroll, slideIndexes) {\n    const { groupSlides } = slidesToScroll;\n    const { min, max } = scrollContainLimit;\n    const slideRegistry = createSlideRegistry();\n    function createSlideRegistry() {\n        const groupedSlideIndexes = groupSlides(slideIndexes);\n        const doNotContain = !containSnaps || containScroll === \"keepSnaps\";\n        if (doNotContain || contentSize <= viewSize) return groupedSlideIndexes;\n        return groupedSlideIndexes.slice(min, max).map((group, index, groups)=>{\n            const isFirst = !index;\n            const isLast = arrayIsLastIndex(groups, index);\n            if (isFirst) {\n                const range = arrayLast(groups[0]) + 1;\n                return arrayFromNumber(range);\n            }\n            if (isLast) {\n                const range = arrayLastIndex(slideIndexes) - arrayLast(groups)[0] + 1;\n                return arrayFromNumber(range, arrayLast(groups)[0]);\n            }\n            return group;\n        });\n    }\n    const self = {\n        slideRegistry\n    };\n    return self;\n}\nfunction ScrollTarget(loop, scrollSnaps, contentSize, limit, targetVector) {\n    const { reachedAny, removeOffset, constrain } = limit;\n    function minDistance(distances) {\n        return distances.concat().sort((a, b)=>mathAbs(a) - mathAbs(b))[0];\n    }\n    function findTargetSnap(target) {\n        const distance = loop ? removeOffset(target) : constrain(target);\n        const ascDiffsToSnaps = scrollSnaps.map((scrollSnap)=>scrollSnap - distance).map((diffToSnap)=>shortcut(diffToSnap, 0)).map((diff, i)=>({\n                diff,\n                index: i\n            })).sort((d1, d2)=>mathAbs(d1.diff) - mathAbs(d2.diff));\n        const { index } = ascDiffsToSnaps[0];\n        return {\n            index,\n            distance\n        };\n    }\n    function shortcut(target, direction) {\n        const targets = [\n            target,\n            target + contentSize,\n            target - contentSize\n        ];\n        if (!loop) return targets[0];\n        if (!direction) return minDistance(targets);\n        const matchingTargets = targets.filter((t)=>mathSign(t) === direction);\n        if (matchingTargets.length) return minDistance(matchingTargets);\n        return arrayLast(targets) - contentSize;\n    }\n    function byIndex(index, direction) {\n        const diffToSnap = scrollSnaps[index] - targetVector.get();\n        const distance = shortcut(diffToSnap, direction);\n        return {\n            index,\n            distance\n        };\n    }\n    function byDistance(distance, snap) {\n        const target = targetVector.get() + distance;\n        const { index, distance: targetSnapDistance } = findTargetSnap(target);\n        const reachedBound = !loop && reachedAny(target);\n        if (!snap || reachedBound) return {\n            index,\n            distance\n        };\n        const diffToSnap = scrollSnaps[index] - targetSnapDistance;\n        const snapDistance = distance + shortcut(diffToSnap, 0);\n        return {\n            index,\n            distance: snapDistance\n        };\n    }\n    const self = {\n        byDistance,\n        byIndex,\n        shortcut\n    };\n    return self;\n}\nfunction ScrollTo(animation, indexCurrent, indexPrevious, scrollTarget, targetVector, eventHandler) {\n    function scrollTo(target) {\n        const distanceDiff = target.distance;\n        const indexDiff = target.index !== indexCurrent.get();\n        targetVector.add(distanceDiff);\n        if (distanceDiff) animation.start();\n        if (indexDiff) {\n            indexPrevious.set(indexCurrent.get());\n            indexCurrent.set(target.index);\n            eventHandler.emit(\"select\");\n        }\n    }\n    function distance(n, snap) {\n        const target = scrollTarget.byDistance(n, snap);\n        scrollTo(target);\n    }\n    function index(n, direction) {\n        const targetIndex = indexCurrent.clone().set(n);\n        const target = scrollTarget.byIndex(targetIndex.get(), direction);\n        scrollTo(target);\n    }\n    const self = {\n        distance,\n        index\n    };\n    return self;\n}\nfunction SlideFocus(root, slides, slideRegistry, scrollTo, scrollBody, eventStore) {\n    let lastTabPressTime = 0;\n    function init() {\n        eventStore.add(document, \"keydown\", registerTabPress, false);\n        slides.forEach(addSlideFocusEvent);\n    }\n    function registerTabPress(event) {\n        if (event.code === \"Tab\") lastTabPressTime = new Date().getTime();\n    }\n    function addSlideFocusEvent(slide) {\n        const focus = ()=>{\n            const nowTime = new Date().getTime();\n            const diffTime = nowTime - lastTabPressTime;\n            if (diffTime > 10) return;\n            root.scrollLeft = 0;\n            const index = slides.indexOf(slide);\n            const group = slideRegistry.findIndex((group)=>group.includes(index));\n            if (!isNumber(group)) return;\n            scrollBody.useDuration(0);\n            scrollTo.index(group, 0);\n        };\n        eventStore.add(slide, \"focus\", focus, {\n            passive: true,\n            capture: true\n        });\n    }\n    const self = {\n        init\n    };\n    return self;\n}\nfunction Vector1D(initialValue) {\n    let value = initialValue;\n    function get() {\n        return value;\n    }\n    function set(n) {\n        value = normalizeInput(n);\n    }\n    function add(n) {\n        value += normalizeInput(n);\n    }\n    function subtract(n) {\n        value -= normalizeInput(n);\n    }\n    function normalizeInput(n) {\n        return isNumber(n) ? n : n.get();\n    }\n    const self = {\n        get,\n        set,\n        add,\n        subtract\n    };\n    return self;\n}\nfunction Translate(axis, direction, container) {\n    const translate = axis.scroll === \"x\" ? x : y;\n    const containerStyle = container.style;\n    let disabled = false;\n    function x(n) {\n        return `translate3d(${n}px,0px,0px)`;\n    }\n    function y(n) {\n        return `translate3d(0px,${n}px,0px)`;\n    }\n    function to(target) {\n        if (disabled) return;\n        containerStyle.transform = translate(direction.apply(target));\n    }\n    function toggleActive(active) {\n        disabled = !active;\n    }\n    function clear() {\n        if (disabled) return;\n        containerStyle.transform = \"\";\n        if (!container.getAttribute(\"style\")) container.removeAttribute(\"style\");\n    }\n    const self = {\n        clear,\n        to,\n        toggleActive\n    };\n    return self;\n}\nfunction SlideLooper(axis, direction, viewSize, contentSize, slideSizes, slideSizesWithGaps, snaps, scrollSnaps, offsetLocation, slides) {\n    const roundingSafety = 0.5;\n    const ascItems = arrayKeys(slideSizesWithGaps);\n    const descItems = arrayKeys(slideSizesWithGaps).reverse();\n    const loopPoints = startPoints().concat(endPoints());\n    function removeSlideSizes(indexes, from) {\n        return indexes.reduce((a, i)=>{\n            return a - slideSizesWithGaps[i];\n        }, from);\n    }\n    function slidesInGap(indexes, gap) {\n        return indexes.reduce((a, i)=>{\n            const remainingGap = removeSlideSizes(a, gap);\n            return remainingGap > 0 ? a.concat([\n                i\n            ]) : a;\n        }, []);\n    }\n    function findSlideBounds(offset) {\n        return snaps.map((snap, index)=>({\n                start: snap - slideSizes[index] + roundingSafety + offset,\n                end: snap + viewSize - roundingSafety + offset\n            }));\n    }\n    function findLoopPoints(indexes, offset, isEndEdge) {\n        const slideBounds = findSlideBounds(offset);\n        return indexes.map((index)=>{\n            const initial = isEndEdge ? 0 : -contentSize;\n            const altered = isEndEdge ? contentSize : 0;\n            const boundEdge = isEndEdge ? \"end\" : \"start\";\n            const loopPoint = slideBounds[index][boundEdge];\n            return {\n                index,\n                loopPoint,\n                slideLocation: Vector1D(-1),\n                translate: Translate(axis, direction, slides[index]),\n                target: ()=>offsetLocation.get() > loopPoint ? initial : altered\n            };\n        });\n    }\n    function startPoints() {\n        const gap = scrollSnaps[0];\n        const indexes = slidesInGap(descItems, gap);\n        return findLoopPoints(indexes, contentSize, false);\n    }\n    function endPoints() {\n        const gap = viewSize - scrollSnaps[0] - 1;\n        const indexes = slidesInGap(ascItems, gap);\n        return findLoopPoints(indexes, -contentSize, true);\n    }\n    function canLoop() {\n        return loopPoints.every(({ index })=>{\n            const otherIndexes = ascItems.filter((i)=>i !== index);\n            return removeSlideSizes(otherIndexes, viewSize) <= 0.1;\n        });\n    }\n    function loop() {\n        loopPoints.forEach((loopPoint)=>{\n            const { target, translate, slideLocation } = loopPoint;\n            const shiftLocation = target();\n            if (shiftLocation === slideLocation.get()) return;\n            translate.to(shiftLocation);\n            slideLocation.set(shiftLocation);\n        });\n    }\n    function clear() {\n        loopPoints.forEach((loopPoint)=>loopPoint.translate.clear());\n    }\n    const self = {\n        canLoop,\n        clear,\n        loop,\n        loopPoints\n    };\n    return self;\n}\nfunction SlidesHandler(container, eventHandler, watchSlides) {\n    let mutationObserver;\n    let destroyed = false;\n    function init(emblaApi) {\n        if (!watchSlides) return;\n        function defaultCallback(mutations) {\n            for (const mutation of mutations){\n                if (mutation.type === \"childList\") {\n                    emblaApi.reInit();\n                    eventHandler.emit(\"slidesChanged\");\n                    break;\n                }\n            }\n        }\n        mutationObserver = new MutationObserver((mutations)=>{\n            if (destroyed) return;\n            if (isBoolean(watchSlides) || watchSlides(emblaApi, mutations)) {\n                defaultCallback(mutations);\n            }\n        });\n        mutationObserver.observe(container, {\n            childList: true\n        });\n    }\n    function destroy() {\n        if (mutationObserver) mutationObserver.disconnect();\n        destroyed = true;\n    }\n    const self = {\n        init,\n        destroy\n    };\n    return self;\n}\nfunction SlidesInView(container, slides, eventHandler, threshold) {\n    const intersectionEntryMap = {};\n    let inViewCache = null;\n    let notInViewCache = null;\n    let intersectionObserver;\n    let destroyed = false;\n    function init() {\n        intersectionObserver = new IntersectionObserver((entries)=>{\n            if (destroyed) return;\n            entries.forEach((entry)=>{\n                const index = slides.indexOf(entry.target);\n                intersectionEntryMap[index] = entry;\n            });\n            inViewCache = null;\n            notInViewCache = null;\n            eventHandler.emit(\"slidesInView\");\n        }, {\n            root: container.parentElement,\n            threshold\n        });\n        slides.forEach((slide)=>intersectionObserver.observe(slide));\n    }\n    function destroy() {\n        if (intersectionObserver) intersectionObserver.disconnect();\n        destroyed = true;\n    }\n    function createInViewList(inView) {\n        return objectKeys(intersectionEntryMap).reduce((list, slideIndex)=>{\n            const index = parseInt(slideIndex);\n            const { isIntersecting } = intersectionEntryMap[index];\n            const inViewMatch = inView && isIntersecting;\n            const notInViewMatch = !inView && !isIntersecting;\n            if (inViewMatch || notInViewMatch) list.push(index);\n            return list;\n        }, []);\n    }\n    function get(inView = true) {\n        if (inView && inViewCache) return inViewCache;\n        if (!inView && notInViewCache) return notInViewCache;\n        const slideIndexes = createInViewList(inView);\n        if (inView) inViewCache = slideIndexes;\n        if (!inView) notInViewCache = slideIndexes;\n        return slideIndexes;\n    }\n    const self = {\n        init,\n        destroy,\n        get\n    };\n    return self;\n}\nfunction SlideSizes(axis, containerRect, slideRects, slides, readEdgeGap, ownerWindow) {\n    const { measureSize, startEdge, endEdge } = axis;\n    const withEdgeGap = slideRects[0] && readEdgeGap;\n    const startGap = measureStartGap();\n    const endGap = measureEndGap();\n    const slideSizes = slideRects.map(measureSize);\n    const slideSizesWithGaps = measureWithGaps();\n    function measureStartGap() {\n        if (!withEdgeGap) return 0;\n        const slideRect = slideRects[0];\n        return mathAbs(containerRect[startEdge] - slideRect[startEdge]);\n    }\n    function measureEndGap() {\n        if (!withEdgeGap) return 0;\n        const style = ownerWindow.getComputedStyle(arrayLast(slides));\n        return parseFloat(style.getPropertyValue(`margin-${endEdge}`));\n    }\n    function measureWithGaps() {\n        return slideRects.map((rect, index, rects)=>{\n            const isFirst = !index;\n            const isLast = arrayIsLastIndex(rects, index);\n            if (isFirst) return slideSizes[index] + startGap;\n            if (isLast) return slideSizes[index] + endGap;\n            return rects[index + 1][startEdge] - rect[startEdge];\n        }).map(mathAbs);\n    }\n    const self = {\n        slideSizes,\n        slideSizesWithGaps,\n        startGap,\n        endGap\n    };\n    return self;\n}\nfunction SlidesToScroll(axis, direction, viewSize, slidesToScroll, loop, containerRect, slideRects, startGap, endGap) {\n    const { startEdge, endEdge } = axis;\n    const groupByNumber = isNumber(slidesToScroll);\n    function byNumber(array, groupSize) {\n        return arrayKeys(array).filter((i)=>i % groupSize === 0).map((i)=>array.slice(i, i + groupSize));\n    }\n    function bySize(array) {\n        if (!array.length) return [];\n        return arrayKeys(array).reduce((groups, rectB)=>{\n            const rectA = arrayLast(groups) || 0;\n            const isFirst = rectA === 0;\n            const isLast = rectB === arrayLastIndex(array);\n            const edgeA = containerRect[startEdge] - slideRects[rectA][startEdge];\n            const edgeB = containerRect[startEdge] - slideRects[rectB][endEdge];\n            const gapA = !loop && isFirst ? direction.apply(startGap) : 0;\n            const gapB = !loop && isLast ? direction.apply(endGap) : 0;\n            const chunkSize = mathAbs(edgeB - gapB - (edgeA + gapA));\n            if (chunkSize > viewSize) groups.push(rectB);\n            if (isLast) groups.push(array.length);\n            return groups;\n        }, []).map((currentSize, index, groups)=>{\n            const previousSize = Math.max(groups[index - 1] || 0);\n            return array.slice(previousSize, currentSize);\n        });\n    }\n    function groupSlides(array) {\n        return groupByNumber ? byNumber(array, slidesToScroll) : bySize(array);\n    }\n    const self = {\n        groupSlides\n    };\n    return self;\n}\nfunction Engine(root, container, slides, ownerDocument, ownerWindow, options, eventHandler, animations) {\n    // Options\n    const { align, axis: scrollAxis, direction: contentDirection, startIndex, loop, duration, dragFree, dragThreshold, inViewThreshold, slidesToScroll: groupSlides, skipSnaps, containScroll, watchResize, watchSlides, watchDrag } = options;\n    // Measurements\n    const nodeRects = NodeRects();\n    const containerRect = nodeRects.measure(container);\n    const slideRects = slides.map(nodeRects.measure);\n    const direction = Direction(contentDirection);\n    const axis = Axis(scrollAxis, contentDirection);\n    const viewSize = axis.measureSize(containerRect);\n    const percentOfView = PercentOfView(viewSize);\n    const alignment = Alignment(align, viewSize);\n    const containSnaps = !loop && !!containScroll;\n    const readEdgeGap = loop || !!containScroll;\n    const { slideSizes, slideSizesWithGaps, startGap, endGap } = SlideSizes(axis, containerRect, slideRects, slides, readEdgeGap, ownerWindow);\n    const slidesToScroll = SlidesToScroll(axis, direction, viewSize, groupSlides, loop, containerRect, slideRects, startGap, endGap);\n    const { snaps, snapsAligned } = ScrollSnaps(axis, alignment, containerRect, slideRects, slidesToScroll);\n    const contentSize = -arrayLast(snaps) + arrayLast(slideSizesWithGaps);\n    const { snapsContained, scrollContainLimit } = ScrollContain(viewSize, contentSize, snapsAligned, containScroll);\n    const scrollSnaps = containSnaps ? snapsContained : snapsAligned;\n    const { limit } = ScrollLimit(contentSize, scrollSnaps, loop);\n    // Indexes\n    const index = Counter(arrayLastIndex(scrollSnaps), startIndex, loop);\n    const indexPrevious = index.clone();\n    const slideIndexes = arrayKeys(slides);\n    // Animation\n    const update = ({ dragHandler, scrollBody, scrollBounds, options: { loop } })=>{\n        if (!loop) scrollBounds.constrain(dragHandler.pointerDown());\n        scrollBody.seek();\n    };\n    const render = ({ scrollBody, translate, location, offsetLocation, scrollLooper, slideLooper, dragHandler, animation, eventHandler, options: { loop } }, lagOffset)=>{\n        const velocity = scrollBody.velocity();\n        const hasSettled = scrollBody.settled();\n        if (hasSettled && !dragHandler.pointerDown()) {\n            animation.stop();\n            eventHandler.emit(\"settle\");\n        }\n        if (!hasSettled) eventHandler.emit(\"scroll\");\n        offsetLocation.set(location.get() - velocity + velocity * lagOffset);\n        if (loop) {\n            scrollLooper.loop(scrollBody.direction());\n            slideLooper.loop();\n        }\n        translate.to(offsetLocation.get());\n    };\n    const animation = {\n        start: ()=>animations.start(engine),\n        stop: ()=>animations.stop(engine),\n        update: ()=>update(engine),\n        render: (lagOffset)=>render(engine, lagOffset)\n    };\n    // Shared\n    const friction = 0.68;\n    const startLocation = scrollSnaps[index.get()];\n    const location = Vector1D(startLocation);\n    const offsetLocation = Vector1D(startLocation);\n    const target = Vector1D(startLocation);\n    const scrollBody = ScrollBody(location, offsetLocation, target, duration, friction);\n    const scrollTarget = ScrollTarget(loop, scrollSnaps, contentSize, limit, target);\n    const scrollTo = ScrollTo(animation, index, indexPrevious, scrollTarget, target, eventHandler);\n    const scrollProgress = ScrollProgress(limit);\n    const eventStore = EventStore();\n    const slidesInView = SlidesInView(container, slides, eventHandler, inViewThreshold);\n    const { slideRegistry } = SlideRegistry(viewSize, contentSize, containSnaps, containScroll, scrollContainLimit, slidesToScroll, slideIndexes);\n    const slideFocus = SlideFocus(root, slides, slideRegistry, scrollTo, scrollBody, eventStore);\n    // Engine\n    const engine = {\n        ownerDocument,\n        ownerWindow,\n        eventHandler,\n        containerRect,\n        slideRects,\n        animation,\n        axis,\n        direction,\n        dragHandler: DragHandler(axis, direction, root, ownerDocument, ownerWindow, target, DragTracker(axis, ownerWindow), location, animation, scrollTo, scrollBody, scrollTarget, index, eventHandler, percentOfView, dragFree, dragThreshold, skipSnaps, friction, watchDrag),\n        eventStore,\n        percentOfView,\n        index,\n        indexPrevious,\n        limit,\n        location,\n        offsetLocation,\n        options,\n        resizeHandler: ResizeHandler(container, eventHandler, ownerWindow, slides, axis, watchResize, nodeRects),\n        scrollBody,\n        scrollBounds: ScrollBounds(limit, location, target, scrollBody, percentOfView),\n        scrollLooper: ScrollLooper(contentSize, limit, offsetLocation, [\n            location,\n            offsetLocation,\n            target\n        ]),\n        scrollProgress,\n        scrollSnapList: scrollSnaps.map(scrollProgress.get),\n        scrollSnaps,\n        scrollTarget,\n        scrollTo,\n        slideLooper: SlideLooper(axis, direction, viewSize, contentSize, slideSizes, slideSizesWithGaps, snaps, scrollSnaps, offsetLocation, slides),\n        slideFocus,\n        slidesHandler: SlidesHandler(container, eventHandler, watchSlides),\n        slidesInView,\n        slideIndexes,\n        slideRegistry,\n        slidesToScroll,\n        target,\n        translate: Translate(axis, direction, container)\n    };\n    return engine;\n}\nfunction Animations(ownerWindow) {\n    const timeStep = 1000 / 60;\n    let engines = [];\n    let lastTimeStamp = null;\n    let lag = 0;\n    let animationFrame = 0;\n    function animate(timeStamp) {\n        if (!lastTimeStamp) lastTimeStamp = timeStamp;\n        const elapsed = timeStamp - lastTimeStamp;\n        lastTimeStamp = timeStamp;\n        lag += elapsed;\n        while(lag >= timeStep){\n            engines.forEach(({ animation })=>animation.update());\n            lag -= timeStep;\n        }\n        const lagOffset = mathAbs(lag / timeStep);\n        engines.forEach(({ animation })=>animation.render(lagOffset));\n        if (animationFrame) ownerWindow.requestAnimationFrame(animate);\n    }\n    function start(engine) {\n        if (!engines.includes(engine)) engines.push(engine);\n        if (animationFrame) return;\n        animationFrame = ownerWindow.requestAnimationFrame(animate);\n    }\n    function stop(engine) {\n        engines = engines.filter((e)=>e !== engine);\n        if (engines.length) return;\n        ownerWindow.cancelAnimationFrame(animationFrame);\n        lastTimeStamp = null;\n        lag = 0;\n        animationFrame = 0;\n    }\n    function reset() {\n        lastTimeStamp = null;\n        lag = 0;\n    }\n    const self = {\n        start,\n        stop,\n        reset,\n        window: ownerWindow\n    };\n    return self;\n}\nfunction EventHandler() {\n    const listeners = {};\n    let api;\n    function init(emblaApi) {\n        api = emblaApi;\n    }\n    function getListeners(evt) {\n        return listeners[evt] || [];\n    }\n    function emit(evt) {\n        getListeners(evt).forEach((e)=>e(api, evt));\n        return self;\n    }\n    function on(evt, cb) {\n        listeners[evt] = getListeners(evt).concat([\n            cb\n        ]);\n        return self;\n    }\n    function off(evt, cb) {\n        listeners[evt] = getListeners(evt).filter((e)=>e !== cb);\n        return self;\n    }\n    const self = {\n        init,\n        emit,\n        off,\n        on\n    };\n    return self;\n}\nconst defaultOptions = {\n    align: \"center\",\n    axis: \"x\",\n    container: null,\n    slides: null,\n    containScroll: \"trimSnaps\",\n    direction: \"ltr\",\n    slidesToScroll: 1,\n    inViewThreshold: 0,\n    breakpoints: {},\n    dragFree: false,\n    dragThreshold: 10,\n    loop: false,\n    skipSnaps: false,\n    duration: 25,\n    startIndex: 0,\n    active: true,\n    watchDrag: true,\n    watchResize: true,\n    watchSlides: true\n};\nfunction OptionsHandler(ownerWindow) {\n    function mergeOptions(optionsA, optionsB) {\n        return objectsMergeDeep(optionsA, optionsB || {});\n    }\n    function optionsAtMedia(options) {\n        const optionsAtMedia = options.breakpoints || {};\n        const matchedMediaOptions = objectKeys(optionsAtMedia).filter((media)=>ownerWindow.matchMedia(media).matches).map((media)=>optionsAtMedia[media]).reduce((a, mediaOption)=>mergeOptions(a, mediaOption), {});\n        return mergeOptions(options, matchedMediaOptions);\n    }\n    function optionsMediaQueries(optionsList) {\n        return optionsList.map((options)=>objectKeys(options.breakpoints || {})).reduce((acc, mediaQueries)=>acc.concat(mediaQueries), []).map(ownerWindow.matchMedia);\n    }\n    const self = {\n        mergeOptions,\n        optionsAtMedia,\n        optionsMediaQueries\n    };\n    return self;\n}\nfunction PluginsHandler(optionsHandler) {\n    let activePlugins = [];\n    function init(emblaApi, plugins) {\n        activePlugins = plugins.filter(({ options })=>optionsHandler.optionsAtMedia(options).active !== false);\n        activePlugins.forEach((plugin)=>plugin.init(emblaApi, optionsHandler));\n        return plugins.reduce((map, plugin)=>Object.assign(map, {\n                [plugin.name]: plugin\n            }), {});\n    }\n    function destroy() {\n        activePlugins = activePlugins.filter((plugin)=>plugin.destroy());\n    }\n    const self = {\n        init,\n        destroy\n    };\n    return self;\n}\nfunction EmblaCarousel(root, userOptions, userPlugins) {\n    const ownerDocument = root.ownerDocument;\n    const ownerWindow = ownerDocument.defaultView;\n    const optionsHandler = OptionsHandler(ownerWindow);\n    const pluginsHandler = PluginsHandler(optionsHandler);\n    const mediaHandlers = EventStore();\n    const documentVisibleHandler = EventStore();\n    const eventHandler = EventHandler();\n    const { animationRealms } = EmblaCarousel;\n    const { mergeOptions, optionsAtMedia, optionsMediaQueries } = optionsHandler;\n    const { on, off, emit } = eventHandler;\n    const reInit = reActivate;\n    let destroyed = false;\n    let engine;\n    let optionsBase = mergeOptions(defaultOptions, EmblaCarousel.globalOptions);\n    let options = mergeOptions(optionsBase);\n    let pluginList = [];\n    let pluginApis;\n    let container;\n    let slides;\n    function storeElements() {\n        const { container: userContainer, slides: userSlides } = options;\n        const customContainer = isString(userContainer) ? root.querySelector(userContainer) : userContainer;\n        container = customContainer || root.children[0];\n        const customSlides = isString(userSlides) ? container.querySelectorAll(userSlides) : userSlides;\n        slides = [].slice.call(customSlides || container.children);\n    }\n    function createEngine(options, animations) {\n        const engine = Engine(root, container, slides, ownerDocument, ownerWindow, options, eventHandler, animations);\n        if (options.loop && !engine.slideLooper.canLoop()) {\n            const optionsWithoutLoop = Object.assign({}, options, {\n                loop: false\n            });\n            return createEngine(optionsWithoutLoop, animations);\n        }\n        return engine;\n    }\n    function activate(withOptions, withPlugins) {\n        if (destroyed) return;\n        const animationRealm = animationRealms.find((a)=>a.window === ownerWindow);\n        const animations = animationRealm || Animations(ownerWindow);\n        if (!animationRealm) animationRealms.push(animations);\n        optionsBase = mergeOptions(optionsBase, withOptions);\n        options = optionsAtMedia(optionsBase);\n        pluginList = withPlugins || pluginList;\n        storeElements();\n        engine = createEngine(options, animations);\n        optionsMediaQueries([\n            optionsBase,\n            ...pluginList.map(({ options })=>options)\n        ]).forEach((query)=>mediaHandlers.add(query, \"change\", reActivate));\n        if (!options.active) return;\n        engine.translate.to(engine.location.get());\n        engine.slidesInView.init();\n        engine.slideFocus.init();\n        engine.eventHandler.init(self);\n        engine.resizeHandler.init(self);\n        engine.slidesHandler.init(self);\n        documentVisibleHandler.add(ownerDocument, \"visibilitychange\", ()=>{\n            if (ownerDocument.hidden) animations.reset();\n        });\n        if (engine.options.loop) engine.slideLooper.loop();\n        if (container.offsetParent && slides.length) engine.dragHandler.init(self);\n        pluginApis = pluginsHandler.init(self, pluginList);\n    }\n    function reActivate(withOptions, withPlugins) {\n        const startIndex = selectedScrollSnap();\n        deActivate();\n        activate(mergeOptions({\n            startIndex\n        }, withOptions), withPlugins);\n        eventHandler.emit(\"reInit\");\n    }\n    function deActivate() {\n        engine.dragHandler.destroy();\n        engine.animation.stop();\n        engine.eventStore.clear();\n        engine.translate.clear();\n        engine.slideLooper.clear();\n        engine.resizeHandler.destroy();\n        engine.slidesHandler.destroy();\n        engine.slidesInView.destroy();\n        pluginsHandler.destroy();\n        mediaHandlers.clear();\n        documentVisibleHandler.clear();\n    }\n    function destroy() {\n        if (destroyed) return;\n        destroyed = true;\n        mediaHandlers.clear();\n        deActivate();\n        eventHandler.emit(\"destroy\");\n    }\n    function scrollTo(index, jump, direction) {\n        if (!options.active || destroyed) return;\n        engine.scrollBody.useBaseFriction().useDuration(jump ? 0 : options.duration);\n        engine.scrollTo.index(index, direction || 0);\n    }\n    function scrollNext(jump) {\n        const next = engine.index.add(1).get();\n        scrollTo(next, jump === true, -1);\n    }\n    function scrollPrev(jump) {\n        const prev = engine.index.add(-1).get();\n        scrollTo(prev, jump === true, 1);\n    }\n    function canScrollNext() {\n        const next = engine.index.add(1).get();\n        return next !== selectedScrollSnap();\n    }\n    function canScrollPrev() {\n        const prev = engine.index.add(-1).get();\n        return prev !== selectedScrollSnap();\n    }\n    function scrollSnapList() {\n        return engine.scrollSnapList;\n    }\n    function scrollProgress() {\n        return engine.scrollProgress.get(engine.location.get());\n    }\n    function selectedScrollSnap() {\n        return engine.index.get();\n    }\n    function previousScrollSnap() {\n        return engine.indexPrevious.get();\n    }\n    function slidesInView() {\n        return engine.slidesInView.get();\n    }\n    function slidesNotInView() {\n        return engine.slidesInView.get(false);\n    }\n    function plugins() {\n        return pluginApis;\n    }\n    function internalEngine() {\n        return engine;\n    }\n    function rootNode() {\n        return root;\n    }\n    function containerNode() {\n        return container;\n    }\n    function slideNodes() {\n        return slides;\n    }\n    const self = {\n        canScrollNext,\n        canScrollPrev,\n        containerNode,\n        internalEngine,\n        destroy,\n        off,\n        on,\n        emit,\n        plugins,\n        previousScrollSnap,\n        reInit,\n        rootNode,\n        scrollNext,\n        scrollPrev,\n        scrollProgress,\n        scrollSnapList,\n        scrollTo,\n        selectedScrollSnap,\n        slideNodes,\n        slidesInView,\n        slidesNotInView\n    };\n    activate(userOptions, userPlugins);\n    setTimeout(()=>eventHandler.emit(\"init\"), 0);\n    return self;\n}\nEmblaCarousel.animationRealms = [];\nEmblaCarousel.globalOptions = undefined;\n //# sourceMappingURL=embla-carousel.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2VtYmxhLWNhcm91c2VsQDguMC4wLXJjMTUvbm9kZV9tb2R1bGVzL2VtYmxhLWNhcm91c2VsL2VzbS9lbWJsYS1jYXJvdXNlbC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLFNBQVNBLFNBQVNDLE9BQU87SUFDdkIsT0FBTyxPQUFPQSxZQUFZO0FBQzVCO0FBQ0EsU0FBU0MsU0FBU0QsT0FBTztJQUN2QixPQUFPLE9BQU9BLFlBQVk7QUFDNUI7QUFDQSxTQUFTRSxVQUFVRixPQUFPO0lBQ3hCLE9BQU8sT0FBT0EsWUFBWTtBQUM1QjtBQUNBLFNBQVNHLFNBQVNILE9BQU87SUFDdkIsT0FBT0ksT0FBT0MsU0FBUyxDQUFDQyxRQUFRLENBQUNDLElBQUksQ0FBQ1AsYUFBYTtBQUNyRDtBQUNBLFNBQVNRLFFBQVFDLENBQUM7SUFDaEIsT0FBT0MsS0FBS0MsR0FBRyxDQUFDRjtBQUNsQjtBQUNBLFNBQVNHLFNBQVNILENBQUM7SUFDakIsT0FBT0MsS0FBS0csSUFBSSxDQUFDSjtBQUNuQjtBQUNBLFNBQVNLLFNBQVNDLE1BQU0sRUFBRUMsTUFBTTtJQUM5QixPQUFPUixRQUFRTyxTQUFTQztBQUMxQjtBQUNBLFNBQVNDLFVBQVVGLE1BQU0sRUFBRUMsTUFBTTtJQUMvQixJQUFJRCxXQUFXLEtBQUtDLFdBQVcsR0FBRyxPQUFPO0lBQ3pDLElBQUlSLFFBQVFPLFdBQVdQLFFBQVFRLFNBQVMsT0FBTztJQUMvQyxNQUFNRSxPQUFPSixTQUFTTixRQUFRTyxTQUFTUCxRQUFRUTtJQUMvQyxPQUFPUixRQUFRVSxPQUFPSDtBQUN4QjtBQUNBLFNBQVNJLFVBQVVDLEtBQUs7SUFDdEIsT0FBT0MsV0FBV0QsT0FBT0UsR0FBRyxDQUFDQztBQUMvQjtBQUNBLFNBQVNDLFVBQVVKLEtBQUs7SUFDdEIsT0FBT0EsS0FBSyxDQUFDSyxlQUFlTCxPQUFPO0FBQ3JDO0FBQ0EsU0FBU0ssZUFBZUwsS0FBSztJQUMzQixPQUFP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LFNBQVNMO0lBQ2xCO0lBQ0EsU0FBUzFFO1FBQ1AsT0FBT04sT0FBT00sY0FBYztJQUM5QjtJQUNBLFNBQVNKO1FBQ1AsT0FBT0YsT0FBT0UsY0FBYyxDQUFDalksR0FBRyxDQUFDK1gsT0FBT3BXLFFBQVEsQ0FBQzNCLEdBQUc7SUFDdEQ7SUFDQSxTQUFTK2M7UUFDUCxPQUFPaEYsT0FBT3hiLEtBQUssQ0FBQ3lELEdBQUc7SUFDekI7SUFDQSxTQUFTdWQ7UUFDUCxPQUFPeEYsT0FBTzNILGFBQWEsQ0FBQ3BRLEdBQUc7SUFDakM7SUFDQSxTQUFTa1k7UUFDUCxPQUFPSCxPQUFPRyxZQUFZLENBQUNsWSxHQUFHO0lBQ2hDO0lBQ0EsU0FBU3dkO1FBQ1AsT0FBT3pGLE9BQU9HLFlBQVksQ0FBQ2xZLEdBQUcsQ0FBQztJQUNqQztJQUNBLFNBQVM0YTtRQUNQLE9BQU9nQjtJQUNUO0lBQ0EsU0FBUzZCO1FBQ1AsT0FBTzFGO0lBQ1Q7SUFDQSxTQUFTeFc7UUFDUCxPQUFPa1A7SUFDVDtJQUNBLFNBQVNpTjtRQUNQLE9BQU8xVjtJQUNUO0lBQ0EsU0FBUzJWO1FBQ1AsT0FBTzFWO0lBQ1Q7SUFDQSxNQUFNNUosT0FBTztRQUNYZ2Y7UUFDQUM7UUFDQUk7UUFDQUQ7UUFDQXhaO1FBQ0F1VjtRQUNBRjtRQUNBOVQ7UUFDQW9WO1FBQ0EyQztRQUNBcFU7UUFDQTVIO1FBQ0EyYjtRQUNBQztRQUNBbEY7UUFDQUk7UUFDQXhXO1FBQ0FrYjtRQUNBWTtRQUNBekY7UUFDQXNGO0lBQ0Y7SUFDQWpCLFNBQVN0QixhQUFhQztJQUN0QjBDLFdBQVcsSUFBTTViLGFBQWF3RCxJQUFJLENBQUMsU0FBUztJQUM1QyxPQUFPbkg7QUFDVDtBQUNBMmMsY0FBY08sZUFBZSxHQUFHLEVBQUU7QUFDbENQLGNBQWNVLGFBQWEsR0FBRzVYO0FBRU0sQ0FDcEMsOENBQThDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGF3YS1kb2NzLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9lbWJsYS1jYXJvdXNlbEA4LjAuMC1yYzE1L25vZGVfbW9kdWxlcy9lbWJsYS1jYXJvdXNlbC9lc20vZW1ibGEtY2Fyb3VzZWwuZXNtLmpzPzk3NDEiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gaXNOdW1iZXIoc3ViamVjdCkge1xuICByZXR1cm4gdHlwZW9mIHN1YmplY3QgPT09ICdudW1iZXInO1xufVxuZnVuY3Rpb24gaXNTdHJpbmcoc3ViamVjdCkge1xuICByZXR1cm4gdHlwZW9mIHN1YmplY3QgPT09ICdzdHJpbmcnO1xufVxuZnVuY3Rpb24gaXNCb29sZWFuKHN1YmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBzdWJqZWN0ID09PSAnYm9vbGVhbic7XG59XG5mdW5jdGlvbiBpc09iamVjdChzdWJqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ViamVjdCkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuZnVuY3Rpb24gbWF0aEFicyhuKSB7XG4gIHJldHVybiBNYXRoLmFicyhuKTtcbn1cbmZ1bmN0aW9uIG1hdGhTaWduKG4pIHtcbiAgcmV0dXJuIE1hdGguc2lnbihuKTtcbn1cbmZ1bmN0aW9uIGRlbHRhQWJzKHZhbHVlQiwgdmFsdWVBKSB7XG4gIHJldHVybiBtYXRoQWJzKHZhbHVlQiAtIHZhbHVlQSk7XG59XG5mdW5jdGlvbiBmYWN0b3JBYnModmFsdWVCLCB2YWx1ZUEpIHtcbiAgaWYgKHZhbHVlQiA9PT0gMCB8fCB2YWx1ZUEgPT09IDApIHJldHVybiAwO1xuICBpZiAobWF0aEFicyh2YWx1ZUIpIDw9IG1hdGhBYnModmFsdWVBKSkgcmV0dXJuIDA7XG4gIGNvbnN0IGRpZmYgPSBkZWx0YUFicyhtYXRoQWJzKHZhbHVlQiksIG1hdGhBYnModmFsdWVBKSk7XG4gIHJldHVybiBtYXRoQWJzKGRpZmYgLyB2YWx1ZUIpO1xufVxuZnVuY3Rpb24gYXJyYXlLZXlzKGFycmF5KSB7XG4gIHJldHVybiBvYmplY3RLZXlzKGFycmF5KS5tYXAoTnVtYmVyKTtcbn1cbmZ1bmN0aW9uIGFycmF5TGFzdChhcnJheSkge1xuICByZXR1cm4gYXJyYXlbYXJyYXlMYXN0SW5kZXgoYXJyYXkpXTtcbn1cbmZ1bmN0aW9uIGFycmF5TGFzdEluZGV4KGFycmF5KSB7XG4gIHJldHVybiBNYXRoLm1heCgwLCBhcnJheS5sZW5ndGggLSAxKTtcbn1cbmZ1bmN0aW9uIGFycmF5SXNMYXN0SW5kZXgoYXJyYXksIGluZGV4KSB7XG4gIHJldHVybiBpbmRleCA9PT0gYXJyYXlMYXN0SW5kZXgoYXJyYXkpO1xufVxuZnVuY3Rpb24gYXJyYXlGcm9tTnVtYmVyKG4sIHN0YXJ0QXQgPSAwKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKEFycmF5KG4pLCAoXywgaSkgPT4gc3RhcnRBdCArIGkpO1xufVxuZnVuY3Rpb24gb2JqZWN0S2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iamVjdCk7XG59XG5mdW5jdGlvbiBvYmplY3RzTWVyZ2VEZWVwKG9iamVjdEEsIG9iamVjdEIpIHtcbiAgcmV0dXJuIFtvYmplY3RBLCBvYmplY3RCXS5yZWR1Y2UoKG1lcmdlZE9iamVjdHMsIGN1cnJlbnRPYmplY3QpID0+IHtcbiAgICBvYmplY3RLZXlzKGN1cnJlbnRPYmplY3QpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlQSA9IG1lcmdlZE9iamVjdHNba2V5XTtcbiAgICAgIGNvbnN0IHZhbHVlQiA9IGN1cnJlbnRPYmplY3Rba2V5XTtcbiAgICAgIGNvbnN0IGFyZU9iamVjdHMgPSBpc09iamVjdCh2YWx1ZUEpICYmIGlzT2JqZWN0KHZhbHVlQik7XG4gICAgICBtZXJnZWRPYmplY3RzW2tleV0gPSBhcmVPYmplY3RzID8gb2JqZWN0c01lcmdlRGVlcCh2YWx1ZUEsIHZhbHVlQikgOiB2YWx1ZUI7XG4gICAgfSk7XG4gICAgcmV0dXJuIG1lcmdlZE9iamVjdHM7XG4gIH0sIHt9KTtcbn1cbmZ1bmN0aW9uIGlzTW91c2VFdmVudChldnQsIG93bmVyV2luZG93KSB7XG4gIHJldHVybiB0eXBlb2Ygb3duZXJXaW5kb3cuTW91c2VFdmVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZXZ0IGluc3RhbmNlb2Ygb3duZXJXaW5kb3cuTW91c2VFdmVudDtcbn1cblxuZnVuY3Rpb24gQWxpZ25tZW50KGFsaWduLCB2aWV3U2l6ZSkge1xuICBjb25zdCBwcmVkZWZpbmVkID0ge1xuICAgIHN0YXJ0LFxuICAgIGNlbnRlcixcbiAgICBlbmRcbiAgfTtcbiAgZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgZnVuY3Rpb24gY2VudGVyKG4pIHtcbiAgICByZXR1cm4gZW5kKG4pIC8gMjtcbiAgfVxuICBmdW5jdGlvbiBlbmQobikge1xuICAgIHJldHVybiB2aWV3U2l6ZSAtIG47XG4gIH1cbiAgZnVuY3Rpb24gbWVhc3VyZShuLCBpbmRleCkge1xuICAgIGlmIChpc1N0cmluZyhhbGlnbikpIHJldHVybiBwcmVkZWZpbmVkW2FsaWduXShuKTtcbiAgICByZXR1cm4gYWxpZ24odmlld1NpemUsIG4sIGluZGV4KTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIG1lYXN1cmVcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIEF4aXMoYXhpcywgZGlyZWN0aW9uKSB7XG4gIGNvbnN0IHNjcm9sbCA9IGF4aXMgPT09ICd5JyA/ICd5JyA6ICd4JztcbiAgY29uc3QgY3Jvc3MgPSBheGlzID09PSAneScgPyAneCcgOiAneSc7XG4gIGNvbnN0IHN0YXJ0RWRnZSA9IGdldFN0YXJ0RWRnZSgpO1xuICBjb25zdCBlbmRFZGdlID0gZ2V0RW5kRWRnZSgpO1xuICBmdW5jdGlvbiBtZWFzdXJlU2l6ZShub2RlUmVjdCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IG5vZGVSZWN0O1xuICAgIHJldHVybiBzY3JvbGwgPT09ICd4JyA/IHdpZHRoIDogaGVpZ2h0O1xuICB9XG4gIGZ1bmN0aW9uIGdldFN0YXJ0RWRnZSgpIHtcbiAgICBpZiAoc2Nyb2xsID09PSAneScpIHJldHVybiAndG9wJztcbiAgICByZXR1cm4gZGlyZWN0aW9uID09PSAncnRsJyA/ICdyaWdodCcgOiAnbGVmdCc7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0RW5kRWRnZSgpIHtcbiAgICBpZiAoc2Nyb2xsID09PSAneScpIHJldHVybiAnYm90dG9tJztcbiAgICByZXR1cm4gZGlyZWN0aW9uID09PSAncnRsJyA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBzY3JvbGwsXG4gICAgY3Jvc3MsXG4gICAgc3RhcnRFZGdlLFxuICAgIGVuZEVkZ2UsXG4gICAgbWVhc3VyZVNpemVcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIExpbWl0KG1pbiwgbWF4KSB7XG4gIGNvbnN0IGxlbmd0aCA9IG1hdGhBYnMobWluIC0gbWF4KTtcbiAgZnVuY3Rpb24gcmVhY2hlZE1pbihuKSB7XG4gICAgcmV0dXJuIG4gPCBtaW47XG4gIH1cbiAgZnVuY3Rpb24gcmVhY2hlZE1heChuKSB7XG4gICAgcmV0dXJuIG4gPiBtYXg7XG4gIH1cbiAgZnVuY3Rpb24gcmVhY2hlZEFueShuKSB7XG4gICAgcmV0dXJuIHJlYWNoZWRNaW4obikgfHwgcmVhY2hlZE1heChuKTtcbiAgfVxuICBmdW5jdGlvbiBjb25zdHJhaW4obikge1xuICAgIGlmICghcmVhY2hlZEFueShuKSkgcmV0dXJuIG47XG4gICAgcmV0dXJuIHJlYWNoZWRNaW4obikgPyBtaW4gOiBtYXg7XG4gIH1cbiAgZnVuY3Rpb24gcmVtb3ZlT2Zmc2V0KG4pIHtcbiAgICBpZiAoIWxlbmd0aCkgcmV0dXJuIG47XG4gICAgcmV0dXJuIG4gLSBsZW5ndGggKiBNYXRoLmNlaWwoKG4gLSBtYXgpIC8gbGVuZ3RoKTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGxlbmd0aCxcbiAgICBtYXgsXG4gICAgbWluLFxuICAgIGNvbnN0cmFpbixcbiAgICByZWFjaGVkQW55LFxuICAgIHJlYWNoZWRNYXgsXG4gICAgcmVhY2hlZE1pbixcbiAgICByZW1vdmVPZmZzZXRcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIENvdW50ZXIobWF4LCBzdGFydCwgbG9vcCkge1xuICBjb25zdCB7XG4gICAgY29uc3RyYWluXG4gIH0gPSBMaW1pdCgwLCBtYXgpO1xuICBjb25zdCBsb29wRW5kID0gbWF4ICsgMTtcbiAgbGV0IGNvdW50ZXIgPSB3aXRoaW5MaW1pdChzdGFydCk7XG4gIGZ1bmN0aW9uIHdpdGhpbkxpbWl0KG4pIHtcbiAgICByZXR1cm4gIWxvb3AgPyBjb25zdHJhaW4obikgOiBtYXRoQWJzKChsb29wRW5kICsgbikgJSBsb29wRW5kKTtcbiAgfVxuICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIGNvdW50ZXI7XG4gIH1cbiAgZnVuY3Rpb24gc2V0KG4pIHtcbiAgICBjb3VudGVyID0gd2l0aGluTGltaXQobik7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgZnVuY3Rpb24gYWRkKG4pIHtcbiAgICByZXR1cm4gY2xvbmUoKS5zZXQoZ2V0KCkgKyBuKTtcbiAgfVxuICBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICByZXR1cm4gQ291bnRlcihtYXgsIGdldCgpLCBsb29wKTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGdldCxcbiAgICBzZXQsXG4gICAgYWRkLFxuICAgIGNsb25lXG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBEaXJlY3Rpb24oZGlyZWN0aW9uKSB7XG4gIGNvbnN0IHNpZ24gPSBkaXJlY3Rpb24gPT09ICdydGwnID8gLTEgOiAxO1xuICBmdW5jdGlvbiBhcHBseShuKSB7XG4gICAgcmV0dXJuIG4gKiBzaWduO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgYXBwbHlcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIEV2ZW50U3RvcmUoKSB7XG4gIGxldCBsaXN0ZW5lcnMgPSBbXTtcbiAgZnVuY3Rpb24gYWRkKG5vZGUsIHR5cGUsIGhhbmRsZXIsIG9wdGlvbnMgPSB7XG4gICAgcGFzc2l2ZTogdHJ1ZVxuICB9KSB7XG4gICAgbGV0IHJlbW92ZUxpc3RlbmVyO1xuICAgIGlmICgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gbm9kZSkge1xuICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgICAgcmVtb3ZlTGlzdGVuZXIgPSAoKSA9PiBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxlZ2FjeU1lZGlhUXVlcnlMaXN0ID0gbm9kZTtcbiAgICAgIGxlZ2FjeU1lZGlhUXVlcnlMaXN0LmFkZExpc3RlbmVyKGhhbmRsZXIpO1xuICAgICAgcmVtb3ZlTGlzdGVuZXIgPSAoKSA9PiBsZWdhY3lNZWRpYVF1ZXJ5TGlzdC5yZW1vdmVMaXN0ZW5lcihoYW5kbGVyKTtcbiAgICB9XG4gICAgbGlzdGVuZXJzLnB1c2gocmVtb3ZlTGlzdGVuZXIpO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIGxpc3RlbmVycyA9IGxpc3RlbmVycy5maWx0ZXIocmVtb3ZlID0+IHJlbW92ZSgpKTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGFkZCxcbiAgICBjbGVhclxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gRHJhZ0hhbmRsZXIoYXhpcywgZGlyZWN0aW9uLCByb290Tm9kZSwgb3duZXJEb2N1bWVudCwgb3duZXJXaW5kb3csIHRhcmdldCwgZHJhZ1RyYWNrZXIsIGxvY2F0aW9uLCBhbmltYXRpb24sIHNjcm9sbFRvLCBzY3JvbGxCb2R5LCBzY3JvbGxUYXJnZXQsIGluZGV4LCBldmVudEhhbmRsZXIsIHBlcmNlbnRPZlZpZXcsIGRyYWdGcmVlLCBkcmFnVGhyZXNob2xkLCBza2lwU25hcHMsIGJhc2VGcmljdGlvbiwgd2F0Y2hEcmFnKSB7XG4gIGNvbnN0IHtcbiAgICBjcm9zczogY3Jvc3NBeGlzXG4gIH0gPSBheGlzO1xuICBjb25zdCBmb2N1c05vZGVzID0gWydJTlBVVCcsICdTRUxFQ1QnLCAnVEVYVEFSRUEnXTtcbiAgY29uc3Qgbm9uUGFzc2l2ZUV2ZW50ID0ge1xuICAgIHBhc3NpdmU6IGZhbHNlXG4gIH07XG4gIGNvbnN0IGluaXRFdmVudHMgPSBFdmVudFN0b3JlKCk7XG4gIGNvbnN0IGRyYWdFdmVudHMgPSBFdmVudFN0b3JlKCk7XG4gIGNvbnN0IGdvVG9OZXh0VGhyZXNob2xkID0gTGltaXQoNTAsIDIyNSkuY29uc3RyYWluKHBlcmNlbnRPZlZpZXcubWVhc3VyZSgyMCkpO1xuICBjb25zdCBzbmFwRm9yY2VCb29zdCA9IHtcbiAgICBtb3VzZTogMzAwLFxuICAgIHRvdWNoOiA0MDBcbiAgfTtcbiAgY29uc3QgZnJlZUZvcmNlQm9vc3QgPSB7XG4gICAgbW91c2U6IDUwMCxcbiAgICB0b3VjaDogNjAwXG4gIH07XG4gIGNvbnN0IGJhc2VTcGVlZCA9IGRyYWdGcmVlID8gNDMgOiAyNTtcbiAgbGV0IGlzTW92aW5nID0gZmFsc2U7XG4gIGxldCBzdGFydFNjcm9sbCA9IDA7XG4gIGxldCBzdGFydENyb3NzID0gMDtcbiAgbGV0IHBvaW50ZXJJc0Rvd24gPSBmYWxzZTtcbiAgbGV0IHByZXZlbnRTY3JvbGwgPSBmYWxzZTtcbiAgbGV0IHByZXZlbnRDbGljayA9IGZhbHNlO1xuICBsZXQgaXNNb3VzZSA9IGZhbHNlO1xuICBmdW5jdGlvbiBpbml0KGVtYmxhQXBpKSB7XG4gICAgaWYgKCF3YXRjaERyYWcpIHJldHVybjtcbiAgICBmdW5jdGlvbiBkb3duSWZBbGxvd2VkKGV2dCkge1xuICAgICAgaWYgKGlzQm9vbGVhbih3YXRjaERyYWcpIHx8IHdhdGNoRHJhZyhlbWJsYUFwaSwgZXZ0KSkgZG93bihldnQpO1xuICAgIH1cbiAgICBjb25zdCBub2RlID0gcm9vdE5vZGU7XG4gICAgaW5pdEV2ZW50cy5hZGQobm9kZSwgJ2RyYWdzdGFydCcsIGV2dCA9PiBldnQucHJldmVudERlZmF1bHQoKSwgbm9uUGFzc2l2ZUV2ZW50KS5hZGQobm9kZSwgJ3RvdWNobW92ZScsICgpID0+IHVuZGVmaW5lZCwgbm9uUGFzc2l2ZUV2ZW50KS5hZGQobm9kZSwgJ3RvdWNoZW5kJywgKCkgPT4gdW5kZWZpbmVkKS5hZGQobm9kZSwgJ3RvdWNoc3RhcnQnLCBkb3duSWZBbGxvd2VkKS5hZGQobm9kZSwgJ21vdXNlZG93bicsIGRvd25JZkFsbG93ZWQpLmFkZChub2RlLCAndG91Y2hjYW5jZWwnLCB1cCkuYWRkKG5vZGUsICdjb250ZXh0bWVudScsIHVwKS5hZGQobm9kZSwgJ2NsaWNrJywgY2xpY2ssIHRydWUpO1xuICB9XG4gIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgaW5pdEV2ZW50cy5jbGVhcigpO1xuICAgIGRyYWdFdmVudHMuY2xlYXIoKTtcbiAgfVxuICBmdW5jdGlvbiBhZGREcmFnRXZlbnRzKCkge1xuICAgIGNvbnN0IG5vZGUgPSBpc01vdXNlID8gb3duZXJEb2N1bWVudCA6IHJvb3ROb2RlO1xuICAgIGRyYWdFdmVudHMuYWRkKG5vZGUsICd0b3VjaG1vdmUnLCBtb3ZlLCBub25QYXNzaXZlRXZlbnQpLmFkZChub2RlLCAndG91Y2hlbmQnLCB1cCkuYWRkKG5vZGUsICdtb3VzZW1vdmUnLCBtb3ZlLCBub25QYXNzaXZlRXZlbnQpLmFkZChub2RlLCAnbW91c2V1cCcsIHVwKTtcbiAgfVxuICBmdW5jdGlvbiBpc0ZvY3VzTm9kZShub2RlKSB7XG4gICAgY29uc3Qgbm9kZU5hbWUgPSBub2RlLm5vZGVOYW1lIHx8ICcnO1xuICAgIHJldHVybiBmb2N1c05vZGVzLmluY2x1ZGVzKG5vZGVOYW1lKTtcbiAgfVxuICBmdW5jdGlvbiBmb3JjZUJvb3N0KCkge1xuICAgIGNvbnN0IGJvb3N0ID0gZHJhZ0ZyZWUgPyBmcmVlRm9yY2VCb29zdCA6IHNuYXBGb3JjZUJvb3N0O1xuICAgIGNvbnN0IHR5cGUgPSBpc01vdXNlID8gJ21vdXNlJyA6ICd0b3VjaCc7XG4gICAgcmV0dXJuIGJvb3N0W3R5cGVdO1xuICB9XG4gIGZ1bmN0aW9uIGFsbG93ZWRGb3JjZShmb3JjZSwgdGFyZ2V0Q2hhbmdlZCkge1xuICAgIGNvbnN0IG5leHQgPSBpbmRleC5hZGQobWF0aFNpZ24oZm9yY2UpICogLTEpO1xuICAgIGNvbnN0IGJhc2VGb3JjZSA9IHNjcm9sbFRhcmdldC5ieURpc3RhbmNlKGZvcmNlLCAhZHJhZ0ZyZWUpLmRpc3RhbmNlO1xuICAgIGlmIChkcmFnRnJlZSB8fCBtYXRoQWJzKGZvcmNlKSA8IGdvVG9OZXh0VGhyZXNob2xkKSByZXR1cm4gYmFzZUZvcmNlO1xuICAgIGlmIChza2lwU25hcHMgJiYgdGFyZ2V0Q2hhbmdlZCkgcmV0dXJuIGJhc2VGb3JjZSAqIDAuNTtcbiAgICByZXR1cm4gc2Nyb2xsVGFyZ2V0LmJ5SW5kZXgobmV4dC5nZXQoKSwgMCkuZGlzdGFuY2U7XG4gIH1cbiAgZnVuY3Rpb24gZG93bihldnQpIHtcbiAgICBjb25zdCBpc01vdXNlRXZ0ID0gaXNNb3VzZUV2ZW50KGV2dCwgb3duZXJXaW5kb3cpO1xuICAgIGlzTW91c2UgPSBpc01vdXNlRXZ0O1xuICAgIGlmIChpc01vdXNlRXZ0ICYmIGV2dC5idXR0b24gIT09IDApIHJldHVybjtcbiAgICBpZiAoaXNGb2N1c05vZGUoZXZ0LnRhcmdldCkpIHJldHVybjtcbiAgICBwcmV2ZW50Q2xpY2sgPSBkcmFnRnJlZSAmJiBpc01vdXNlRXZ0ICYmICFldnQuYnV0dG9ucyAmJiBpc01vdmluZztcbiAgICBpc01vdmluZyA9IGRlbHRhQWJzKHRhcmdldC5nZXQoKSwgbG9jYXRpb24uZ2V0KCkpID49IDI7XG4gICAgcG9pbnRlcklzRG93biA9IHRydWU7XG4gICAgZHJhZ1RyYWNrZXIucG9pbnRlckRvd24oZXZ0KTtcbiAgICBzY3JvbGxCb2R5LnVzZUZyaWN0aW9uKDApLnVzZUR1cmF0aW9uKDApO1xuICAgIHRhcmdldC5zZXQobG9jYXRpb24pO1xuICAgIGFkZERyYWdFdmVudHMoKTtcbiAgICBzdGFydFNjcm9sbCA9IGRyYWdUcmFja2VyLnJlYWRQb2ludChldnQpO1xuICAgIHN0YXJ0Q3Jvc3MgPSBkcmFnVHJhY2tlci5yZWFkUG9pbnQoZXZ0LCBjcm9zc0F4aXMpO1xuICAgIGV2ZW50SGFuZGxlci5lbWl0KCdwb2ludGVyRG93bicpO1xuICB9XG4gIGZ1bmN0aW9uIG1vdmUoZXZ0KSB7XG4gICAgY29uc3QgbGFzdFNjcm9sbCA9IGRyYWdUcmFja2VyLnJlYWRQb2ludChldnQpO1xuICAgIGNvbnN0IGxhc3RDcm9zcyA9IGRyYWdUcmFja2VyLnJlYWRQb2ludChldnQsIGNyb3NzQXhpcyk7XG4gICAgY29uc3QgZGlmZlNjcm9sbCA9IGRlbHRhQWJzKGxhc3RTY3JvbGwsIHN0YXJ0U2Nyb2xsKTtcbiAgICBjb25zdCBkaWZmQ3Jvc3MgPSBkZWx0YUFicyhsYXN0Q3Jvc3MsIHN0YXJ0Q3Jvc3MpO1xuICAgIGlmICghcHJldmVudFNjcm9sbCAmJiAhaXNNb3VzZSkge1xuICAgICAgaWYgKCFldnQuY2FuY2VsYWJsZSkgcmV0dXJuIHVwKGV2dCk7XG4gICAgICBwcmV2ZW50U2Nyb2xsID0gZGlmZlNjcm9sbCA+IGRpZmZDcm9zcztcbiAgICAgIGlmICghcHJldmVudFNjcm9sbCkgcmV0dXJuIHVwKGV2dCk7XG4gICAgfVxuICAgIGNvbnN0IGRpZmYgPSBkcmFnVHJhY2tlci5wb2ludGVyTW92ZShldnQpO1xuICAgIGlmIChkaWZmU2Nyb2xsID4gZHJhZ1RocmVzaG9sZCkgcHJldmVudENsaWNrID0gdHJ1ZTtcbiAgICBzY3JvbGxCb2R5LnVzZUZyaWN0aW9uKDAuMykudXNlRHVyYXRpb24oMSk7XG4gICAgYW5pbWF0aW9uLnN0YXJ0KCk7XG4gICAgdGFyZ2V0LmFkZChkaXJlY3Rpb24uYXBwbHkoZGlmZikpO1xuICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG4gIGZ1bmN0aW9uIHVwKGV2dCkge1xuICAgIGNvbnN0IGN1cnJlbnRMb2NhdGlvbiA9IHNjcm9sbFRhcmdldC5ieURpc3RhbmNlKDAsIGZhbHNlKTtcbiAgICBjb25zdCB0YXJnZXRDaGFuZ2VkID0gY3VycmVudExvY2F0aW9uLmluZGV4ICE9PSBpbmRleC5nZXQoKTtcbiAgICBjb25zdCByYXdGb3JjZSA9IGRyYWdUcmFja2VyLnBvaW50ZXJVcChldnQpICogZm9yY2VCb29zdCgpO1xuICAgIGNvbnN0IGZvcmNlID0gYWxsb3dlZEZvcmNlKGRpcmVjdGlvbi5hcHBseShyYXdGb3JjZSksIHRhcmdldENoYW5nZWQpO1xuICAgIGNvbnN0IGZvcmNlRmFjdG9yID0gZmFjdG9yQWJzKHJhd0ZvcmNlLCBmb3JjZSk7XG4gICAgY29uc3Qgc3BlZWQgPSBiYXNlU3BlZWQgLSAxMCAqIGZvcmNlRmFjdG9yO1xuICAgIGNvbnN0IGZyaWN0aW9uID0gYmFzZUZyaWN0aW9uICsgZm9yY2VGYWN0b3IgLyA1MDtcbiAgICBwcmV2ZW50U2Nyb2xsID0gZmFsc2U7XG4gICAgcG9pbnRlcklzRG93biA9IGZhbHNlO1xuICAgIGRyYWdFdmVudHMuY2xlYXIoKTtcbiAgICBzY3JvbGxCb2R5LnVzZUR1cmF0aW9uKHNwZWVkKS51c2VGcmljdGlvbihmcmljdGlvbik7XG4gICAgc2Nyb2xsVG8uZGlzdGFuY2UoZm9yY2UsICFkcmFnRnJlZSk7XG4gICAgaXNNb3VzZSA9IGZhbHNlO1xuICAgIGV2ZW50SGFuZGxlci5lbWl0KCdwb2ludGVyVXAnKTtcbiAgfVxuICBmdW5jdGlvbiBjbGljayhldnQpIHtcbiAgICBpZiAocHJldmVudENsaWNrKSB7XG4gICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcG9pbnRlckRvd24oKSB7XG4gICAgcmV0dXJuIHBvaW50ZXJJc0Rvd247XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBpbml0LFxuICAgIHBvaW50ZXJEb3duLFxuICAgIGRlc3Ryb3lcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIERyYWdUcmFja2VyKGF4aXMsIG93bmVyV2luZG93KSB7XG4gIGNvbnN0IGxvZ0ludGVydmFsID0gMTcwO1xuICBsZXQgc3RhcnRFdmVudDtcbiAgbGV0IGxhc3RFdmVudDtcbiAgZnVuY3Rpb24gcmVhZFRpbWUoZXZ0KSB7XG4gICAgcmV0dXJuIGV2dC50aW1lU3RhbXA7XG4gIH1cbiAgZnVuY3Rpb24gcmVhZFBvaW50KGV2dCwgZXZ0QXhpcykge1xuICAgIGNvbnN0IHByb3BlcnR5ID0gZXZ0QXhpcyB8fCBheGlzLnNjcm9sbDtcbiAgICBjb25zdCBjb29yZCA9IGBjbGllbnQke3Byb3BlcnR5ID09PSAneCcgPyAnWCcgOiAnWSd9YDtcbiAgICByZXR1cm4gKGlzTW91c2VFdmVudChldnQsIG93bmVyV2luZG93KSA/IGV2dCA6IGV2dC50b3VjaGVzWzBdKVtjb29yZF07XG4gIH1cbiAgZnVuY3Rpb24gcG9pbnRlckRvd24oZXZ0KSB7XG4gICAgc3RhcnRFdmVudCA9IGV2dDtcbiAgICBsYXN0RXZlbnQgPSBldnQ7XG4gICAgcmV0dXJuIHJlYWRQb2ludChldnQpO1xuICB9XG4gIGZ1bmN0aW9uIHBvaW50ZXJNb3ZlKGV2dCkge1xuICAgIGNvbnN0IGRpZmYgPSByZWFkUG9pbnQoZXZ0KSAtIHJlYWRQb2ludChsYXN0RXZlbnQpO1xuICAgIGNvbnN0IGV4cGlyZWQgPSByZWFkVGltZShldnQpIC0gcmVhZFRpbWUoc3RhcnRFdmVudCkgPiBsb2dJbnRlcnZhbDtcbiAgICBsYXN0RXZlbnQgPSBldnQ7XG4gICAgaWYgKGV4cGlyZWQpIHN0YXJ0RXZlbnQgPSBldnQ7XG4gICAgcmV0dXJuIGRpZmY7XG4gIH1cbiAgZnVuY3Rpb24gcG9pbnRlclVwKGV2dCkge1xuICAgIGlmICghc3RhcnRFdmVudCB8fCAhbGFzdEV2ZW50KSByZXR1cm4gMDtcbiAgICBjb25zdCBkaWZmRHJhZyA9IHJlYWRQb2ludChsYXN0RXZlbnQpIC0gcmVhZFBvaW50KHN0YXJ0RXZlbnQpO1xuICAgIGNvbnN0IGRpZmZUaW1lID0gcmVhZFRpbWUoZXZ0KSAtIHJlYWRUaW1lKHN0YXJ0RXZlbnQpO1xuICAgIGNvbnN0IGV4cGlyZWQgPSByZWFkVGltZShldnQpIC0gcmVhZFRpbWUobGFzdEV2ZW50KSA+IGxvZ0ludGVydmFsO1xuICAgIGNvbnN0IGZvcmNlID0gZGlmZkRyYWcgLyBkaWZmVGltZTtcbiAgICBjb25zdCBpc0ZsaWNrID0gZGlmZlRpbWUgJiYgIWV4cGlyZWQgJiYgbWF0aEFicyhmb3JjZSkgPiAwLjE7XG4gICAgcmV0dXJuIGlzRmxpY2sgPyBmb3JjZSA6IDA7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBwb2ludGVyRG93bixcbiAgICBwb2ludGVyTW92ZSxcbiAgICBwb2ludGVyVXAsXG4gICAgcmVhZFBvaW50XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBOb2RlUmVjdHMoKSB7XG4gIGZ1bmN0aW9uIG1lYXN1cmUobm9kZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIG9mZnNldFRvcCxcbiAgICAgIG9mZnNldExlZnQsXG4gICAgICBvZmZzZXRXaWR0aCxcbiAgICAgIG9mZnNldEhlaWdodFxuICAgIH0gPSBub2RlO1xuICAgIGNvbnN0IG9mZnNldCA9IHtcbiAgICAgIHRvcDogb2Zmc2V0VG9wLFxuICAgICAgcmlnaHQ6IG9mZnNldExlZnQgKyBvZmZzZXRXaWR0aCxcbiAgICAgIGJvdHRvbTogb2Zmc2V0VG9wICsgb2Zmc2V0SGVpZ2h0LFxuICAgICAgbGVmdDogb2Zmc2V0TGVmdCxcbiAgICAgIHdpZHRoOiBvZmZzZXRXaWR0aCxcbiAgICAgIGhlaWdodDogb2Zmc2V0SGVpZ2h0XG4gICAgfTtcbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgbWVhc3VyZVxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gUGVyY2VudE9mVmlldyh2aWV3U2l6ZSkge1xuICBmdW5jdGlvbiBtZWFzdXJlKG4pIHtcbiAgICByZXR1cm4gdmlld1NpemUgKiAobiAvIDEwMCk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBtZWFzdXJlXG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBSZXNpemVIYW5kbGVyKGNvbnRhaW5lciwgZXZlbnRIYW5kbGVyLCBvd25lcldpbmRvdywgc2xpZGVzLCBheGlzLCB3YXRjaFJlc2l6ZSwgbm9kZVJlY3RzKSB7XG4gIGxldCByZXNpemVPYnNlcnZlcjtcbiAgbGV0IGNvbnRhaW5lclNpemU7XG4gIGxldCBzbGlkZVNpemVzID0gW107XG4gIGxldCBkZXN0cm95ZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gcmVhZFNpemUobm9kZSkge1xuICAgIHJldHVybiBheGlzLm1lYXN1cmVTaXplKG5vZGVSZWN0cy5tZWFzdXJlKG5vZGUpKTtcbiAgfVxuICBmdW5jdGlvbiBpbml0KGVtYmxhQXBpKSB7XG4gICAgaWYgKCF3YXRjaFJlc2l6ZSkgcmV0dXJuO1xuICAgIGNvbnRhaW5lclNpemUgPSByZWFkU2l6ZShjb250YWluZXIpO1xuICAgIHNsaWRlU2l6ZXMgPSBzbGlkZXMubWFwKHJlYWRTaXplKTtcbiAgICBmdW5jdGlvbiBkZWZhdWx0Q2FsbGJhY2soZW50cmllcykge1xuICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICAgIGNvbnN0IGlzQ29udGFpbmVyID0gZW50cnkudGFyZ2V0ID09PSBjb250YWluZXI7XG4gICAgICAgIGNvbnN0IHNsaWRlSW5kZXggPSBzbGlkZXMuaW5kZXhPZihlbnRyeS50YXJnZXQpO1xuICAgICAgICBjb25zdCBsYXN0U2l6ZSA9IGlzQ29udGFpbmVyID8gY29udGFpbmVyU2l6ZSA6IHNsaWRlU2l6ZXNbc2xpZGVJbmRleF07XG4gICAgICAgIGNvbnN0IG5ld1NpemUgPSByZWFkU2l6ZShpc0NvbnRhaW5lciA/IGNvbnRhaW5lciA6IHNsaWRlc1tzbGlkZUluZGV4XSk7XG4gICAgICAgIGNvbnN0IGRpZmZTaXplID0gbWF0aEFicyhuZXdTaXplIC0gbGFzdFNpemUpO1xuICAgICAgICBpZiAoZGlmZlNpemUgPj0gMC41KSB7XG4gICAgICAgICAgb3duZXJXaW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIGVtYmxhQXBpLnJlSW5pdCgpO1xuICAgICAgICAgICAgZXZlbnRIYW5kbGVyLmVtaXQoJ3Jlc2l6ZScpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgICAgaWYgKGRlc3Ryb3llZCkgcmV0dXJuO1xuICAgICAgaWYgKGlzQm9vbGVhbih3YXRjaFJlc2l6ZSkgfHwgd2F0Y2hSZXNpemUoZW1ibGFBcGksIGVudHJpZXMpKSB7XG4gICAgICAgIGRlZmF1bHRDYWxsYmFjayhlbnRyaWVzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBvYnNlcnZlTm9kZXMgPSBbY29udGFpbmVyXS5jb25jYXQoc2xpZGVzKTtcbiAgICBvYnNlcnZlTm9kZXMuZm9yRWFjaChub2RlID0+IHJlc2l6ZU9ic2VydmVyLm9ic2VydmUobm9kZSkpO1xuICB9XG4gIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgaWYgKHJlc2l6ZU9ic2VydmVyKSByZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGluaXQsXG4gICAgZGVzdHJveVxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gU2Nyb2xsQm9keShsb2NhdGlvbiwgb2Zmc2V0TG9jYXRpb24sIHRhcmdldCwgYmFzZUR1cmF0aW9uLCBiYXNlRnJpY3Rpb24pIHtcbiAgbGV0IGJvZHlWZWxvY2l0eSA9IDA7XG4gIGxldCBzY3JvbGxEaXJlY3Rpb24gPSAwO1xuICBsZXQgc2Nyb2xsRHVyYXRpb24gPSBiYXNlRHVyYXRpb247XG4gIGxldCBzY3JvbGxGcmljdGlvbiA9IGJhc2VGcmljdGlvbjtcbiAgbGV0IHJhd0xvY2F0aW9uID0gbG9jYXRpb24uZ2V0KCk7XG4gIGxldCByYXdMb2NhdGlvblByZXZpb3VzID0gMDtcbiAgZnVuY3Rpb24gc2VlaygpIHtcbiAgICBjb25zdCBkaWZmID0gdGFyZ2V0LmdldCgpIC0gbG9jYXRpb24uZ2V0KCk7XG4gICAgY29uc3QgaXNJbnN0YW50ID0gIXNjcm9sbER1cmF0aW9uO1xuICAgIGxldCBkaXJlY3Rpb25EaWZmID0gMDtcbiAgICBpZiAoaXNJbnN0YW50KSB7XG4gICAgICBib2R5VmVsb2NpdHkgPSAwO1xuICAgICAgbG9jYXRpb24uc2V0KHRhcmdldCk7XG4gICAgICBkaXJlY3Rpb25EaWZmID0gZGlmZjtcbiAgICB9IGVsc2Uge1xuICAgICAgYm9keVZlbG9jaXR5ICs9IGRpZmYgLyBzY3JvbGxEdXJhdGlvbjtcbiAgICAgIGJvZHlWZWxvY2l0eSAqPSBzY3JvbGxGcmljdGlvbjtcbiAgICAgIHJhd0xvY2F0aW9uICs9IGJvZHlWZWxvY2l0eTtcbiAgICAgIGxvY2F0aW9uLmFkZChib2R5VmVsb2NpdHkpO1xuICAgICAgZGlyZWN0aW9uRGlmZiA9IHJhd0xvY2F0aW9uIC0gcmF3TG9jYXRpb25QcmV2aW91cztcbiAgICB9XG4gICAgc2Nyb2xsRGlyZWN0aW9uID0gbWF0aFNpZ24oZGlyZWN0aW9uRGlmZik7XG4gICAgcmF3TG9jYXRpb25QcmV2aW91cyA9IHJhd0xvY2F0aW9uO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIGZ1bmN0aW9uIHNldHRsZWQoKSB7XG4gICAgY29uc3QgZGlmZiA9IHRhcmdldC5nZXQoKSAtIG9mZnNldExvY2F0aW9uLmdldCgpO1xuICAgIHJldHVybiBtYXRoQWJzKGRpZmYpIDwgMC4wMDE7XG4gIH1cbiAgZnVuY3Rpb24gZHVyYXRpb24oKSB7XG4gICAgcmV0dXJuIHNjcm9sbER1cmF0aW9uO1xuICB9XG4gIGZ1bmN0aW9uIGRpcmVjdGlvbigpIHtcbiAgICByZXR1cm4gc2Nyb2xsRGlyZWN0aW9uO1xuICB9XG4gIGZ1bmN0aW9uIHZlbG9jaXR5KCkge1xuICAgIHJldHVybiBib2R5VmVsb2NpdHk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlQmFzZUR1cmF0aW9uKCkge1xuICAgIHJldHVybiB1c2VEdXJhdGlvbihiYXNlRHVyYXRpb24pO1xuICB9XG4gIGZ1bmN0aW9uIHVzZUJhc2VGcmljdGlvbigpIHtcbiAgICByZXR1cm4gdXNlRnJpY3Rpb24oYmFzZUZyaWN0aW9uKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VEdXJhdGlvbihuKSB7XG4gICAgc2Nyb2xsRHVyYXRpb24gPSBuO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIGZ1bmN0aW9uIHVzZUZyaWN0aW9uKG4pIHtcbiAgICBzY3JvbGxGcmljdGlvbiA9IG47XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBkaXJlY3Rpb24sXG4gICAgZHVyYXRpb24sXG4gICAgdmVsb2NpdHksXG4gICAgc2VlayxcbiAgICBzZXR0bGVkLFxuICAgIHVzZUJhc2VGcmljdGlvbixcbiAgICB1c2VCYXNlRHVyYXRpb24sXG4gICAgdXNlRnJpY3Rpb24sXG4gICAgdXNlRHVyYXRpb25cbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIFNjcm9sbEJvdW5kcyhsaW1pdCwgbG9jYXRpb24sIHRhcmdldCwgc2Nyb2xsQm9keSwgcGVyY2VudE9mVmlldykge1xuICBjb25zdCBwdWxsQmFja1RocmVzaG9sZCA9IHBlcmNlbnRPZlZpZXcubWVhc3VyZSgxMCk7XG4gIGNvbnN0IGVkZ2VPZmZzZXRUb2xlcmFuY2UgPSBwZXJjZW50T2ZWaWV3Lm1lYXN1cmUoNTApO1xuICBjb25zdCBmcmljdGlvbkxpbWl0ID0gTGltaXQoMC4xLCAwLjk5KTtcbiAgbGV0IGRpc2FibGVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIHNob3VsZENvbnN0cmFpbigpIHtcbiAgICBpZiAoZGlzYWJsZWQpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIWxpbWl0LnJlYWNoZWRBbnkodGFyZ2V0LmdldCgpKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghbGltaXQucmVhY2hlZEFueShsb2NhdGlvbi5nZXQoKSkpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmdW5jdGlvbiBjb25zdHJhaW4ocG9pbnRlckRvd24pIHtcbiAgICBpZiAoIXNob3VsZENvbnN0cmFpbigpKSByZXR1cm47XG4gICAgY29uc3QgZWRnZSA9IGxpbWl0LnJlYWNoZWRNaW4obG9jYXRpb24uZ2V0KCkpID8gJ21pbicgOiAnbWF4JztcbiAgICBjb25zdCBkaWZmVG9FZGdlID0gbWF0aEFicyhsaW1pdFtlZGdlXSAtIGxvY2F0aW9uLmdldCgpKTtcbiAgICBjb25zdCBkaWZmVG9UYXJnZXQgPSB0YXJnZXQuZ2V0KCkgLSBsb2NhdGlvbi5nZXQoKTtcbiAgICBjb25zdCBmcmljdGlvbiA9IGZyaWN0aW9uTGltaXQuY29uc3RyYWluKGRpZmZUb0VkZ2UgLyBlZGdlT2Zmc2V0VG9sZXJhbmNlKTtcbiAgICB0YXJnZXQuc3VidHJhY3QoZGlmZlRvVGFyZ2V0ICogZnJpY3Rpb24pO1xuICAgIGlmICghcG9pbnRlckRvd24gJiYgbWF0aEFicyhkaWZmVG9UYXJnZXQpIDwgcHVsbEJhY2tUaHJlc2hvbGQpIHtcbiAgICAgIHRhcmdldC5zZXQobGltaXQuY29uc3RyYWluKHRhcmdldC5nZXQoKSkpO1xuICAgICAgc2Nyb2xsQm9keS51c2VEdXJhdGlvbigyNSkudXNlQmFzZUZyaWN0aW9uKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHRvZ2dsZUFjdGl2ZShhY3RpdmUpIHtcbiAgICBkaXNhYmxlZCA9ICFhY3RpdmU7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBjb25zdHJhaW4sXG4gICAgdG9nZ2xlQWN0aXZlXG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBTY3JvbGxDb250YWluKHZpZXdTaXplLCBjb250ZW50U2l6ZSwgc25hcHNBbGlnbmVkLCBjb250YWluU2Nyb2xsKSB7XG4gIGNvbnN0IHNjcm9sbEJvdW5kcyA9IExpbWl0KC1jb250ZW50U2l6ZSArIHZpZXdTaXplLCAwKTtcbiAgY29uc3Qgc25hcHNCb3VuZGVkID0gbWVhc3VyZUJvdW5kZWQoKTtcbiAgY29uc3Qgc2Nyb2xsQ29udGFpbkxpbWl0ID0gZmluZFNjcm9sbENvbnRhaW5MaW1pdCgpO1xuICBjb25zdCBzbmFwc0NvbnRhaW5lZCA9IG1lYXN1cmVDb250YWluZWQoKTtcbiAgZnVuY3Rpb24gZmluZFNjcm9sbENvbnRhaW5MaW1pdCgpIHtcbiAgICBjb25zdCBzdGFydFNuYXAgPSBzbmFwc0JvdW5kZWRbMF07XG4gICAgY29uc3QgZW5kU25hcCA9IGFycmF5TGFzdChzbmFwc0JvdW5kZWQpO1xuICAgIGNvbnN0IG1pbiA9IHNuYXBzQm91bmRlZC5sYXN0SW5kZXhPZihzdGFydFNuYXApO1xuICAgIGNvbnN0IG1heCA9IHNuYXBzQm91bmRlZC5pbmRleE9mKGVuZFNuYXApICsgMTtcbiAgICByZXR1cm4gTGltaXQobWluLCBtYXgpO1xuICB9XG4gIGZ1bmN0aW9uIG1lYXN1cmVCb3VuZGVkKCkge1xuICAgIHJldHVybiBzbmFwc0FsaWduZWQubWFwKChzbmFwQWxpZ25lZCwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGlzRmlyc3QgPSAhaW5kZXg7XG4gICAgICBjb25zdCBpc0xhc3QgPSBhcnJheUlzTGFzdEluZGV4KHNuYXBzQWxpZ25lZCwgaW5kZXgpO1xuICAgICAgaWYgKGlzRmlyc3QpIHJldHVybiBzY3JvbGxCb3VuZHMubWF4O1xuICAgICAgaWYgKGlzTGFzdCkgcmV0dXJuIHNjcm9sbEJvdW5kcy5taW47XG4gICAgICByZXR1cm4gc2Nyb2xsQm91bmRzLmNvbnN0cmFpbihzbmFwQWxpZ25lZCk7XG4gICAgfSkubWFwKHNjcm9sbEJvdW5kID0+IHBhcnNlRmxvYXQoc2Nyb2xsQm91bmQudG9GaXhlZCgzKSkpO1xuICB9XG4gIGZ1bmN0aW9uIG1lYXN1cmVDb250YWluZWQoKSB7XG4gICAgaWYgKGNvbnRlbnRTaXplIDw9IHZpZXdTaXplKSByZXR1cm4gW3Njcm9sbEJvdW5kcy5tYXhdO1xuICAgIGlmIChjb250YWluU2Nyb2xsID09PSAna2VlcFNuYXBzJykgcmV0dXJuIHNuYXBzQm91bmRlZDtcbiAgICBjb25zdCB7XG4gICAgICBtaW4sXG4gICAgICBtYXhcbiAgICB9ID0gc2Nyb2xsQ29udGFpbkxpbWl0O1xuICAgIHJldHVybiBzbmFwc0JvdW5kZWQuc2xpY2UobWluLCBtYXgpO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgc25hcHNDb250YWluZWQsXG4gICAgc2Nyb2xsQ29udGFpbkxpbWl0XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBTY3JvbGxMaW1pdChjb250ZW50U2l6ZSwgc2Nyb2xsU25hcHMsIGxvb3ApIHtcbiAgY29uc3QgbWF4ID0gc2Nyb2xsU25hcHNbMF07XG4gIGNvbnN0IG1pbiA9IGxvb3AgPyBtYXggLSBjb250ZW50U2l6ZSA6IGFycmF5TGFzdChzY3JvbGxTbmFwcyk7XG4gIGNvbnN0IGxpbWl0ID0gTGltaXQobWluLCBtYXgpO1xuICBjb25zdCBzZWxmID0ge1xuICAgIGxpbWl0XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBTY3JvbGxMb29wZXIoY29udGVudFNpemUsIGxpbWl0LCBvZmZzZXRMb2NhdGlvbiwgdmVjdG9ycykge1xuICBjb25zdCBqb2ludFNhZmV0eSA9IDAuMTtcbiAgY29uc3QgbWluID0gbGltaXQubWluICsgam9pbnRTYWZldHk7XG4gIGNvbnN0IG1heCA9IGxpbWl0Lm1heCArIGpvaW50U2FmZXR5O1xuICBjb25zdCB7XG4gICAgcmVhY2hlZE1pbixcbiAgICByZWFjaGVkTWF4XG4gIH0gPSBMaW1pdChtaW4sIG1heCk7XG4gIGZ1bmN0aW9uIHNob3VsZExvb3AoZGlyZWN0aW9uKSB7XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gMSkgcmV0dXJuIHJlYWNoZWRNYXgob2Zmc2V0TG9jYXRpb24uZ2V0KCkpO1xuICAgIGlmIChkaXJlY3Rpb24gPT09IC0xKSByZXR1cm4gcmVhY2hlZE1pbihvZmZzZXRMb2NhdGlvbi5nZXQoKSk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZ1bmN0aW9uIGxvb3AoZGlyZWN0aW9uKSB7XG4gICAgaWYgKCFzaG91bGRMb29wKGRpcmVjdGlvbikpIHJldHVybjtcbiAgICBjb25zdCBsb29wRGlzdGFuY2UgPSBjb250ZW50U2l6ZSAqIChkaXJlY3Rpb24gKiAtMSk7XG4gICAgdmVjdG9ycy5mb3JFYWNoKHYgPT4gdi5hZGQobG9vcERpc3RhbmNlKSk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBsb29wXG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBTY3JvbGxQcm9ncmVzcyhsaW1pdCkge1xuICBjb25zdCB7XG4gICAgbWF4LFxuICAgIGxlbmd0aFxuICB9ID0gbGltaXQ7XG4gIGZ1bmN0aW9uIGdldChuKSB7XG4gICAgY29uc3QgY3VycmVudExvY2F0aW9uID0gbiAtIG1heDtcbiAgICByZXR1cm4gbGVuZ3RoID8gY3VycmVudExvY2F0aW9uIC8gLWxlbmd0aCA6IDA7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBnZXRcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIFNjcm9sbFNuYXBzKGF4aXMsIGFsaWdubWVudCwgY29udGFpbmVyUmVjdCwgc2xpZGVSZWN0cywgc2xpZGVzVG9TY3JvbGwpIHtcbiAgY29uc3Qge1xuICAgIHN0YXJ0RWRnZSxcbiAgICBlbmRFZGdlXG4gIH0gPSBheGlzO1xuICBjb25zdCB7XG4gICAgZ3JvdXBTbGlkZXNcbiAgfSA9IHNsaWRlc1RvU2Nyb2xsO1xuICBjb25zdCBhbGlnbm1lbnRzID0gbWVhc3VyZVNpemVzKCkubWFwKGFsaWdubWVudC5tZWFzdXJlKTtcbiAgY29uc3Qgc25hcHMgPSBtZWFzdXJlVW5hbGlnbmVkKCk7XG4gIGNvbnN0IHNuYXBzQWxpZ25lZCA9IG1lYXN1cmVBbGlnbmVkKCk7XG4gIGZ1bmN0aW9uIG1lYXN1cmVTaXplcygpIHtcbiAgICByZXR1cm4gZ3JvdXBTbGlkZXMoc2xpZGVSZWN0cykubWFwKHJlY3RzID0+IGFycmF5TGFzdChyZWN0cylbZW5kRWRnZV0gLSByZWN0c1swXVtzdGFydEVkZ2VdKS5tYXAobWF0aEFicyk7XG4gIH1cbiAgZnVuY3Rpb24gbWVhc3VyZVVuYWxpZ25lZCgpIHtcbiAgICByZXR1cm4gc2xpZGVSZWN0cy5tYXAocmVjdCA9PiBjb250YWluZXJSZWN0W3N0YXJ0RWRnZV0gLSByZWN0W3N0YXJ0RWRnZV0pLm1hcChzbmFwID0+IC1tYXRoQWJzKHNuYXApKTtcbiAgfVxuICBmdW5jdGlvbiBtZWFzdXJlQWxpZ25lZCgpIHtcbiAgICByZXR1cm4gZ3JvdXBTbGlkZXMoc25hcHMpLm1hcChnID0+IGdbMF0pLm1hcCgoc25hcCwgaW5kZXgpID0+IHNuYXAgKyBhbGlnbm1lbnRzW2luZGV4XSk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBzbmFwcyxcbiAgICBzbmFwc0FsaWduZWRcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIFNsaWRlUmVnaXN0cnkodmlld1NpemUsIGNvbnRlbnRTaXplLCBjb250YWluU25hcHMsIGNvbnRhaW5TY3JvbGwsIHNjcm9sbENvbnRhaW5MaW1pdCwgc2xpZGVzVG9TY3JvbGwsIHNsaWRlSW5kZXhlcykge1xuICBjb25zdCB7XG4gICAgZ3JvdXBTbGlkZXNcbiAgfSA9IHNsaWRlc1RvU2Nyb2xsO1xuICBjb25zdCB7XG4gICAgbWluLFxuICAgIG1heFxuICB9ID0gc2Nyb2xsQ29udGFpbkxpbWl0O1xuICBjb25zdCBzbGlkZVJlZ2lzdHJ5ID0gY3JlYXRlU2xpZGVSZWdpc3RyeSgpO1xuICBmdW5jdGlvbiBjcmVhdGVTbGlkZVJlZ2lzdHJ5KCkge1xuICAgIGNvbnN0IGdyb3VwZWRTbGlkZUluZGV4ZXMgPSBncm91cFNsaWRlcyhzbGlkZUluZGV4ZXMpO1xuICAgIGNvbnN0IGRvTm90Q29udGFpbiA9ICFjb250YWluU25hcHMgfHwgY29udGFpblNjcm9sbCA9PT0gJ2tlZXBTbmFwcyc7XG4gICAgaWYgKGRvTm90Q29udGFpbiB8fCBjb250ZW50U2l6ZSA8PSB2aWV3U2l6ZSkgcmV0dXJuIGdyb3VwZWRTbGlkZUluZGV4ZXM7XG4gICAgcmV0dXJuIGdyb3VwZWRTbGlkZUluZGV4ZXMuc2xpY2UobWluLCBtYXgpLm1hcCgoZ3JvdXAsIGluZGV4LCBncm91cHMpID0+IHtcbiAgICAgIGNvbnN0IGlzRmlyc3QgPSAhaW5kZXg7XG4gICAgICBjb25zdCBpc0xhc3QgPSBhcnJheUlzTGFzdEluZGV4KGdyb3VwcywgaW5kZXgpO1xuICAgICAgaWYgKGlzRmlyc3QpIHtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBhcnJheUxhc3QoZ3JvdXBzWzBdKSArIDE7XG4gICAgICAgIHJldHVybiBhcnJheUZyb21OdW1iZXIocmFuZ2UpO1xuICAgICAgfVxuICAgICAgaWYgKGlzTGFzdCkge1xuICAgICAgICBjb25zdCByYW5nZSA9IGFycmF5TGFzdEluZGV4KHNsaWRlSW5kZXhlcykgLSBhcnJheUxhc3QoZ3JvdXBzKVswXSArIDE7XG4gICAgICAgIHJldHVybiBhcnJheUZyb21OdW1iZXIocmFuZ2UsIGFycmF5TGFzdChncm91cHMpWzBdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBncm91cDtcbiAgICB9KTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIHNsaWRlUmVnaXN0cnlcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIFNjcm9sbFRhcmdldChsb29wLCBzY3JvbGxTbmFwcywgY29udGVudFNpemUsIGxpbWl0LCB0YXJnZXRWZWN0b3IpIHtcbiAgY29uc3Qge1xuICAgIHJlYWNoZWRBbnksXG4gICAgcmVtb3ZlT2Zmc2V0LFxuICAgIGNvbnN0cmFpblxuICB9ID0gbGltaXQ7XG4gIGZ1bmN0aW9uIG1pbkRpc3RhbmNlKGRpc3RhbmNlcykge1xuICAgIHJldHVybiBkaXN0YW5jZXMuY29uY2F0KCkuc29ydCgoYSwgYikgPT4gbWF0aEFicyhhKSAtIG1hdGhBYnMoYikpWzBdO1xuICB9XG4gIGZ1bmN0aW9uIGZpbmRUYXJnZXRTbmFwKHRhcmdldCkge1xuICAgIGNvbnN0IGRpc3RhbmNlID0gbG9vcCA/IHJlbW92ZU9mZnNldCh0YXJnZXQpIDogY29uc3RyYWluKHRhcmdldCk7XG4gICAgY29uc3QgYXNjRGlmZnNUb1NuYXBzID0gc2Nyb2xsU25hcHMubWFwKHNjcm9sbFNuYXAgPT4gc2Nyb2xsU25hcCAtIGRpc3RhbmNlKS5tYXAoZGlmZlRvU25hcCA9PiBzaG9ydGN1dChkaWZmVG9TbmFwLCAwKSkubWFwKChkaWZmLCBpKSA9PiAoe1xuICAgICAgZGlmZixcbiAgICAgIGluZGV4OiBpXG4gICAgfSkpLnNvcnQoKGQxLCBkMikgPT4gbWF0aEFicyhkMS5kaWZmKSAtIG1hdGhBYnMoZDIuZGlmZikpO1xuICAgIGNvbnN0IHtcbiAgICAgIGluZGV4XG4gICAgfSA9IGFzY0RpZmZzVG9TbmFwc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgaW5kZXgsXG4gICAgICBkaXN0YW5jZVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gc2hvcnRjdXQodGFyZ2V0LCBkaXJlY3Rpb24pIHtcbiAgICBjb25zdCB0YXJnZXRzID0gW3RhcmdldCwgdGFyZ2V0ICsgY29udGVudFNpemUsIHRhcmdldCAtIGNvbnRlbnRTaXplXTtcbiAgICBpZiAoIWxvb3ApIHJldHVybiB0YXJnZXRzWzBdO1xuICAgIGlmICghZGlyZWN0aW9uKSByZXR1cm4gbWluRGlzdGFuY2UodGFyZ2V0cyk7XG4gICAgY29uc3QgbWF0Y2hpbmdUYXJnZXRzID0gdGFyZ2V0cy5maWx0ZXIodCA9PiBtYXRoU2lnbih0KSA9PT0gZGlyZWN0aW9uKTtcbiAgICBpZiAobWF0Y2hpbmdUYXJnZXRzLmxlbmd0aCkgcmV0dXJuIG1pbkRpc3RhbmNlKG1hdGNoaW5nVGFyZ2V0cyk7XG4gICAgcmV0dXJuIGFycmF5TGFzdCh0YXJnZXRzKSAtIGNvbnRlbnRTaXplO1xuICB9XG4gIGZ1bmN0aW9uIGJ5SW5kZXgoaW5kZXgsIGRpcmVjdGlvbikge1xuICAgIGNvbnN0IGRpZmZUb1NuYXAgPSBzY3JvbGxTbmFwc1tpbmRleF0gLSB0YXJnZXRWZWN0b3IuZ2V0KCk7XG4gICAgY29uc3QgZGlzdGFuY2UgPSBzaG9ydGN1dChkaWZmVG9TbmFwLCBkaXJlY3Rpb24pO1xuICAgIHJldHVybiB7XG4gICAgICBpbmRleCxcbiAgICAgIGRpc3RhbmNlXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBieURpc3RhbmNlKGRpc3RhbmNlLCBzbmFwKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gdGFyZ2V0VmVjdG9yLmdldCgpICsgZGlzdGFuY2U7XG4gICAgY29uc3Qge1xuICAgICAgaW5kZXgsXG4gICAgICBkaXN0YW5jZTogdGFyZ2V0U25hcERpc3RhbmNlXG4gICAgfSA9IGZpbmRUYXJnZXRTbmFwKHRhcmdldCk7XG4gICAgY29uc3QgcmVhY2hlZEJvdW5kID0gIWxvb3AgJiYgcmVhY2hlZEFueSh0YXJnZXQpO1xuICAgIGlmICghc25hcCB8fCByZWFjaGVkQm91bmQpIHJldHVybiB7XG4gICAgICBpbmRleCxcbiAgICAgIGRpc3RhbmNlXG4gICAgfTtcbiAgICBjb25zdCBkaWZmVG9TbmFwID0gc2Nyb2xsU25hcHNbaW5kZXhdIC0gdGFyZ2V0U25hcERpc3RhbmNlO1xuICAgIGNvbnN0IHNuYXBEaXN0YW5jZSA9IGRpc3RhbmNlICsgc2hvcnRjdXQoZGlmZlRvU25hcCwgMCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluZGV4LFxuICAgICAgZGlzdGFuY2U6IHNuYXBEaXN0YW5jZVxuICAgIH07XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBieURpc3RhbmNlLFxuICAgIGJ5SW5kZXgsXG4gICAgc2hvcnRjdXRcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIFNjcm9sbFRvKGFuaW1hdGlvbiwgaW5kZXhDdXJyZW50LCBpbmRleFByZXZpb3VzLCBzY3JvbGxUYXJnZXQsIHRhcmdldFZlY3RvciwgZXZlbnRIYW5kbGVyKSB7XG4gIGZ1bmN0aW9uIHNjcm9sbFRvKHRhcmdldCkge1xuICAgIGNvbnN0IGRpc3RhbmNlRGlmZiA9IHRhcmdldC5kaXN0YW5jZTtcbiAgICBjb25zdCBpbmRleERpZmYgPSB0YXJnZXQuaW5kZXggIT09IGluZGV4Q3VycmVudC5nZXQoKTtcbiAgICB0YXJnZXRWZWN0b3IuYWRkKGRpc3RhbmNlRGlmZik7XG4gICAgaWYgKGRpc3RhbmNlRGlmZikgYW5pbWF0aW9uLnN0YXJ0KCk7XG4gICAgaWYgKGluZGV4RGlmZikge1xuICAgICAgaW5kZXhQcmV2aW91cy5zZXQoaW5kZXhDdXJyZW50LmdldCgpKTtcbiAgICAgIGluZGV4Q3VycmVudC5zZXQodGFyZ2V0LmluZGV4KTtcbiAgICAgIGV2ZW50SGFuZGxlci5lbWl0KCdzZWxlY3QnKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZGlzdGFuY2Uobiwgc25hcCkge1xuICAgIGNvbnN0IHRhcmdldCA9IHNjcm9sbFRhcmdldC5ieURpc3RhbmNlKG4sIHNuYXApO1xuICAgIHNjcm9sbFRvKHRhcmdldCk7XG4gIH1cbiAgZnVuY3Rpb24gaW5kZXgobiwgZGlyZWN0aW9uKSB7XG4gICAgY29uc3QgdGFyZ2V0SW5kZXggPSBpbmRleEN1cnJlbnQuY2xvbmUoKS5zZXQobik7XG4gICAgY29uc3QgdGFyZ2V0ID0gc2Nyb2xsVGFyZ2V0LmJ5SW5kZXgodGFyZ2V0SW5kZXguZ2V0KCksIGRpcmVjdGlvbik7XG4gICAgc2Nyb2xsVG8odGFyZ2V0KTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGRpc3RhbmNlLFxuICAgIGluZGV4XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBTbGlkZUZvY3VzKHJvb3QsIHNsaWRlcywgc2xpZGVSZWdpc3RyeSwgc2Nyb2xsVG8sIHNjcm9sbEJvZHksIGV2ZW50U3RvcmUpIHtcbiAgbGV0IGxhc3RUYWJQcmVzc1RpbWUgPSAwO1xuICBmdW5jdGlvbiBpbml0KCkge1xuICAgIGV2ZW50U3RvcmUuYWRkKGRvY3VtZW50LCAna2V5ZG93bicsIHJlZ2lzdGVyVGFiUHJlc3MsIGZhbHNlKTtcbiAgICBzbGlkZXMuZm9yRWFjaChhZGRTbGlkZUZvY3VzRXZlbnQpO1xuICB9XG4gIGZ1bmN0aW9uIHJlZ2lzdGVyVGFiUHJlc3MoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuY29kZSA9PT0gJ1RhYicpIGxhc3RUYWJQcmVzc1RpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgfVxuICBmdW5jdGlvbiBhZGRTbGlkZUZvY3VzRXZlbnQoc2xpZGUpIHtcbiAgICBjb25zdCBmb2N1cyA9ICgpID0+IHtcbiAgICAgIGNvbnN0IG5vd1RpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgIGNvbnN0IGRpZmZUaW1lID0gbm93VGltZSAtIGxhc3RUYWJQcmVzc1RpbWU7XG4gICAgICBpZiAoZGlmZlRpbWUgPiAxMCkgcmV0dXJuO1xuICAgICAgcm9vdC5zY3JvbGxMZWZ0ID0gMDtcbiAgICAgIGNvbnN0IGluZGV4ID0gc2xpZGVzLmluZGV4T2Yoc2xpZGUpO1xuICAgICAgY29uc3QgZ3JvdXAgPSBzbGlkZVJlZ2lzdHJ5LmZpbmRJbmRleChncm91cCA9PiBncm91cC5pbmNsdWRlcyhpbmRleCkpO1xuICAgICAgaWYgKCFpc051bWJlcihncm91cCkpIHJldHVybjtcbiAgICAgIHNjcm9sbEJvZHkudXNlRHVyYXRpb24oMCk7XG4gICAgICBzY3JvbGxUby5pbmRleChncm91cCwgMCk7XG4gICAgfTtcbiAgICBldmVudFN0b3JlLmFkZChzbGlkZSwgJ2ZvY3VzJywgZm9jdXMsIHtcbiAgICAgIHBhc3NpdmU6IHRydWUsXG4gICAgICBjYXB0dXJlOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBpbml0XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBWZWN0b3IxRChpbml0aWFsVmFsdWUpIHtcbiAgbGV0IHZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIHNldChuKSB7XG4gICAgdmFsdWUgPSBub3JtYWxpemVJbnB1dChuKTtcbiAgfVxuICBmdW5jdGlvbiBhZGQobikge1xuICAgIHZhbHVlICs9IG5vcm1hbGl6ZUlucHV0KG4pO1xuICB9XG4gIGZ1bmN0aW9uIHN1YnRyYWN0KG4pIHtcbiAgICB2YWx1ZSAtPSBub3JtYWxpemVJbnB1dChuKTtcbiAgfVxuICBmdW5jdGlvbiBub3JtYWxpemVJbnB1dChuKSB7XG4gICAgcmV0dXJuIGlzTnVtYmVyKG4pID8gbiA6IG4uZ2V0KCk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBnZXQsXG4gICAgc2V0LFxuICAgIGFkZCxcbiAgICBzdWJ0cmFjdFxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gVHJhbnNsYXRlKGF4aXMsIGRpcmVjdGlvbiwgY29udGFpbmVyKSB7XG4gIGNvbnN0IHRyYW5zbGF0ZSA9IGF4aXMuc2Nyb2xsID09PSAneCcgPyB4IDogeTtcbiAgY29uc3QgY29udGFpbmVyU3R5bGUgPSBjb250YWluZXIuc3R5bGU7XG4gIGxldCBkaXNhYmxlZCA9IGZhbHNlO1xuICBmdW5jdGlvbiB4KG4pIHtcbiAgICByZXR1cm4gYHRyYW5zbGF0ZTNkKCR7bn1weCwwcHgsMHB4KWA7XG4gIH1cbiAgZnVuY3Rpb24geShuKSB7XG4gICAgcmV0dXJuIGB0cmFuc2xhdGUzZCgwcHgsJHtufXB4LDBweClgO1xuICB9XG4gIGZ1bmN0aW9uIHRvKHRhcmdldCkge1xuICAgIGlmIChkaXNhYmxlZCkgcmV0dXJuO1xuICAgIGNvbnRhaW5lclN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zbGF0ZShkaXJlY3Rpb24uYXBwbHkodGFyZ2V0KSk7XG4gIH1cbiAgZnVuY3Rpb24gdG9nZ2xlQWN0aXZlKGFjdGl2ZSkge1xuICAgIGRpc2FibGVkID0gIWFjdGl2ZTtcbiAgfVxuICBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICBpZiAoZGlzYWJsZWQpIHJldHVybjtcbiAgICBjb250YWluZXJTdHlsZS50cmFuc2Zvcm0gPSAnJztcbiAgICBpZiAoIWNvbnRhaW5lci5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykpIGNvbnRhaW5lci5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBjbGVhcixcbiAgICB0byxcbiAgICB0b2dnbGVBY3RpdmVcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIFNsaWRlTG9vcGVyKGF4aXMsIGRpcmVjdGlvbiwgdmlld1NpemUsIGNvbnRlbnRTaXplLCBzbGlkZVNpemVzLCBzbGlkZVNpemVzV2l0aEdhcHMsIHNuYXBzLCBzY3JvbGxTbmFwcywgb2Zmc2V0TG9jYXRpb24sIHNsaWRlcykge1xuICBjb25zdCByb3VuZGluZ1NhZmV0eSA9IDAuNTtcbiAgY29uc3QgYXNjSXRlbXMgPSBhcnJheUtleXMoc2xpZGVTaXplc1dpdGhHYXBzKTtcbiAgY29uc3QgZGVzY0l0ZW1zID0gYXJyYXlLZXlzKHNsaWRlU2l6ZXNXaXRoR2FwcykucmV2ZXJzZSgpO1xuICBjb25zdCBsb29wUG9pbnRzID0gc3RhcnRQb2ludHMoKS5jb25jYXQoZW5kUG9pbnRzKCkpO1xuICBmdW5jdGlvbiByZW1vdmVTbGlkZVNpemVzKGluZGV4ZXMsIGZyb20pIHtcbiAgICByZXR1cm4gaW5kZXhlcy5yZWR1Y2UoKGEsIGkpID0+IHtcbiAgICAgIHJldHVybiBhIC0gc2xpZGVTaXplc1dpdGhHYXBzW2ldO1xuICAgIH0sIGZyb20pO1xuICB9XG4gIGZ1bmN0aW9uIHNsaWRlc0luR2FwKGluZGV4ZXMsIGdhcCkge1xuICAgIHJldHVybiBpbmRleGVzLnJlZHVjZSgoYSwgaSkgPT4ge1xuICAgICAgY29uc3QgcmVtYWluaW5nR2FwID0gcmVtb3ZlU2xpZGVTaXplcyhhLCBnYXApO1xuICAgICAgcmV0dXJuIHJlbWFpbmluZ0dhcCA+IDAgPyBhLmNvbmNhdChbaV0pIDogYTtcbiAgICB9LCBbXSk7XG4gIH1cbiAgZnVuY3Rpb24gZmluZFNsaWRlQm91bmRzKG9mZnNldCkge1xuICAgIHJldHVybiBzbmFwcy5tYXAoKHNuYXAsIGluZGV4KSA9PiAoe1xuICAgICAgc3RhcnQ6IHNuYXAgLSBzbGlkZVNpemVzW2luZGV4XSArIHJvdW5kaW5nU2FmZXR5ICsgb2Zmc2V0LFxuICAgICAgZW5kOiBzbmFwICsgdmlld1NpemUgLSByb3VuZGluZ1NhZmV0eSArIG9mZnNldFxuICAgIH0pKTtcbiAgfVxuICBmdW5jdGlvbiBmaW5kTG9vcFBvaW50cyhpbmRleGVzLCBvZmZzZXQsIGlzRW5kRWRnZSkge1xuICAgIGNvbnN0IHNsaWRlQm91bmRzID0gZmluZFNsaWRlQm91bmRzKG9mZnNldCk7XG4gICAgcmV0dXJuIGluZGV4ZXMubWFwKGluZGV4ID0+IHtcbiAgICAgIGNvbnN0IGluaXRpYWwgPSBpc0VuZEVkZ2UgPyAwIDogLWNvbnRlbnRTaXplO1xuICAgICAgY29uc3QgYWx0ZXJlZCA9IGlzRW5kRWRnZSA/IGNvbnRlbnRTaXplIDogMDtcbiAgICAgIGNvbnN0IGJvdW5kRWRnZSA9IGlzRW5kRWRnZSA/ICdlbmQnIDogJ3N0YXJ0JztcbiAgICAgIGNvbnN0IGxvb3BQb2ludCA9IHNsaWRlQm91bmRzW2luZGV4XVtib3VuZEVkZ2VdO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIGxvb3BQb2ludCxcbiAgICAgICAgc2xpZGVMb2NhdGlvbjogVmVjdG9yMUQoLTEpLFxuICAgICAgICB0cmFuc2xhdGU6IFRyYW5zbGF0ZShheGlzLCBkaXJlY3Rpb24sIHNsaWRlc1tpbmRleF0pLFxuICAgICAgICB0YXJnZXQ6ICgpID0+IG9mZnNldExvY2F0aW9uLmdldCgpID4gbG9vcFBvaW50ID8gaW5pdGlhbCA6IGFsdGVyZWRcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gc3RhcnRQb2ludHMoKSB7XG4gICAgY29uc3QgZ2FwID0gc2Nyb2xsU25hcHNbMF07XG4gICAgY29uc3QgaW5kZXhlcyA9IHNsaWRlc0luR2FwKGRlc2NJdGVtcywgZ2FwKTtcbiAgICByZXR1cm4gZmluZExvb3BQb2ludHMoaW5kZXhlcywgY29udGVudFNpemUsIGZhbHNlKTtcbiAgfVxuICBmdW5jdGlvbiBlbmRQb2ludHMoKSB7XG4gICAgY29uc3QgZ2FwID0gdmlld1NpemUgLSBzY3JvbGxTbmFwc1swXSAtIDE7XG4gICAgY29uc3QgaW5kZXhlcyA9IHNsaWRlc0luR2FwKGFzY0l0ZW1zLCBnYXApO1xuICAgIHJldHVybiBmaW5kTG9vcFBvaW50cyhpbmRleGVzLCAtY29udGVudFNpemUsIHRydWUpO1xuICB9XG4gIGZ1bmN0aW9uIGNhbkxvb3AoKSB7XG4gICAgcmV0dXJuIGxvb3BQb2ludHMuZXZlcnkoKHtcbiAgICAgIGluZGV4XG4gICAgfSkgPT4ge1xuICAgICAgY29uc3Qgb3RoZXJJbmRleGVzID0gYXNjSXRlbXMuZmlsdGVyKGkgPT4gaSAhPT0gaW5kZXgpO1xuICAgICAgcmV0dXJuIHJlbW92ZVNsaWRlU2l6ZXMob3RoZXJJbmRleGVzLCB2aWV3U2l6ZSkgPD0gMC4xO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGxvb3AoKSB7XG4gICAgbG9vcFBvaW50cy5mb3JFYWNoKGxvb3BQb2ludCA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgdHJhbnNsYXRlLFxuICAgICAgICBzbGlkZUxvY2F0aW9uXG4gICAgICB9ID0gbG9vcFBvaW50O1xuICAgICAgY29uc3Qgc2hpZnRMb2NhdGlvbiA9IHRhcmdldCgpO1xuICAgICAgaWYgKHNoaWZ0TG9jYXRpb24gPT09IHNsaWRlTG9jYXRpb24uZ2V0KCkpIHJldHVybjtcbiAgICAgIHRyYW5zbGF0ZS50byhzaGlmdExvY2F0aW9uKTtcbiAgICAgIHNsaWRlTG9jYXRpb24uc2V0KHNoaWZ0TG9jYXRpb24pO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIGxvb3BQb2ludHMuZm9yRWFjaChsb29wUG9pbnQgPT4gbG9vcFBvaW50LnRyYW5zbGF0ZS5jbGVhcigpKTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGNhbkxvb3AsXG4gICAgY2xlYXIsXG4gICAgbG9vcCxcbiAgICBsb29wUG9pbnRzXG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBTbGlkZXNIYW5kbGVyKGNvbnRhaW5lciwgZXZlbnRIYW5kbGVyLCB3YXRjaFNsaWRlcykge1xuICBsZXQgbXV0YXRpb25PYnNlcnZlcjtcbiAgbGV0IGRlc3Ryb3llZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBpbml0KGVtYmxhQXBpKSB7XG4gICAgaWYgKCF3YXRjaFNsaWRlcykgcmV0dXJuO1xuICAgIGZ1bmN0aW9uIGRlZmF1bHRDYWxsYmFjayhtdXRhdGlvbnMpIHtcbiAgICAgIGZvciAoY29uc3QgbXV0YXRpb24gb2YgbXV0YXRpb25zKSB7XG4gICAgICAgIGlmIChtdXRhdGlvbi50eXBlID09PSAnY2hpbGRMaXN0Jykge1xuICAgICAgICAgIGVtYmxhQXBpLnJlSW5pdCgpO1xuICAgICAgICAgIGV2ZW50SGFuZGxlci5lbWl0KCdzbGlkZXNDaGFuZ2VkJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbXV0YXRpb25PYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKG11dGF0aW9ucyA9PiB7XG4gICAgICBpZiAoZGVzdHJveWVkKSByZXR1cm47XG4gICAgICBpZiAoaXNCb29sZWFuKHdhdGNoU2xpZGVzKSB8fCB3YXRjaFNsaWRlcyhlbWJsYUFwaSwgbXV0YXRpb25zKSkge1xuICAgICAgICBkZWZhdWx0Q2FsbGJhY2sobXV0YXRpb25zKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBtdXRhdGlvbk9ic2VydmVyLm9ic2VydmUoY29udGFpbmVyLCB7XG4gICAgICBjaGlsZExpc3Q6IHRydWVcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIGlmIChtdXRhdGlvbk9ic2VydmVyKSBtdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICBkZXN0cm95ZWQgPSB0cnVlO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgaW5pdCxcbiAgICBkZXN0cm95XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBTbGlkZXNJblZpZXcoY29udGFpbmVyLCBzbGlkZXMsIGV2ZW50SGFuZGxlciwgdGhyZXNob2xkKSB7XG4gIGNvbnN0IGludGVyc2VjdGlvbkVudHJ5TWFwID0ge307XG4gIGxldCBpblZpZXdDYWNoZSA9IG51bGw7XG4gIGxldCBub3RJblZpZXdDYWNoZSA9IG51bGw7XG4gIGxldCBpbnRlcnNlY3Rpb25PYnNlcnZlcjtcbiAgbGV0IGRlc3Ryb3llZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBpbml0KCkge1xuICAgIGludGVyc2VjdGlvbk9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgICAgaWYgKGRlc3Ryb3llZCkgcmV0dXJuO1xuICAgICAgZW50cmllcy5mb3JFYWNoKGVudHJ5ID0+IHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBzbGlkZXMuaW5kZXhPZihlbnRyeS50YXJnZXQpO1xuICAgICAgICBpbnRlcnNlY3Rpb25FbnRyeU1hcFtpbmRleF0gPSBlbnRyeTtcbiAgICAgIH0pO1xuICAgICAgaW5WaWV3Q2FjaGUgPSBudWxsO1xuICAgICAgbm90SW5WaWV3Q2FjaGUgPSBudWxsO1xuICAgICAgZXZlbnRIYW5kbGVyLmVtaXQoJ3NsaWRlc0luVmlldycpO1xuICAgIH0sIHtcbiAgICAgIHJvb3Q6IGNvbnRhaW5lci5wYXJlbnRFbGVtZW50LFxuICAgICAgdGhyZXNob2xkXG4gICAgfSk7XG4gICAgc2xpZGVzLmZvckVhY2goc2xpZGUgPT4gaW50ZXJzZWN0aW9uT2JzZXJ2ZXIub2JzZXJ2ZShzbGlkZSkpO1xuICB9XG4gIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgaWYgKGludGVyc2VjdGlvbk9ic2VydmVyKSBpbnRlcnNlY3Rpb25PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVJblZpZXdMaXN0KGluVmlldykge1xuICAgIHJldHVybiBvYmplY3RLZXlzKGludGVyc2VjdGlvbkVudHJ5TWFwKS5yZWR1Y2UoKGxpc3QsIHNsaWRlSW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGluZGV4ID0gcGFyc2VJbnQoc2xpZGVJbmRleCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGlzSW50ZXJzZWN0aW5nXG4gICAgICB9ID0gaW50ZXJzZWN0aW9uRW50cnlNYXBbaW5kZXhdO1xuICAgICAgY29uc3QgaW5WaWV3TWF0Y2ggPSBpblZpZXcgJiYgaXNJbnRlcnNlY3Rpbmc7XG4gICAgICBjb25zdCBub3RJblZpZXdNYXRjaCA9ICFpblZpZXcgJiYgIWlzSW50ZXJzZWN0aW5nO1xuICAgICAgaWYgKGluVmlld01hdGNoIHx8IG5vdEluVmlld01hdGNoKSBsaXN0LnB1c2goaW5kZXgpO1xuICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfSwgW10pO1xuICB9XG4gIGZ1bmN0aW9uIGdldChpblZpZXcgPSB0cnVlKSB7XG4gICAgaWYgKGluVmlldyAmJiBpblZpZXdDYWNoZSkgcmV0dXJuIGluVmlld0NhY2hlO1xuICAgIGlmICghaW5WaWV3ICYmIG5vdEluVmlld0NhY2hlKSByZXR1cm4gbm90SW5WaWV3Q2FjaGU7XG4gICAgY29uc3Qgc2xpZGVJbmRleGVzID0gY3JlYXRlSW5WaWV3TGlzdChpblZpZXcpO1xuICAgIGlmIChpblZpZXcpIGluVmlld0NhY2hlID0gc2xpZGVJbmRleGVzO1xuICAgIGlmICghaW5WaWV3KSBub3RJblZpZXdDYWNoZSA9IHNsaWRlSW5kZXhlcztcbiAgICByZXR1cm4gc2xpZGVJbmRleGVzO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgaW5pdCxcbiAgICBkZXN0cm95LFxuICAgIGdldFxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gU2xpZGVTaXplcyhheGlzLCBjb250YWluZXJSZWN0LCBzbGlkZVJlY3RzLCBzbGlkZXMsIHJlYWRFZGdlR2FwLCBvd25lcldpbmRvdykge1xuICBjb25zdCB7XG4gICAgbWVhc3VyZVNpemUsXG4gICAgc3RhcnRFZGdlLFxuICAgIGVuZEVkZ2VcbiAgfSA9IGF4aXM7XG4gIGNvbnN0IHdpdGhFZGdlR2FwID0gc2xpZGVSZWN0c1swXSAmJiByZWFkRWRnZUdhcDtcbiAgY29uc3Qgc3RhcnRHYXAgPSBtZWFzdXJlU3RhcnRHYXAoKTtcbiAgY29uc3QgZW5kR2FwID0gbWVhc3VyZUVuZEdhcCgpO1xuICBjb25zdCBzbGlkZVNpemVzID0gc2xpZGVSZWN0cy5tYXAobWVhc3VyZVNpemUpO1xuICBjb25zdCBzbGlkZVNpemVzV2l0aEdhcHMgPSBtZWFzdXJlV2l0aEdhcHMoKTtcbiAgZnVuY3Rpb24gbWVhc3VyZVN0YXJ0R2FwKCkge1xuICAgIGlmICghd2l0aEVkZ2VHYXApIHJldHVybiAwO1xuICAgIGNvbnN0IHNsaWRlUmVjdCA9IHNsaWRlUmVjdHNbMF07XG4gICAgcmV0dXJuIG1hdGhBYnMoY29udGFpbmVyUmVjdFtzdGFydEVkZ2VdIC0gc2xpZGVSZWN0W3N0YXJ0RWRnZV0pO1xuICB9XG4gIGZ1bmN0aW9uIG1lYXN1cmVFbmRHYXAoKSB7XG4gICAgaWYgKCF3aXRoRWRnZUdhcCkgcmV0dXJuIDA7XG4gICAgY29uc3Qgc3R5bGUgPSBvd25lcldpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGFycmF5TGFzdChzbGlkZXMpKTtcbiAgICByZXR1cm4gcGFyc2VGbG9hdChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKGBtYXJnaW4tJHtlbmRFZGdlfWApKTtcbiAgfVxuICBmdW5jdGlvbiBtZWFzdXJlV2l0aEdhcHMoKSB7XG4gICAgcmV0dXJuIHNsaWRlUmVjdHMubWFwKChyZWN0LCBpbmRleCwgcmVjdHMpID0+IHtcbiAgICAgIGNvbnN0IGlzRmlyc3QgPSAhaW5kZXg7XG4gICAgICBjb25zdCBpc0xhc3QgPSBhcnJheUlzTGFzdEluZGV4KHJlY3RzLCBpbmRleCk7XG4gICAgICBpZiAoaXNGaXJzdCkgcmV0dXJuIHNsaWRlU2l6ZXNbaW5kZXhdICsgc3RhcnRHYXA7XG4gICAgICBpZiAoaXNMYXN0KSByZXR1cm4gc2xpZGVTaXplc1tpbmRleF0gKyBlbmRHYXA7XG4gICAgICByZXR1cm4gcmVjdHNbaW5kZXggKyAxXVtzdGFydEVkZ2VdIC0gcmVjdFtzdGFydEVkZ2VdO1xuICAgIH0pLm1hcChtYXRoQWJzKTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIHNsaWRlU2l6ZXMsXG4gICAgc2xpZGVTaXplc1dpdGhHYXBzLFxuICAgIHN0YXJ0R2FwLFxuICAgIGVuZEdhcFxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gU2xpZGVzVG9TY3JvbGwoYXhpcywgZGlyZWN0aW9uLCB2aWV3U2l6ZSwgc2xpZGVzVG9TY3JvbGwsIGxvb3AsIGNvbnRhaW5lclJlY3QsIHNsaWRlUmVjdHMsIHN0YXJ0R2FwLCBlbmRHYXApIHtcbiAgY29uc3Qge1xuICAgIHN0YXJ0RWRnZSxcbiAgICBlbmRFZGdlXG4gIH0gPSBheGlzO1xuICBjb25zdCBncm91cEJ5TnVtYmVyID0gaXNOdW1iZXIoc2xpZGVzVG9TY3JvbGwpO1xuICBmdW5jdGlvbiBieU51bWJlcihhcnJheSwgZ3JvdXBTaXplKSB7XG4gICAgcmV0dXJuIGFycmF5S2V5cyhhcnJheSkuZmlsdGVyKGkgPT4gaSAlIGdyb3VwU2l6ZSA9PT0gMCkubWFwKGkgPT4gYXJyYXkuc2xpY2UoaSwgaSArIGdyb3VwU2l6ZSkpO1xuICB9XG4gIGZ1bmN0aW9uIGJ5U2l6ZShhcnJheSkge1xuICAgIGlmICghYXJyYXkubGVuZ3RoKSByZXR1cm4gW107XG4gICAgcmV0dXJuIGFycmF5S2V5cyhhcnJheSkucmVkdWNlKChncm91cHMsIHJlY3RCKSA9PiB7XG4gICAgICBjb25zdCByZWN0QSA9IGFycmF5TGFzdChncm91cHMpIHx8IDA7XG4gICAgICBjb25zdCBpc0ZpcnN0ID0gcmVjdEEgPT09IDA7XG4gICAgICBjb25zdCBpc0xhc3QgPSByZWN0QiA9PT0gYXJyYXlMYXN0SW5kZXgoYXJyYXkpO1xuICAgICAgY29uc3QgZWRnZUEgPSBjb250YWluZXJSZWN0W3N0YXJ0RWRnZV0gLSBzbGlkZVJlY3RzW3JlY3RBXVtzdGFydEVkZ2VdO1xuICAgICAgY29uc3QgZWRnZUIgPSBjb250YWluZXJSZWN0W3N0YXJ0RWRnZV0gLSBzbGlkZVJlY3RzW3JlY3RCXVtlbmRFZGdlXTtcbiAgICAgIGNvbnN0IGdhcEEgPSAhbG9vcCAmJiBpc0ZpcnN0ID8gZGlyZWN0aW9uLmFwcGx5KHN0YXJ0R2FwKSA6IDA7XG4gICAgICBjb25zdCBnYXBCID0gIWxvb3AgJiYgaXNMYXN0ID8gZGlyZWN0aW9uLmFwcGx5KGVuZEdhcCkgOiAwO1xuICAgICAgY29uc3QgY2h1bmtTaXplID0gbWF0aEFicyhlZGdlQiAtIGdhcEIgLSAoZWRnZUEgKyBnYXBBKSk7XG4gICAgICBpZiAoY2h1bmtTaXplID4gdmlld1NpemUpIGdyb3Vwcy5wdXNoKHJlY3RCKTtcbiAgICAgIGlmIChpc0xhc3QpIGdyb3Vwcy5wdXNoKGFycmF5Lmxlbmd0aCk7XG4gICAgICByZXR1cm4gZ3JvdXBzO1xuICAgIH0sIFtdKS5tYXAoKGN1cnJlbnRTaXplLCBpbmRleCwgZ3JvdXBzKSA9PiB7XG4gICAgICBjb25zdCBwcmV2aW91c1NpemUgPSBNYXRoLm1heChncm91cHNbaW5kZXggLSAxXSB8fCAwKTtcbiAgICAgIHJldHVybiBhcnJheS5zbGljZShwcmV2aW91c1NpemUsIGN1cnJlbnRTaXplKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBncm91cFNsaWRlcyhhcnJheSkge1xuICAgIHJldHVybiBncm91cEJ5TnVtYmVyID8gYnlOdW1iZXIoYXJyYXksIHNsaWRlc1RvU2Nyb2xsKSA6IGJ5U2l6ZShhcnJheSk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBncm91cFNsaWRlc1xuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gRW5naW5lKHJvb3QsIGNvbnRhaW5lciwgc2xpZGVzLCBvd25lckRvY3VtZW50LCBvd25lcldpbmRvdywgb3B0aW9ucywgZXZlbnRIYW5kbGVyLCBhbmltYXRpb25zKSB7XG4gIC8vIE9wdGlvbnNcbiAgY29uc3Qge1xuICAgIGFsaWduLFxuICAgIGF4aXM6IHNjcm9sbEF4aXMsXG4gICAgZGlyZWN0aW9uOiBjb250ZW50RGlyZWN0aW9uLFxuICAgIHN0YXJ0SW5kZXgsXG4gICAgbG9vcCxcbiAgICBkdXJhdGlvbixcbiAgICBkcmFnRnJlZSxcbiAgICBkcmFnVGhyZXNob2xkLFxuICAgIGluVmlld1RocmVzaG9sZCxcbiAgICBzbGlkZXNUb1Njcm9sbDogZ3JvdXBTbGlkZXMsXG4gICAgc2tpcFNuYXBzLFxuICAgIGNvbnRhaW5TY3JvbGwsXG4gICAgd2F0Y2hSZXNpemUsXG4gICAgd2F0Y2hTbGlkZXMsXG4gICAgd2F0Y2hEcmFnXG4gIH0gPSBvcHRpb25zO1xuICAvLyBNZWFzdXJlbWVudHNcbiAgY29uc3Qgbm9kZVJlY3RzID0gTm9kZVJlY3RzKCk7XG4gIGNvbnN0IGNvbnRhaW5lclJlY3QgPSBub2RlUmVjdHMubWVhc3VyZShjb250YWluZXIpO1xuICBjb25zdCBzbGlkZVJlY3RzID0gc2xpZGVzLm1hcChub2RlUmVjdHMubWVhc3VyZSk7XG4gIGNvbnN0IGRpcmVjdGlvbiA9IERpcmVjdGlvbihjb250ZW50RGlyZWN0aW9uKTtcbiAgY29uc3QgYXhpcyA9IEF4aXMoc2Nyb2xsQXhpcywgY29udGVudERpcmVjdGlvbik7XG4gIGNvbnN0IHZpZXdTaXplID0gYXhpcy5tZWFzdXJlU2l6ZShjb250YWluZXJSZWN0KTtcbiAgY29uc3QgcGVyY2VudE9mVmlldyA9IFBlcmNlbnRPZlZpZXcodmlld1NpemUpO1xuICBjb25zdCBhbGlnbm1lbnQgPSBBbGlnbm1lbnQoYWxpZ24sIHZpZXdTaXplKTtcbiAgY29uc3QgY29udGFpblNuYXBzID0gIWxvb3AgJiYgISFjb250YWluU2Nyb2xsO1xuICBjb25zdCByZWFkRWRnZUdhcCA9IGxvb3AgfHwgISFjb250YWluU2Nyb2xsO1xuICBjb25zdCB7XG4gICAgc2xpZGVTaXplcyxcbiAgICBzbGlkZVNpemVzV2l0aEdhcHMsXG4gICAgc3RhcnRHYXAsXG4gICAgZW5kR2FwXG4gIH0gPSBTbGlkZVNpemVzKGF4aXMsIGNvbnRhaW5lclJlY3QsIHNsaWRlUmVjdHMsIHNsaWRlcywgcmVhZEVkZ2VHYXAsIG93bmVyV2luZG93KTtcbiAgY29uc3Qgc2xpZGVzVG9TY3JvbGwgPSBTbGlkZXNUb1Njcm9sbChheGlzLCBkaXJlY3Rpb24sIHZpZXdTaXplLCBncm91cFNsaWRlcywgbG9vcCwgY29udGFpbmVyUmVjdCwgc2xpZGVSZWN0cywgc3RhcnRHYXAsIGVuZEdhcCk7XG4gIGNvbnN0IHtcbiAgICBzbmFwcyxcbiAgICBzbmFwc0FsaWduZWRcbiAgfSA9IFNjcm9sbFNuYXBzKGF4aXMsIGFsaWdubWVudCwgY29udGFpbmVyUmVjdCwgc2xpZGVSZWN0cywgc2xpZGVzVG9TY3JvbGwpO1xuICBjb25zdCBjb250ZW50U2l6ZSA9IC1hcnJheUxhc3Qoc25hcHMpICsgYXJyYXlMYXN0KHNsaWRlU2l6ZXNXaXRoR2Fwcyk7XG4gIGNvbnN0IHtcbiAgICBzbmFwc0NvbnRhaW5lZCxcbiAgICBzY3JvbGxDb250YWluTGltaXRcbiAgfSA9IFNjcm9sbENvbnRhaW4odmlld1NpemUsIGNvbnRlbnRTaXplLCBzbmFwc0FsaWduZWQsIGNvbnRhaW5TY3JvbGwpO1xuICBjb25zdCBzY3JvbGxTbmFwcyA9IGNvbnRhaW5TbmFwcyA/IHNuYXBzQ29udGFpbmVkIDogc25hcHNBbGlnbmVkO1xuICBjb25zdCB7XG4gICAgbGltaXRcbiAgfSA9IFNjcm9sbExpbWl0KGNvbnRlbnRTaXplLCBzY3JvbGxTbmFwcywgbG9vcCk7XG4gIC8vIEluZGV4ZXNcbiAgY29uc3QgaW5kZXggPSBDb3VudGVyKGFycmF5TGFzdEluZGV4KHNjcm9sbFNuYXBzKSwgc3RhcnRJbmRleCwgbG9vcCk7XG4gIGNvbnN0IGluZGV4UHJldmlvdXMgPSBpbmRleC5jbG9uZSgpO1xuICBjb25zdCBzbGlkZUluZGV4ZXMgPSBhcnJheUtleXMoc2xpZGVzKTtcbiAgLy8gQW5pbWF0aW9uXG4gIGNvbnN0IHVwZGF0ZSA9ICh7XG4gICAgZHJhZ0hhbmRsZXIsXG4gICAgc2Nyb2xsQm9keSxcbiAgICBzY3JvbGxCb3VuZHMsXG4gICAgb3B0aW9uczoge1xuICAgICAgbG9vcFxuICAgIH1cbiAgfSkgPT4ge1xuICAgIGlmICghbG9vcCkgc2Nyb2xsQm91bmRzLmNvbnN0cmFpbihkcmFnSGFuZGxlci5wb2ludGVyRG93bigpKTtcbiAgICBzY3JvbGxCb2R5LnNlZWsoKTtcbiAgfTtcbiAgY29uc3QgcmVuZGVyID0gKHtcbiAgICBzY3JvbGxCb2R5LFxuICAgIHRyYW5zbGF0ZSxcbiAgICBsb2NhdGlvbixcbiAgICBvZmZzZXRMb2NhdGlvbixcbiAgICBzY3JvbGxMb29wZXIsXG4gICAgc2xpZGVMb29wZXIsXG4gICAgZHJhZ0hhbmRsZXIsXG4gICAgYW5pbWF0aW9uLFxuICAgIGV2ZW50SGFuZGxlcixcbiAgICBvcHRpb25zOiB7XG4gICAgICBsb29wXG4gICAgfVxuICB9LCBsYWdPZmZzZXQpID0+IHtcbiAgICBjb25zdCB2ZWxvY2l0eSA9IHNjcm9sbEJvZHkudmVsb2NpdHkoKTtcbiAgICBjb25zdCBoYXNTZXR0bGVkID0gc2Nyb2xsQm9keS5zZXR0bGVkKCk7XG4gICAgaWYgKGhhc1NldHRsZWQgJiYgIWRyYWdIYW5kbGVyLnBvaW50ZXJEb3duKCkpIHtcbiAgICAgIGFuaW1hdGlvbi5zdG9wKCk7XG4gICAgICBldmVudEhhbmRsZXIuZW1pdCgnc2V0dGxlJyk7XG4gICAgfVxuICAgIGlmICghaGFzU2V0dGxlZCkgZXZlbnRIYW5kbGVyLmVtaXQoJ3Njcm9sbCcpO1xuICAgIG9mZnNldExvY2F0aW9uLnNldChsb2NhdGlvbi5nZXQoKSAtIHZlbG9jaXR5ICsgdmVsb2NpdHkgKiBsYWdPZmZzZXQpO1xuICAgIGlmIChsb29wKSB7XG4gICAgICBzY3JvbGxMb29wZXIubG9vcChzY3JvbGxCb2R5LmRpcmVjdGlvbigpKTtcbiAgICAgIHNsaWRlTG9vcGVyLmxvb3AoKTtcbiAgICB9XG4gICAgdHJhbnNsYXRlLnRvKG9mZnNldExvY2F0aW9uLmdldCgpKTtcbiAgfTtcbiAgY29uc3QgYW5pbWF0aW9uID0ge1xuICAgIHN0YXJ0OiAoKSA9PiBhbmltYXRpb25zLnN0YXJ0KGVuZ2luZSksXG4gICAgc3RvcDogKCkgPT4gYW5pbWF0aW9ucy5zdG9wKGVuZ2luZSksXG4gICAgdXBkYXRlOiAoKSA9PiB1cGRhdGUoZW5naW5lKSxcbiAgICByZW5kZXI6IGxhZ09mZnNldCA9PiByZW5kZXIoZW5naW5lLCBsYWdPZmZzZXQpXG4gIH07XG4gIC8vIFNoYXJlZFxuICBjb25zdCBmcmljdGlvbiA9IDAuNjg7XG4gIGNvbnN0IHN0YXJ0TG9jYXRpb24gPSBzY3JvbGxTbmFwc1tpbmRleC5nZXQoKV07XG4gIGNvbnN0IGxvY2F0aW9uID0gVmVjdG9yMUQoc3RhcnRMb2NhdGlvbik7XG4gIGNvbnN0IG9mZnNldExvY2F0aW9uID0gVmVjdG9yMUQoc3RhcnRMb2NhdGlvbik7XG4gIGNvbnN0IHRhcmdldCA9IFZlY3RvcjFEKHN0YXJ0TG9jYXRpb24pO1xuICBjb25zdCBzY3JvbGxCb2R5ID0gU2Nyb2xsQm9keShsb2NhdGlvbiwgb2Zmc2V0TG9jYXRpb24sIHRhcmdldCwgZHVyYXRpb24sIGZyaWN0aW9uKTtcbiAgY29uc3Qgc2Nyb2xsVGFyZ2V0ID0gU2Nyb2xsVGFyZ2V0KGxvb3AsIHNjcm9sbFNuYXBzLCBjb250ZW50U2l6ZSwgbGltaXQsIHRhcmdldCk7XG4gIGNvbnN0IHNjcm9sbFRvID0gU2Nyb2xsVG8oYW5pbWF0aW9uLCBpbmRleCwgaW5kZXhQcmV2aW91cywgc2Nyb2xsVGFyZ2V0LCB0YXJnZXQsIGV2ZW50SGFuZGxlcik7XG4gIGNvbnN0IHNjcm9sbFByb2dyZXNzID0gU2Nyb2xsUHJvZ3Jlc3MobGltaXQpO1xuICBjb25zdCBldmVudFN0b3JlID0gRXZlbnRTdG9yZSgpO1xuICBjb25zdCBzbGlkZXNJblZpZXcgPSBTbGlkZXNJblZpZXcoY29udGFpbmVyLCBzbGlkZXMsIGV2ZW50SGFuZGxlciwgaW5WaWV3VGhyZXNob2xkKTtcbiAgY29uc3Qge1xuICAgIHNsaWRlUmVnaXN0cnlcbiAgfSA9IFNsaWRlUmVnaXN0cnkodmlld1NpemUsIGNvbnRlbnRTaXplLCBjb250YWluU25hcHMsIGNvbnRhaW5TY3JvbGwsIHNjcm9sbENvbnRhaW5MaW1pdCwgc2xpZGVzVG9TY3JvbGwsIHNsaWRlSW5kZXhlcyk7XG4gIGNvbnN0IHNsaWRlRm9jdXMgPSBTbGlkZUZvY3VzKHJvb3QsIHNsaWRlcywgc2xpZGVSZWdpc3RyeSwgc2Nyb2xsVG8sIHNjcm9sbEJvZHksIGV2ZW50U3RvcmUpO1xuICAvLyBFbmdpbmVcbiAgY29uc3QgZW5naW5lID0ge1xuICAgIG93bmVyRG9jdW1lbnQsXG4gICAgb3duZXJXaW5kb3csXG4gICAgZXZlbnRIYW5kbGVyLFxuICAgIGNvbnRhaW5lclJlY3QsXG4gICAgc2xpZGVSZWN0cyxcbiAgICBhbmltYXRpb24sXG4gICAgYXhpcyxcbiAgICBkaXJlY3Rpb24sXG4gICAgZHJhZ0hhbmRsZXI6IERyYWdIYW5kbGVyKGF4aXMsIGRpcmVjdGlvbiwgcm9vdCwgb3duZXJEb2N1bWVudCwgb3duZXJXaW5kb3csIHRhcmdldCwgRHJhZ1RyYWNrZXIoYXhpcywgb3duZXJXaW5kb3cpLCBsb2NhdGlvbiwgYW5pbWF0aW9uLCBzY3JvbGxUbywgc2Nyb2xsQm9keSwgc2Nyb2xsVGFyZ2V0LCBpbmRleCwgZXZlbnRIYW5kbGVyLCBwZXJjZW50T2ZWaWV3LCBkcmFnRnJlZSwgZHJhZ1RocmVzaG9sZCwgc2tpcFNuYXBzLCBmcmljdGlvbiwgd2F0Y2hEcmFnKSxcbiAgICBldmVudFN0b3JlLFxuICAgIHBlcmNlbnRPZlZpZXcsXG4gICAgaW5kZXgsXG4gICAgaW5kZXhQcmV2aW91cyxcbiAgICBsaW1pdCxcbiAgICBsb2NhdGlvbixcbiAgICBvZmZzZXRMb2NhdGlvbixcbiAgICBvcHRpb25zLFxuICAgIHJlc2l6ZUhhbmRsZXI6IFJlc2l6ZUhhbmRsZXIoY29udGFpbmVyLCBldmVudEhhbmRsZXIsIG93bmVyV2luZG93LCBzbGlkZXMsIGF4aXMsIHdhdGNoUmVzaXplLCBub2RlUmVjdHMpLFxuICAgIHNjcm9sbEJvZHksXG4gICAgc2Nyb2xsQm91bmRzOiBTY3JvbGxCb3VuZHMobGltaXQsIGxvY2F0aW9uLCB0YXJnZXQsIHNjcm9sbEJvZHksIHBlcmNlbnRPZlZpZXcpLFxuICAgIHNjcm9sbExvb3BlcjogU2Nyb2xsTG9vcGVyKGNvbnRlbnRTaXplLCBsaW1pdCwgb2Zmc2V0TG9jYXRpb24sIFtsb2NhdGlvbiwgb2Zmc2V0TG9jYXRpb24sIHRhcmdldF0pLFxuICAgIHNjcm9sbFByb2dyZXNzLFxuICAgIHNjcm9sbFNuYXBMaXN0OiBzY3JvbGxTbmFwcy5tYXAoc2Nyb2xsUHJvZ3Jlc3MuZ2V0KSxcbiAgICBzY3JvbGxTbmFwcyxcbiAgICBzY3JvbGxUYXJnZXQsXG4gICAgc2Nyb2xsVG8sXG4gICAgc2xpZGVMb29wZXI6IFNsaWRlTG9vcGVyKGF4aXMsIGRpcmVjdGlvbiwgdmlld1NpemUsIGNvbnRlbnRTaXplLCBzbGlkZVNpemVzLCBzbGlkZVNpemVzV2l0aEdhcHMsIHNuYXBzLCBzY3JvbGxTbmFwcywgb2Zmc2V0TG9jYXRpb24sIHNsaWRlcyksXG4gICAgc2xpZGVGb2N1cyxcbiAgICBzbGlkZXNIYW5kbGVyOiBTbGlkZXNIYW5kbGVyKGNvbnRhaW5lciwgZXZlbnRIYW5kbGVyLCB3YXRjaFNsaWRlcyksXG4gICAgc2xpZGVzSW5WaWV3LFxuICAgIHNsaWRlSW5kZXhlcyxcbiAgICBzbGlkZVJlZ2lzdHJ5LFxuICAgIHNsaWRlc1RvU2Nyb2xsLFxuICAgIHRhcmdldCxcbiAgICB0cmFuc2xhdGU6IFRyYW5zbGF0ZShheGlzLCBkaXJlY3Rpb24sIGNvbnRhaW5lcilcbiAgfTtcbiAgcmV0dXJuIGVuZ2luZTtcbn1cblxuZnVuY3Rpb24gQW5pbWF0aW9ucyhvd25lcldpbmRvdykge1xuICBjb25zdCB0aW1lU3RlcCA9IDEwMDAgLyA2MDtcbiAgbGV0IGVuZ2luZXMgPSBbXTtcbiAgbGV0IGxhc3RUaW1lU3RhbXAgPSBudWxsO1xuICBsZXQgbGFnID0gMDtcbiAgbGV0IGFuaW1hdGlvbkZyYW1lID0gMDtcbiAgZnVuY3Rpb24gYW5pbWF0ZSh0aW1lU3RhbXApIHtcbiAgICBpZiAoIWxhc3RUaW1lU3RhbXApIGxhc3RUaW1lU3RhbXAgPSB0aW1lU3RhbXA7XG4gICAgY29uc3QgZWxhcHNlZCA9IHRpbWVTdGFtcCAtIGxhc3RUaW1lU3RhbXA7XG4gICAgbGFzdFRpbWVTdGFtcCA9IHRpbWVTdGFtcDtcbiAgICBsYWcgKz0gZWxhcHNlZDtcbiAgICB3aGlsZSAobGFnID49IHRpbWVTdGVwKSB7XG4gICAgICBlbmdpbmVzLmZvckVhY2goKHtcbiAgICAgICAgYW5pbWF0aW9uXG4gICAgICB9KSA9PiBhbmltYXRpb24udXBkYXRlKCkpO1xuICAgICAgbGFnIC09IHRpbWVTdGVwO1xuICAgIH1cbiAgICBjb25zdCBsYWdPZmZzZXQgPSBtYXRoQWJzKGxhZyAvIHRpbWVTdGVwKTtcbiAgICBlbmdpbmVzLmZvckVhY2goKHtcbiAgICAgIGFuaW1hdGlvblxuICAgIH0pID0+IGFuaW1hdGlvbi5yZW5kZXIobGFnT2Zmc2V0KSk7XG4gICAgaWYgKGFuaW1hdGlvbkZyYW1lKSBvd25lcldpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XG4gIH1cbiAgZnVuY3Rpb24gc3RhcnQoZW5naW5lKSB7XG4gICAgaWYgKCFlbmdpbmVzLmluY2x1ZGVzKGVuZ2luZSkpIGVuZ2luZXMucHVzaChlbmdpbmUpO1xuICAgIGlmIChhbmltYXRpb25GcmFtZSkgcmV0dXJuO1xuICAgIGFuaW1hdGlvbkZyYW1lID0gb3duZXJXaW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHN0b3AoZW5naW5lKSB7XG4gICAgZW5naW5lcyA9IGVuZ2luZXMuZmlsdGVyKGUgPT4gZSAhPT0gZW5naW5lKTtcbiAgICBpZiAoZW5naW5lcy5sZW5ndGgpIHJldHVybjtcbiAgICBvd25lcldpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShhbmltYXRpb25GcmFtZSk7XG4gICAgbGFzdFRpbWVTdGFtcCA9IG51bGw7XG4gICAgbGFnID0gMDtcbiAgICBhbmltYXRpb25GcmFtZSA9IDA7XG4gIH1cbiAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgbGFzdFRpbWVTdGFtcCA9IG51bGw7XG4gICAgbGFnID0gMDtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIHN0YXJ0LFxuICAgIHN0b3AsXG4gICAgcmVzZXQsXG4gICAgd2luZG93OiBvd25lcldpbmRvd1xuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gRXZlbnRIYW5kbGVyKCkge1xuICBjb25zdCBsaXN0ZW5lcnMgPSB7fTtcbiAgbGV0IGFwaTtcbiAgZnVuY3Rpb24gaW5pdChlbWJsYUFwaSkge1xuICAgIGFwaSA9IGVtYmxhQXBpO1xuICB9XG4gIGZ1bmN0aW9uIGdldExpc3RlbmVycyhldnQpIHtcbiAgICByZXR1cm4gbGlzdGVuZXJzW2V2dF0gfHwgW107XG4gIH1cbiAgZnVuY3Rpb24gZW1pdChldnQpIHtcbiAgICBnZXRMaXN0ZW5lcnMoZXZ0KS5mb3JFYWNoKGUgPT4gZShhcGksIGV2dCkpO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIGZ1bmN0aW9uIG9uKGV2dCwgY2IpIHtcbiAgICBsaXN0ZW5lcnNbZXZ0XSA9IGdldExpc3RlbmVycyhldnQpLmNvbmNhdChbY2JdKTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICBmdW5jdGlvbiBvZmYoZXZ0LCBjYikge1xuICAgIGxpc3RlbmVyc1tldnRdID0gZ2V0TGlzdGVuZXJzKGV2dCkuZmlsdGVyKGUgPT4gZSAhPT0gY2IpO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgaW5pdCxcbiAgICBlbWl0LFxuICAgIG9mZixcbiAgICBvblxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGFsaWduOiAnY2VudGVyJyxcbiAgYXhpczogJ3gnLFxuICBjb250YWluZXI6IG51bGwsXG4gIHNsaWRlczogbnVsbCxcbiAgY29udGFpblNjcm9sbDogJ3RyaW1TbmFwcycsXG4gIGRpcmVjdGlvbjogJ2x0cicsXG4gIHNsaWRlc1RvU2Nyb2xsOiAxLFxuICBpblZpZXdUaHJlc2hvbGQ6IDAsXG4gIGJyZWFrcG9pbnRzOiB7fSxcbiAgZHJhZ0ZyZWU6IGZhbHNlLFxuICBkcmFnVGhyZXNob2xkOiAxMCxcbiAgbG9vcDogZmFsc2UsXG4gIHNraXBTbmFwczogZmFsc2UsXG4gIGR1cmF0aW9uOiAyNSxcbiAgc3RhcnRJbmRleDogMCxcbiAgYWN0aXZlOiB0cnVlLFxuICB3YXRjaERyYWc6IHRydWUsXG4gIHdhdGNoUmVzaXplOiB0cnVlLFxuICB3YXRjaFNsaWRlczogdHJ1ZVxufTtcblxuZnVuY3Rpb24gT3B0aW9uc0hhbmRsZXIob3duZXJXaW5kb3cpIHtcbiAgZnVuY3Rpb24gbWVyZ2VPcHRpb25zKG9wdGlvbnNBLCBvcHRpb25zQikge1xuICAgIHJldHVybiBvYmplY3RzTWVyZ2VEZWVwKG9wdGlvbnNBLCBvcHRpb25zQiB8fCB7fSk7XG4gIH1cbiAgZnVuY3Rpb24gb3B0aW9uc0F0TWVkaWEob3B0aW9ucykge1xuICAgIGNvbnN0IG9wdGlvbnNBdE1lZGlhID0gb3B0aW9ucy5icmVha3BvaW50cyB8fCB7fTtcbiAgICBjb25zdCBtYXRjaGVkTWVkaWFPcHRpb25zID0gb2JqZWN0S2V5cyhvcHRpb25zQXRNZWRpYSkuZmlsdGVyKG1lZGlhID0+IG93bmVyV2luZG93Lm1hdGNoTWVkaWEobWVkaWEpLm1hdGNoZXMpLm1hcChtZWRpYSA9PiBvcHRpb25zQXRNZWRpYVttZWRpYV0pLnJlZHVjZSgoYSwgbWVkaWFPcHRpb24pID0+IG1lcmdlT3B0aW9ucyhhLCBtZWRpYU9wdGlvbiksIHt9KTtcbiAgICByZXR1cm4gbWVyZ2VPcHRpb25zKG9wdGlvbnMsIG1hdGNoZWRNZWRpYU9wdGlvbnMpO1xuICB9XG4gIGZ1bmN0aW9uIG9wdGlvbnNNZWRpYVF1ZXJpZXMob3B0aW9uc0xpc3QpIHtcbiAgICByZXR1cm4gb3B0aW9uc0xpc3QubWFwKG9wdGlvbnMgPT4gb2JqZWN0S2V5cyhvcHRpb25zLmJyZWFrcG9pbnRzIHx8IHt9KSkucmVkdWNlKChhY2MsIG1lZGlhUXVlcmllcykgPT4gYWNjLmNvbmNhdChtZWRpYVF1ZXJpZXMpLCBbXSkubWFwKG93bmVyV2luZG93Lm1hdGNoTWVkaWEpO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgbWVyZ2VPcHRpb25zLFxuICAgIG9wdGlvbnNBdE1lZGlhLFxuICAgIG9wdGlvbnNNZWRpYVF1ZXJpZXNcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIFBsdWdpbnNIYW5kbGVyKG9wdGlvbnNIYW5kbGVyKSB7XG4gIGxldCBhY3RpdmVQbHVnaW5zID0gW107XG4gIGZ1bmN0aW9uIGluaXQoZW1ibGFBcGksIHBsdWdpbnMpIHtcbiAgICBhY3RpdmVQbHVnaW5zID0gcGx1Z2lucy5maWx0ZXIoKHtcbiAgICAgIG9wdGlvbnNcbiAgICB9KSA9PiBvcHRpb25zSGFuZGxlci5vcHRpb25zQXRNZWRpYShvcHRpb25zKS5hY3RpdmUgIT09IGZhbHNlKTtcbiAgICBhY3RpdmVQbHVnaW5zLmZvckVhY2gocGx1Z2luID0+IHBsdWdpbi5pbml0KGVtYmxhQXBpLCBvcHRpb25zSGFuZGxlcikpO1xuICAgIHJldHVybiBwbHVnaW5zLnJlZHVjZSgobWFwLCBwbHVnaW4pID0+IE9iamVjdC5hc3NpZ24obWFwLCB7XG4gICAgICBbcGx1Z2luLm5hbWVdOiBwbHVnaW5cbiAgICB9KSwge30pO1xuICB9XG4gIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgYWN0aXZlUGx1Z2lucyA9IGFjdGl2ZVBsdWdpbnMuZmlsdGVyKHBsdWdpbiA9PiBwbHVnaW4uZGVzdHJveSgpKTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGluaXQsXG4gICAgZGVzdHJveVxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gRW1ibGFDYXJvdXNlbChyb290LCB1c2VyT3B0aW9ucywgdXNlclBsdWdpbnMpIHtcbiAgY29uc3Qgb3duZXJEb2N1bWVudCA9IHJvb3Qub3duZXJEb2N1bWVudDtcbiAgY29uc3Qgb3duZXJXaW5kb3cgPSBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICBjb25zdCBvcHRpb25zSGFuZGxlciA9IE9wdGlvbnNIYW5kbGVyKG93bmVyV2luZG93KTtcbiAgY29uc3QgcGx1Z2luc0hhbmRsZXIgPSBQbHVnaW5zSGFuZGxlcihvcHRpb25zSGFuZGxlcik7XG4gIGNvbnN0IG1lZGlhSGFuZGxlcnMgPSBFdmVudFN0b3JlKCk7XG4gIGNvbnN0IGRvY3VtZW50VmlzaWJsZUhhbmRsZXIgPSBFdmVudFN0b3JlKCk7XG4gIGNvbnN0IGV2ZW50SGFuZGxlciA9IEV2ZW50SGFuZGxlcigpO1xuICBjb25zdCB7XG4gICAgYW5pbWF0aW9uUmVhbG1zXG4gIH0gPSBFbWJsYUNhcm91c2VsO1xuICBjb25zdCB7XG4gICAgbWVyZ2VPcHRpb25zLFxuICAgIG9wdGlvbnNBdE1lZGlhLFxuICAgIG9wdGlvbnNNZWRpYVF1ZXJpZXNcbiAgfSA9IG9wdGlvbnNIYW5kbGVyO1xuICBjb25zdCB7XG4gICAgb24sXG4gICAgb2ZmLFxuICAgIGVtaXRcbiAgfSA9IGV2ZW50SGFuZGxlcjtcbiAgY29uc3QgcmVJbml0ID0gcmVBY3RpdmF0ZTtcbiAgbGV0IGRlc3Ryb3llZCA9IGZhbHNlO1xuICBsZXQgZW5naW5lO1xuICBsZXQgb3B0aW9uc0Jhc2UgPSBtZXJnZU9wdGlvbnMoZGVmYXVsdE9wdGlvbnMsIEVtYmxhQ2Fyb3VzZWwuZ2xvYmFsT3B0aW9ucyk7XG4gIGxldCBvcHRpb25zID0gbWVyZ2VPcHRpb25zKG9wdGlvbnNCYXNlKTtcbiAgbGV0IHBsdWdpbkxpc3QgPSBbXTtcbiAgbGV0IHBsdWdpbkFwaXM7XG4gIGxldCBjb250YWluZXI7XG4gIGxldCBzbGlkZXM7XG4gIGZ1bmN0aW9uIHN0b3JlRWxlbWVudHMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29udGFpbmVyOiB1c2VyQ29udGFpbmVyLFxuICAgICAgc2xpZGVzOiB1c2VyU2xpZGVzXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgY3VzdG9tQ29udGFpbmVyID0gaXNTdHJpbmcodXNlckNvbnRhaW5lcikgPyByb290LnF1ZXJ5U2VsZWN0b3IodXNlckNvbnRhaW5lcikgOiB1c2VyQ29udGFpbmVyO1xuICAgIGNvbnRhaW5lciA9IGN1c3RvbUNvbnRhaW5lciB8fCByb290LmNoaWxkcmVuWzBdO1xuICAgIGNvbnN0IGN1c3RvbVNsaWRlcyA9IGlzU3RyaW5nKHVzZXJTbGlkZXMpID8gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwodXNlclNsaWRlcykgOiB1c2VyU2xpZGVzO1xuICAgIHNsaWRlcyA9IFtdLnNsaWNlLmNhbGwoY3VzdG9tU2xpZGVzIHx8IGNvbnRhaW5lci5jaGlsZHJlbik7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlRW5naW5lKG9wdGlvbnMsIGFuaW1hdGlvbnMpIHtcbiAgICBjb25zdCBlbmdpbmUgPSBFbmdpbmUocm9vdCwgY29udGFpbmVyLCBzbGlkZXMsIG93bmVyRG9jdW1lbnQsIG93bmVyV2luZG93LCBvcHRpb25zLCBldmVudEhhbmRsZXIsIGFuaW1hdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLmxvb3AgJiYgIWVuZ2luZS5zbGlkZUxvb3Blci5jYW5Mb29wKCkpIHtcbiAgICAgIGNvbnN0IG9wdGlvbnNXaXRob3V0TG9vcCA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgICAgbG9vcDogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNyZWF0ZUVuZ2luZShvcHRpb25zV2l0aG91dExvb3AsIGFuaW1hdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gZW5naW5lO1xuICB9XG4gIGZ1bmN0aW9uIGFjdGl2YXRlKHdpdGhPcHRpb25zLCB3aXRoUGx1Z2lucykge1xuICAgIGlmIChkZXN0cm95ZWQpIHJldHVybjtcbiAgICBjb25zdCBhbmltYXRpb25SZWFsbSA9IGFuaW1hdGlvblJlYWxtcy5maW5kKGEgPT4gYS53aW5kb3cgPT09IG93bmVyV2luZG93KTtcbiAgICBjb25zdCBhbmltYXRpb25zID0gYW5pbWF0aW9uUmVhbG0gfHwgQW5pbWF0aW9ucyhvd25lcldpbmRvdyk7XG4gICAgaWYgKCFhbmltYXRpb25SZWFsbSkgYW5pbWF0aW9uUmVhbG1zLnB1c2goYW5pbWF0aW9ucyk7XG4gICAgb3B0aW9uc0Jhc2UgPSBtZXJnZU9wdGlvbnMob3B0aW9uc0Jhc2UsIHdpdGhPcHRpb25zKTtcbiAgICBvcHRpb25zID0gb3B0aW9uc0F0TWVkaWEob3B0aW9uc0Jhc2UpO1xuICAgIHBsdWdpbkxpc3QgPSB3aXRoUGx1Z2lucyB8fCBwbHVnaW5MaXN0O1xuICAgIHN0b3JlRWxlbWVudHMoKTtcbiAgICBlbmdpbmUgPSBjcmVhdGVFbmdpbmUob3B0aW9ucywgYW5pbWF0aW9ucyk7XG4gICAgb3B0aW9uc01lZGlhUXVlcmllcyhbb3B0aW9uc0Jhc2UsIC4uLnBsdWdpbkxpc3QubWFwKCh7XG4gICAgICBvcHRpb25zXG4gICAgfSkgPT4gb3B0aW9ucyldKS5mb3JFYWNoKHF1ZXJ5ID0+IG1lZGlhSGFuZGxlcnMuYWRkKHF1ZXJ5LCAnY2hhbmdlJywgcmVBY3RpdmF0ZSkpO1xuICAgIGlmICghb3B0aW9ucy5hY3RpdmUpIHJldHVybjtcbiAgICBlbmdpbmUudHJhbnNsYXRlLnRvKGVuZ2luZS5sb2NhdGlvbi5nZXQoKSk7XG4gICAgZW5naW5lLnNsaWRlc0luVmlldy5pbml0KCk7XG4gICAgZW5naW5lLnNsaWRlRm9jdXMuaW5pdCgpO1xuICAgIGVuZ2luZS5ldmVudEhhbmRsZXIuaW5pdChzZWxmKTtcbiAgICBlbmdpbmUucmVzaXplSGFuZGxlci5pbml0KHNlbGYpO1xuICAgIGVuZ2luZS5zbGlkZXNIYW5kbGVyLmluaXQoc2VsZik7XG4gICAgZG9jdW1lbnRWaXNpYmxlSGFuZGxlci5hZGQob3duZXJEb2N1bWVudCwgJ3Zpc2liaWxpdHljaGFuZ2UnLCAoKSA9PiB7XG4gICAgICBpZiAob3duZXJEb2N1bWVudC5oaWRkZW4pIGFuaW1hdGlvbnMucmVzZXQoKTtcbiAgICB9KTtcbiAgICBpZiAoZW5naW5lLm9wdGlvbnMubG9vcCkgZW5naW5lLnNsaWRlTG9vcGVyLmxvb3AoKTtcbiAgICBpZiAoY29udGFpbmVyLm9mZnNldFBhcmVudCAmJiBzbGlkZXMubGVuZ3RoKSBlbmdpbmUuZHJhZ0hhbmRsZXIuaW5pdChzZWxmKTtcbiAgICBwbHVnaW5BcGlzID0gcGx1Z2luc0hhbmRsZXIuaW5pdChzZWxmLCBwbHVnaW5MaXN0KTtcbiAgfVxuICBmdW5jdGlvbiByZUFjdGl2YXRlKHdpdGhPcHRpb25zLCB3aXRoUGx1Z2lucykge1xuICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBzZWxlY3RlZFNjcm9sbFNuYXAoKTtcbiAgICBkZUFjdGl2YXRlKCk7XG4gICAgYWN0aXZhdGUobWVyZ2VPcHRpb25zKHtcbiAgICAgIHN0YXJ0SW5kZXhcbiAgICB9LCB3aXRoT3B0aW9ucyksIHdpdGhQbHVnaW5zKTtcbiAgICBldmVudEhhbmRsZXIuZW1pdCgncmVJbml0Jyk7XG4gIH1cbiAgZnVuY3Rpb24gZGVBY3RpdmF0ZSgpIHtcbiAgICBlbmdpbmUuZHJhZ0hhbmRsZXIuZGVzdHJveSgpO1xuICAgIGVuZ2luZS5hbmltYXRpb24uc3RvcCgpO1xuICAgIGVuZ2luZS5ldmVudFN0b3JlLmNsZWFyKCk7XG4gICAgZW5naW5lLnRyYW5zbGF0ZS5jbGVhcigpO1xuICAgIGVuZ2luZS5zbGlkZUxvb3Blci5jbGVhcigpO1xuICAgIGVuZ2luZS5yZXNpemVIYW5kbGVyLmRlc3Ryb3koKTtcbiAgICBlbmdpbmUuc2xpZGVzSGFuZGxlci5kZXN0cm95KCk7XG4gICAgZW5naW5lLnNsaWRlc0luVmlldy5kZXN0cm95KCk7XG4gICAgcGx1Z2luc0hhbmRsZXIuZGVzdHJveSgpO1xuICAgIG1lZGlhSGFuZGxlcnMuY2xlYXIoKTtcbiAgICBkb2N1bWVudFZpc2libGVIYW5kbGVyLmNsZWFyKCk7XG4gIH1cbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBpZiAoZGVzdHJveWVkKSByZXR1cm47XG4gICAgZGVzdHJveWVkID0gdHJ1ZTtcbiAgICBtZWRpYUhhbmRsZXJzLmNsZWFyKCk7XG4gICAgZGVBY3RpdmF0ZSgpO1xuICAgIGV2ZW50SGFuZGxlci5lbWl0KCdkZXN0cm95Jyk7XG4gIH1cbiAgZnVuY3Rpb24gc2Nyb2xsVG8oaW5kZXgsIGp1bXAsIGRpcmVjdGlvbikge1xuICAgIGlmICghb3B0aW9ucy5hY3RpdmUgfHwgZGVzdHJveWVkKSByZXR1cm47XG4gICAgZW5naW5lLnNjcm9sbEJvZHkudXNlQmFzZUZyaWN0aW9uKCkudXNlRHVyYXRpb24oanVtcCA/IDAgOiBvcHRpb25zLmR1cmF0aW9uKTtcbiAgICBlbmdpbmUuc2Nyb2xsVG8uaW5kZXgoaW5kZXgsIGRpcmVjdGlvbiB8fCAwKTtcbiAgfVxuICBmdW5jdGlvbiBzY3JvbGxOZXh0KGp1bXApIHtcbiAgICBjb25zdCBuZXh0ID0gZW5naW5lLmluZGV4LmFkZCgxKS5nZXQoKTtcbiAgICBzY3JvbGxUbyhuZXh0LCBqdW1wID09PSB0cnVlLCAtMSk7XG4gIH1cbiAgZnVuY3Rpb24gc2Nyb2xsUHJldihqdW1wKSB7XG4gICAgY29uc3QgcHJldiA9IGVuZ2luZS5pbmRleC5hZGQoLTEpLmdldCgpO1xuICAgIHNjcm9sbFRvKHByZXYsIGp1bXAgPT09IHRydWUsIDEpO1xuICB9XG4gIGZ1bmN0aW9uIGNhblNjcm9sbE5leHQoKSB7XG4gICAgY29uc3QgbmV4dCA9IGVuZ2luZS5pbmRleC5hZGQoMSkuZ2V0KCk7XG4gICAgcmV0dXJuIG5leHQgIT09IHNlbGVjdGVkU2Nyb2xsU25hcCgpO1xuICB9XG4gIGZ1bmN0aW9uIGNhblNjcm9sbFByZXYoKSB7XG4gICAgY29uc3QgcHJldiA9IGVuZ2luZS5pbmRleC5hZGQoLTEpLmdldCgpO1xuICAgIHJldHVybiBwcmV2ICE9PSBzZWxlY3RlZFNjcm9sbFNuYXAoKTtcbiAgfVxuICBmdW5jdGlvbiBzY3JvbGxTbmFwTGlzdCgpIHtcbiAgICByZXR1cm4gZW5naW5lLnNjcm9sbFNuYXBMaXN0O1xuICB9XG4gIGZ1bmN0aW9uIHNjcm9sbFByb2dyZXNzKCkge1xuICAgIHJldHVybiBlbmdpbmUuc2Nyb2xsUHJvZ3Jlc3MuZ2V0KGVuZ2luZS5sb2NhdGlvbi5nZXQoKSk7XG4gIH1cbiAgZnVuY3Rpb24gc2VsZWN0ZWRTY3JvbGxTbmFwKCkge1xuICAgIHJldHVybiBlbmdpbmUuaW5kZXguZ2V0KCk7XG4gIH1cbiAgZnVuY3Rpb24gcHJldmlvdXNTY3JvbGxTbmFwKCkge1xuICAgIHJldHVybiBlbmdpbmUuaW5kZXhQcmV2aW91cy5nZXQoKTtcbiAgfVxuICBmdW5jdGlvbiBzbGlkZXNJblZpZXcoKSB7XG4gICAgcmV0dXJuIGVuZ2luZS5zbGlkZXNJblZpZXcuZ2V0KCk7XG4gIH1cbiAgZnVuY3Rpb24gc2xpZGVzTm90SW5WaWV3KCkge1xuICAgIHJldHVybiBlbmdpbmUuc2xpZGVzSW5WaWV3LmdldChmYWxzZSk7XG4gIH1cbiAgZnVuY3Rpb24gcGx1Z2lucygpIHtcbiAgICByZXR1cm4gcGx1Z2luQXBpcztcbiAgfVxuICBmdW5jdGlvbiBpbnRlcm5hbEVuZ2luZSgpIHtcbiAgICByZXR1cm4gZW5naW5lO1xuICB9XG4gIGZ1bmN0aW9uIHJvb3ROb2RlKCkge1xuICAgIHJldHVybiByb290O1xuICB9XG4gIGZ1bmN0aW9uIGNvbnRhaW5lck5vZGUoKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfVxuICBmdW5jdGlvbiBzbGlkZU5vZGVzKCkge1xuICAgIHJldHVybiBzbGlkZXM7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBjYW5TY3JvbGxOZXh0LFxuICAgIGNhblNjcm9sbFByZXYsXG4gICAgY29udGFpbmVyTm9kZSxcbiAgICBpbnRlcm5hbEVuZ2luZSxcbiAgICBkZXN0cm95LFxuICAgIG9mZixcbiAgICBvbixcbiAgICBlbWl0LFxuICAgIHBsdWdpbnMsXG4gICAgcHJldmlvdXNTY3JvbGxTbmFwLFxuICAgIHJlSW5pdCxcbiAgICByb290Tm9kZSxcbiAgICBzY3JvbGxOZXh0LFxuICAgIHNjcm9sbFByZXYsXG4gICAgc2Nyb2xsUHJvZ3Jlc3MsXG4gICAgc2Nyb2xsU25hcExpc3QsXG4gICAgc2Nyb2xsVG8sXG4gICAgc2VsZWN0ZWRTY3JvbGxTbmFwLFxuICAgIHNsaWRlTm9kZXMsXG4gICAgc2xpZGVzSW5WaWV3LFxuICAgIHNsaWRlc05vdEluVmlld1xuICB9O1xuICBhY3RpdmF0ZSh1c2VyT3B0aW9ucywgdXNlclBsdWdpbnMpO1xuICBzZXRUaW1lb3V0KCgpID0+IGV2ZW50SGFuZGxlci5lbWl0KCdpbml0JyksIDApO1xuICByZXR1cm4gc2VsZjtcbn1cbkVtYmxhQ2Fyb3VzZWwuYW5pbWF0aW9uUmVhbG1zID0gW107XG5FbWJsYUNhcm91c2VsLmdsb2JhbE9wdGlvbnMgPSB1bmRlZmluZWQ7XG5cbmV4cG9ydCB7IEVtYmxhQ2Fyb3VzZWwgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW1ibGEtY2Fyb3VzZWwuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbImlzTnVtYmVyIiwic3ViamVjdCIsImlzU3RyaW5nIiwiaXNCb29sZWFuIiwiaXNPYmplY3QiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJtYXRoQWJzIiwibiIsIk1hdGgiLCJhYnMiLCJtYXRoU2lnbiIsInNpZ24iLCJkZWx0YUFicyIsInZhbHVlQiIsInZhbHVlQSIsImZhY3RvckFicyIsImRpZmYiLCJhcnJheUtleXMiLCJhcnJheSIsIm9iamVjdEtleXMiLCJtYXAiLCJOdW1iZXIiLCJhcnJheUxhc3QiLCJhcnJheUxhc3RJbmRleCIsIm1heCIsImxlbmd0aCIsImFycmF5SXNMYXN0SW5kZXgiLCJpbmRleCIsImFycmF5RnJvbU51bWJlciIsInN0YXJ0QXQiLCJBcnJheSIsImZyb20iLCJfIiwiaSIsIm9iamVjdCIsImtleXMiLCJvYmplY3RzTWVyZ2VEZWVwIiwib2JqZWN0QSIsIm9iamVjdEIiLCJyZWR1Y2UiLCJtZXJnZWRPYmplY3RzIiwiY3VycmVudE9iamVjdCIsImZvckVhY2giLCJrZXkiLCJhcmVPYmplY3RzIiwiaXNNb3VzZUV2ZW50IiwiZXZ0Iiwib3duZXJXaW5kb3ciLCJNb3VzZUV2ZW50IiwiQWxpZ25tZW50IiwiYWxpZ24iLCJ2aWV3U2l6ZSIsInByZWRlZmluZWQiLCJzdGFydCIsImNlbnRlciIsImVuZCIsIm1lYXN1cmUiLCJzZWxmIiwiQXhpcyIsImF4aXMiLCJkaXJlY3Rpb24iLCJzY3JvbGwiLCJjcm9zcyIsInN0YXJ0RWRnZSIsImdldFN0YXJ0RWRnZSIsImVuZEVkZ2UiLCJnZXRFbmRFZGdlIiwibWVhc3VyZVNpemUiLCJub2RlUmVjdCIsIndpZHRoIiwiaGVpZ2h0IiwiTGltaXQiLCJtaW4iLCJyZWFjaGVkTWluIiwicmVhY2hlZE1heCIsInJlYWNoZWRBbnkiLCJjb25zdHJhaW4iLCJyZW1vdmVPZmZzZXQiLCJjZWlsIiwiQ291bnRlciIsImxvb3AiLCJsb29wRW5kIiwiY291bnRlciIsIndpdGhpbkxpbWl0IiwiZ2V0Iiwic2V0IiwiYWRkIiwiY2xvbmUiLCJEaXJlY3Rpb24iLCJhcHBseSIsIkV2ZW50U3RvcmUiLCJsaXN0ZW5lcnMiLCJub2RlIiwidHlwZSIsImhhbmRsZXIiLCJvcHRpb25zIiwicGFzc2l2ZSIsInJlbW92ZUxpc3RlbmVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJsZWdhY3lNZWRpYVF1ZXJ5TGlzdCIsImFkZExpc3RlbmVyIiwicHVzaCIsImNsZWFyIiwiZmlsdGVyIiwicmVtb3ZlIiwiRHJhZ0hhbmRsZXIiLCJyb290Tm9kZSIsIm93bmVyRG9jdW1lbnQiLCJ0YXJnZXQiLCJkcmFnVHJhY2tlciIsImxvY2F0aW9uIiwiYW5pbWF0aW9uIiwic2Nyb2xsVG8iLCJzY3JvbGxCb2R5Iiwic2Nyb2xsVGFyZ2V0IiwiZXZlbnRIYW5kbGVyIiwicGVyY2VudE9mVmlldyIsImRyYWdGcmVlIiwiZHJhZ1RocmVzaG9sZCIsInNraXBTbmFwcyIsImJhc2VGcmljdGlvbiIsIndhdGNoRHJhZyIsImNyb3NzQXhpcyIsImZvY3VzTm9kZXMiLCJub25QYXNzaXZlRXZlbnQiLCJpbml0RXZlbnRzIiwiZHJhZ0V2ZW50cyIsImdvVG9OZXh0VGhyZXNob2xkIiwic25hcEZvcmNlQm9vc3QiLCJtb3VzZSIsInRvdWNoIiwiZnJlZUZvcmNlQm9vc3QiLCJiYXNlU3BlZWQiLCJpc01vdmluZyIsInN0YXJ0U2Nyb2xsIiwic3RhcnRDcm9zcyIsInBvaW50ZXJJc0Rvd24iLCJwcmV2ZW50U2Nyb2xsIiwicHJldmVudENsaWNrIiwiaXNNb3VzZSIsImluaXQiLCJlbWJsYUFwaSIsImRvd25JZkFsbG93ZWQiLCJkb3duIiwicHJldmVudERlZmF1bHQiLCJ1bmRlZmluZWQiLCJ1cCIsImNsaWNrIiwiZGVzdHJveSIsImFkZERyYWdFdmVudHMiLCJtb3ZlIiwiaXNGb2N1c05vZGUiLCJub2RlTmFtZSIsImluY2x1ZGVzIiwiZm9yY2VCb29zdCIsImJvb3N0IiwiYWxsb3dlZEZvcmNlIiwiZm9yY2UiLCJ0YXJnZXRDaGFuZ2VkIiwibmV4dCIsImJhc2VGb3JjZSIsImJ5RGlzdGFuY2UiLCJkaXN0YW5jZSIsImJ5SW5kZXgiLCJpc01vdXNlRXZ0IiwiYnV0dG9uIiwiYnV0dG9ucyIsInBvaW50ZXJEb3duIiwidXNlRnJpY3Rpb24iLCJ1c2VEdXJhdGlvbiIsInJlYWRQb2ludCIsImVtaXQiLCJsYXN0U2Nyb2xsIiwibGFzdENyb3NzIiwiZGlmZlNjcm9sbCIsImRpZmZDcm9zcyIsImNhbmNlbGFibGUiLCJwb2ludGVyTW92ZSIsImN1cnJlbnRMb2NhdGlvbiIsInJhd0ZvcmNlIiwicG9pbnRlclVwIiwiZm9yY2VGYWN0b3IiLCJzcGVlZCIsImZyaWN0aW9uIiwic3RvcFByb3BhZ2F0aW9uIiwiRHJhZ1RyYWNrZXIiLCJsb2dJbnRlcnZhbCIsInN0YXJ0RXZlbnQiLCJsYXN0RXZlbnQiLCJyZWFkVGltZSIsInRpbWVTdGFtcCIsImV2dEF4aXMiLCJwcm9wZXJ0eSIsImNvb3JkIiwidG91Y2hlcyIsImV4cGlyZWQiLCJkaWZmRHJhZyIsImRpZmZUaW1lIiwiaXNGbGljayIsIk5vZGVSZWN0cyIsIm9mZnNldFRvcCIsIm9mZnNldExlZnQiLCJvZmZzZXRXaWR0aCIsIm9mZnNldEhlaWdodCIsIm9mZnNldCIsInRvcCIsInJpZ2h0IiwiYm90dG9tIiwibGVmdCIsIlBlcmNlbnRPZlZpZXciLCJSZXNpemVIYW5kbGVyIiwiY29udGFpbmVyIiwic2xpZGVzIiwid2F0Y2hSZXNpemUiLCJub2RlUmVjdHMiLCJyZXNpemVPYnNlcnZlciIsImNvbnRhaW5lclNpemUiLCJzbGlkZVNpemVzIiwiZGVzdHJveWVkIiwicmVhZFNpemUiLCJkZWZhdWx0Q2FsbGJhY2siLCJlbnRyaWVzIiwiZW50cnkiLCJpc0NvbnRhaW5lciIsInNsaWRlSW5kZXgiLCJpbmRleE9mIiwibGFzdFNpemUiLCJuZXdTaXplIiwiZGlmZlNpemUiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJyZUluaXQiLCJSZXNpemVPYnNlcnZlciIsIm9ic2VydmVOb2RlcyIsImNvbmNhdCIsIm9ic2VydmUiLCJkaXNjb25uZWN0IiwiU2Nyb2xsQm9keSIsIm9mZnNldExvY2F0aW9uIiwiYmFzZUR1cmF0aW9uIiwiYm9keVZlbG9jaXR5Iiwic2Nyb2xsRGlyZWN0aW9uIiwic2Nyb2xsRHVyYXRpb24iLCJzY3JvbGxGcmljdGlvbiIsInJhd0xvY2F0aW9uIiwicmF3TG9jYXRpb25QcmV2aW91cyIsInNlZWsiLCJpc0luc3RhbnQiLCJkaXJlY3Rpb25EaWZmIiwic2V0dGxlZCIsImR1cmF0aW9uIiwidmVsb2NpdHkiLCJ1c2VCYXNlRHVyYXRpb24iLCJ1c2VCYXNlRnJpY3Rpb24iLCJTY3JvbGxCb3VuZHMiLCJsaW1pdCIsInB1bGxCYWNrVGhyZXNob2xkIiwiZWRnZU9mZnNldFRvbGVyYW5jZSIsImZyaWN0aW9uTGltaXQiLCJkaXNhYmxlZCIsInNob3VsZENvbnN0cmFpbiIsImVkZ2UiLCJkaWZmVG9FZGdlIiwiZGlmZlRvVGFyZ2V0Iiwic3VidHJhY3QiLCJ0b2dnbGVBY3RpdmUiLCJhY3RpdmUiLCJTY3JvbGxDb250YWluIiwiY29udGVudFNpemUiLCJzbmFwc0FsaWduZWQiLCJjb250YWluU2Nyb2xsIiwic2Nyb2xsQm91bmRzIiwic25hcHNCb3VuZGVkIiwibWVhc3VyZUJvdW5kZWQiLCJzY3JvbGxDb250YWluTGltaXQiLCJmaW5kU2Nyb2xsQ29udGFpbkxpbWl0Iiwic25hcHNDb250YWluZWQiLCJtZWFzdXJlQ29udGFpbmVkIiwic3RhcnRTbmFwIiwiZW5kU25hcCIsImxhc3RJbmRleE9mIiwic25hcEFsaWduZWQiLCJpc0ZpcnN0IiwiaXNMYXN0Iiwic2Nyb2xsQm91bmQiLCJwYXJzZUZsb2F0IiwidG9GaXhlZCIsInNsaWNlIiwiU2Nyb2xsTGltaXQiLCJzY3JvbGxTbmFwcyIsIlNjcm9sbExvb3BlciIsInZlY3RvcnMiLCJqb2ludFNhZmV0eSIsInNob3VsZExvb3AiLCJsb29wRGlzdGFuY2UiLCJ2IiwiU2Nyb2xsUHJvZ3Jlc3MiLCJTY3JvbGxTbmFwcyIsImFsaWdubWVudCIsImNvbnRhaW5lclJlY3QiLCJzbGlkZVJlY3RzIiwic2xpZGVzVG9TY3JvbGwiLCJncm91cFNsaWRlcyIsImFsaWdubWVudHMiLCJtZWFzdXJlU2l6ZXMiLCJzbmFwcyIsIm1lYXN1cmVVbmFsaWduZWQiLCJtZWFzdXJlQWxpZ25lZCIsInJlY3RzIiwicmVjdCIsInNuYXAiLCJnIiwiU2xpZGVSZWdpc3RyeSIsImNvbnRhaW5TbmFwcyIsInNsaWRlSW5kZXhlcyIsInNsaWRlUmVnaXN0cnkiLCJjcmVhdGVTbGlkZVJlZ2lzdHJ5IiwiZ3JvdXBlZFNsaWRlSW5kZXhlcyIsImRvTm90Q29udGFpbiIsImdyb3VwIiwiZ3JvdXBzIiwicmFuZ2UiLCJTY3JvbGxUYXJnZXQiLCJ0YXJnZXRWZWN0b3IiLCJtaW5EaXN0YW5jZSIsImRpc3RhbmNlcyIsInNvcnQiLCJhIiwiYiIsImZpbmRUYXJnZXRTbmFwIiwiYXNjRGlmZnNUb1NuYXBzIiwic2Nyb2xsU25hcCIsImRpZmZUb1NuYXAiLCJzaG9ydGN1dCIsImQxIiwiZDIiLCJ0YXJnZXRzIiwibWF0Y2hpbmdUYXJnZXRzIiwidCIsInRhcmdldFNuYXBEaXN0YW5jZSIsInJlYWNoZWRCb3VuZCIsInNuYXBEaXN0YW5jZSIsIlNjcm9sbFRvIiwiaW5kZXhDdXJyZW50IiwiaW5kZXhQcmV2aW91cyIsImRpc3RhbmNlRGlmZiIsImluZGV4RGlmZiIsInRhcmdldEluZGV4IiwiU2xpZGVGb2N1cyIsInJvb3QiLCJldmVudFN0b3JlIiwibGFzdFRhYlByZXNzVGltZSIsImRvY3VtZW50IiwicmVnaXN0ZXJUYWJQcmVzcyIsImFkZFNsaWRlRm9jdXNFdmVudCIsImV2ZW50IiwiY29kZSIsIkRhdGUiLCJnZXRUaW1lIiwic2xpZGUiLCJmb2N1cyIsIm5vd1RpbWUiLCJzY3JvbGxMZWZ0IiwiZmluZEluZGV4IiwiY2FwdHVyZSIsIlZlY3RvcjFEIiwiaW5pdGlhbFZhbHVlIiwidmFsdWUiLCJub3JtYWxpemVJbnB1dCIsIlRyYW5zbGF0ZSIsInRyYW5zbGF0ZSIsIngiLCJ5IiwiY29udGFpbmVyU3R5bGUiLCJzdHlsZSIsInRvIiwidHJhbnNmb3JtIiwiZ2V0QXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwiU2xpZGVMb29wZXIiLCJzbGlkZVNpemVzV2l0aEdhcHMiLCJyb3VuZGluZ1NhZmV0eSIsImFzY0l0ZW1zIiwiZGVzY0l0ZW1zIiwicmV2ZXJzZSIsImxvb3BQb2ludHMiLCJzdGFydFBvaW50cyIsImVuZFBvaW50cyIsInJlbW92ZVNsaWRlU2l6ZXMiLCJpbmRleGVzIiwic2xpZGVzSW5HYXAiLCJnYXAiLCJyZW1haW5pbmdHYXAiLCJmaW5kU2xpZGVCb3VuZHMiLCJmaW5kTG9vcFBvaW50cyIsImlzRW5kRWRnZSIsInNsaWRlQm91bmRzIiwiaW5pdGlhbCIsImFsdGVyZWQiLCJib3VuZEVkZ2UiLCJsb29wUG9pbnQiLCJzbGlkZUxvY2F0aW9uIiwiY2FuTG9vcCIsImV2ZXJ5Iiwib3RoZXJJbmRleGVzIiwic2hpZnRMb2NhdGlvbiIsIlNsaWRlc0hhbmRsZXIiLCJ3YXRjaFNsaWRlcyIsIm11dGF0aW9uT2JzZXJ2ZXIiLCJtdXRhdGlvbnMiLCJtdXRhdGlvbiIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJjaGlsZExpc3QiLCJTbGlkZXNJblZpZXciLCJ0aHJlc2hvbGQiLCJpbnRlcnNlY3Rpb25FbnRyeU1hcCIsImluVmlld0NhY2hlIiwibm90SW5WaWV3Q2FjaGUiLCJpbnRlcnNlY3Rpb25PYnNlcnZlciIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwicGFyZW50RWxlbWVudCIsImNyZWF0ZUluVmlld0xpc3QiLCJpblZpZXciLCJsaXN0IiwicGFyc2VJbnQiLCJpc0ludGVyc2VjdGluZyIsImluVmlld01hdGNoIiwibm90SW5WaWV3TWF0Y2giLCJTbGlkZVNpemVzIiwicmVhZEVkZ2VHYXAiLCJ3aXRoRWRnZUdhcCIsInN0YXJ0R2FwIiwibWVhc3VyZVN0YXJ0R2FwIiwiZW5kR2FwIiwibWVhc3VyZUVuZEdhcCIsIm1lYXN1cmVXaXRoR2FwcyIsInNsaWRlUmVjdCIsImdldENvbXB1dGVkU3R5bGUiLCJnZXRQcm9wZXJ0eVZhbHVlIiwiU2xpZGVzVG9TY3JvbGwiLCJncm91cEJ5TnVtYmVyIiwiYnlOdW1iZXIiLCJncm91cFNpemUiLCJieVNpemUiLCJyZWN0QiIsInJlY3RBIiwiZWRnZUEiLCJlZGdlQiIsImdhcEEiLCJnYXBCIiwiY2h1bmtTaXplIiwiY3VycmVudFNpemUiLCJwcmV2aW91c1NpemUiLCJFbmdpbmUiLCJhbmltYXRpb25zIiwic2Nyb2xsQXhpcyIsImNvbnRlbnREaXJlY3Rpb24iLCJzdGFydEluZGV4IiwiaW5WaWV3VGhyZXNob2xkIiwidXBkYXRlIiwiZHJhZ0hhbmRsZXIiLCJyZW5kZXIiLCJzY3JvbGxMb29wZXIiLCJzbGlkZUxvb3BlciIsImxhZ09mZnNldCIsImhhc1NldHRsZWQiLCJzdG9wIiwiZW5naW5lIiwic3RhcnRMb2NhdGlvbiIsInNjcm9sbFByb2dyZXNzIiwic2xpZGVzSW5WaWV3Iiwic2xpZGVGb2N1cyIsInJlc2l6ZUhhbmRsZXIiLCJzY3JvbGxTbmFwTGlzdCIsInNsaWRlc0hhbmRsZXIiLCJBbmltYXRpb25zIiwidGltZVN0ZXAiLCJlbmdpbmVzIiwibGFzdFRpbWVTdGFtcCIsImxhZyIsImFuaW1hdGlvbkZyYW1lIiwiYW5pbWF0ZSIsImVsYXBzZWQiLCJlIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJyZXNldCIsIndpbmRvdyIsIkV2ZW50SGFuZGxlciIsImFwaSIsImdldExpc3RlbmVycyIsIm9uIiwiY2IiLCJvZmYiLCJkZWZhdWx0T3B0aW9ucyIsImJyZWFrcG9pbnRzIiwiT3B0aW9uc0hhbmRsZXIiLCJtZXJnZU9wdGlvbnMiLCJvcHRpb25zQSIsIm9wdGlvbnNCIiwib3B0aW9uc0F0TWVkaWEiLCJtYXRjaGVkTWVkaWFPcHRpb25zIiwibWVkaWEiLCJtYXRjaE1lZGlhIiwibWF0Y2hlcyIsIm1lZGlhT3B0aW9uIiwib3B0aW9uc01lZGlhUXVlcmllcyIsIm9wdGlvbnNMaXN0IiwiYWNjIiwibWVkaWFRdWVyaWVzIiwiUGx1Z2luc0hhbmRsZXIiLCJvcHRpb25zSGFuZGxlciIsImFjdGl2ZVBsdWdpbnMiLCJwbHVnaW5zIiwicGx1Z2luIiwiYXNzaWduIiwibmFtZSIsIkVtYmxhQ2Fyb3VzZWwiLCJ1c2VyT3B0aW9ucyIsInVzZXJQbHVnaW5zIiwiZGVmYXVsdFZpZXciLCJwbHVnaW5zSGFuZGxlciIsIm1lZGlhSGFuZGxlcnMiLCJkb2N1bWVudFZpc2libGVIYW5kbGVyIiwiYW5pbWF0aW9uUmVhbG1zIiwicmVBY3RpdmF0ZSIsIm9wdGlvbnNCYXNlIiwiZ2xvYmFsT3B0aW9ucyIsInBsdWdpbkxpc3QiLCJwbHVnaW5BcGlzIiwic3RvcmVFbGVtZW50cyIsInVzZXJDb250YWluZXIiLCJ1c2VyU2xpZGVzIiwiY3VzdG9tQ29udGFpbmVyIiwicXVlcnlTZWxlY3RvciIsImNoaWxkcmVuIiwiY3VzdG9tU2xpZGVzIiwicXVlcnlTZWxlY3RvckFsbCIsImNyZWF0ZUVuZ2luZSIsIm9wdGlvbnNXaXRob3V0TG9vcCIsImFjdGl2YXRlIiwid2l0aE9wdGlvbnMiLCJ3aXRoUGx1Z2lucyIsImFuaW1hdGlvblJlYWxtIiwiZmluZCIsInF1ZXJ5IiwiaGlkZGVuIiwib2Zmc2V0UGFyZW50Iiwic2VsZWN0ZWRTY3JvbGxTbmFwIiwiZGVBY3RpdmF0ZSIsImp1bXAiLCJzY3JvbGxOZXh0Iiwic2Nyb2xsUHJldiIsInByZXYiLCJjYW5TY3JvbGxOZXh0IiwiY2FuU2Nyb2xsUHJldiIsInByZXZpb3VzU2Nyb2xsU25hcCIsInNsaWRlc05vdEluVmlldyIsImludGVybmFsRW5naW5lIiwiY29udGFpbmVyTm9kZSIsInNsaWRlTm9kZXMiLCJzZXRUaW1lb3V0IiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/embla-carousel@8.0.0-rc15/node_modules/embla-carousel/esm/embla-carousel.esm.js\n");

/***/ })

};
;