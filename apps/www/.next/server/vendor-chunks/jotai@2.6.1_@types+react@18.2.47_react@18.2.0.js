"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/jotai@2.6.1_@types+react@18.2.47_react@18.2.0";
exports.ids = ["vendor-chunks/jotai@2.6.1_@types+react@18.2.47_react@18.2.0"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/jotai@2.6.1_@types+react@18.2.47_react@18.2.0/node_modules/jotai/esm/react.mjs":
/*!***************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/jotai@2.6.1_@types+react@18.2.47_react@18.2.0/node_modules/jotai/esm/react.mjs ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Provider: () => (/* binding */ Provider),\n/* harmony export */   useAtom: () => (/* binding */ useAtom),\n/* harmony export */   useAtomValue: () => (/* binding */ useAtomValue),\n/* harmony export */   useSetAtom: () => (/* binding */ useSetAtom),\n/* harmony export */   useStore: () => (/* binding */ useStore)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/../../node_modules/.pnpm/next@14.0.4_@opentelemetry+api@1.7.0_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var jotai_vanilla__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jotai/vanilla */ \"(ssr)/../../node_modules/.pnpm/jotai@2.6.1_@types+react@18.2.47_react@18.2.0/node_modules/jotai/esm/vanilla.mjs\");\n/* __next_internal_client_entry_do_not_use__ Provider,useAtom,useAtomValue,useSetAtom,useStore auto */ \n\nconst StoreContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(void 0);\nconst useStore = (options)=>{\n    const store = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(StoreContext);\n    return (options == null ? void 0 : options.store) || store || (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_1__.getDefaultStore)();\n};\nconst Provider = ({ children, store })=>{\n    const storeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    if (!store && !storeRef.current) {\n        storeRef.current = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_1__.createStore)();\n    }\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(StoreContext.Provider, {\n        value: store || storeRef.current\n    }, children);\n};\nconst isPromiseLike = (x)=>typeof (x == null ? void 0 : x.then) === \"function\";\nconst use = (react__WEBPACK_IMPORTED_MODULE_0___default().use) || ((promise)=>{\n    if (promise.status === \"pending\") {\n        throw promise;\n    } else if (promise.status === \"fulfilled\") {\n        return promise.value;\n    } else if (promise.status === \"rejected\") {\n        throw promise.reason;\n    } else {\n        promise.status = \"pending\";\n        promise.then((v)=>{\n            promise.status = \"fulfilled\";\n            promise.value = v;\n        }, (e)=>{\n            promise.status = \"rejected\";\n            promise.reason = e;\n        });\n        throw promise;\n    }\n});\nfunction useAtomValue(atom, options) {\n    const store = useStore(options);\n    const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)((prev)=>{\n        const nextValue = store.get(atom);\n        if (Object.is(prev[0], nextValue) && prev[1] === store && prev[2] === atom) {\n            return prev;\n        }\n        return [\n            nextValue,\n            store,\n            atom\n        ];\n    }, void 0, ()=>[\n            store.get(atom),\n            store,\n            atom\n        ]);\n    let value = valueFromReducer;\n    if (storeFromReducer !== store || atomFromReducer !== atom) {\n        rerender();\n        value = store.get(atom);\n    }\n    const delay = options == null ? void 0 : options.delay;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const unsub = store.sub(atom, ()=>{\n            if (typeof delay === \"number\") {\n                setTimeout(rerender, delay);\n                return;\n            }\n            rerender();\n        });\n        rerender();\n        return unsub;\n    }, [\n        store,\n        atom,\n        delay\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(value);\n    return isPromiseLike(value) ? use(value) : value;\n}\nfunction useSetAtom(atom, options) {\n    const store = useStore(options);\n    const setAtom = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((...args)=>{\n        if (( false ? 0 : void 0) !== \"production\" && !(\"write\" in atom)) {\n            throw new Error(\"not writable atom\");\n        }\n        return store.set(atom, ...args);\n    }, [\n        store,\n        atom\n    ]);\n    return setAtom;\n}\nfunction useAtom(atom, options) {\n    return [\n        useAtomValue(atom, options),\n        // We do wrong type assertion here, which results in throwing an error.\n        useSetAtom(atom, options)\n    ];\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2pvdGFpQDIuNi4xX0B0eXBlcytyZWFjdEAxOC4yLjQ3X3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvam90YWkvZXNtL3JlYWN0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozt1R0FDMEk7QUFDN0U7QUFFN0QsTUFBTVcsNkJBQWVWLG9EQUFhQSxDQUFDLEtBQUs7QUFDeEMsTUFBTVcsV0FBVyxDQUFDQztJQUNoQixNQUFNQyxRQUFRWixpREFBVUEsQ0FBQ1M7SUFDekIsT0FBTyxDQUFDRSxXQUFXLE9BQU8sS0FBSyxJQUFJQSxRQUFRQyxLQUFLLEtBQUtBLFNBQVNMLDhEQUFlQTtBQUMvRTtBQUNBLE1BQU1NLFdBQVcsQ0FBQyxFQUNoQkMsUUFBUSxFQUNSRixLQUFLLEVBQ047SUFDQyxNQUFNRyxXQUFXZCw2Q0FBTUE7SUFDdkIsSUFBSSxDQUFDVyxTQUFTLENBQUNHLFNBQVNDLE9BQU8sRUFBRTtRQUMvQkQsU0FBU0MsT0FBTyxHQUFHUiwwREFBV0E7SUFDaEM7SUFDQSxxQkFBT04sb0RBQWFBLENBQ2xCTyxhQUFhSSxRQUFRLEVBQ3JCO1FBQ0VJLE9BQU9MLFNBQVNHLFNBQVNDLE9BQU87SUFDbEMsR0FDQUY7QUFFSjtBQUVBLE1BQU1JLGdCQUFnQixDQUFDQyxJQUFNLE9BQVFBLENBQUFBLEtBQUssT0FBTyxLQUFLLElBQUlBLEVBQUVDLElBQUksTUFBTTtBQUN0RSxNQUFNQyxNQUFNdkIsa0RBQWdCLElBQUssRUFBQ3dCO0lBQ2hDLElBQUlBLFFBQVFDLE1BQU0sS0FBSyxXQUFXO1FBQ2hDLE1BQU1EO0lBQ1IsT0FBTyxJQUFJQSxRQUFRQyxNQUFNLEtBQUssYUFBYTtRQUN6QyxPQUFPRCxRQUFRTCxLQUFLO0lBQ3RCLE9BQU8sSUFBSUssUUFBUUMsTUFBTSxLQUFLLFlBQVk7UUFDeEMsTUFBTUQsUUFBUUUsTUFBTTtJQUN0QixPQUFPO1FBQ0xGLFFBQVFDLE1BQU0sR0FBRztRQUNqQkQsUUFBUUYsSUFBSSxDQUNWLENBQUNLO1lBQ0NILFFBQVFDLE1BQU0sR0FBRztZQUNqQkQsUUFBUUwsS0FBSyxHQUFHUTtRQUNsQixHQUNBLENBQUNDO1lBQ0NKLFFBQVFDLE1BQU0sR0FBRztZQUNqQkQsUUFBUUUsTUFBTSxHQUFHRTtRQUNuQjtRQUVGLE1BQU1KO0lBQ1I7QUFDRjtBQUNBLFNBQVNLLGFBQWFDLElBQUksRUFBRWpCLE9BQU87SUFDakMsTUFBTUMsUUFBUUYsU0FBU0M7SUFDdkIsTUFBTSxDQUFDLENBQUNrQixrQkFBa0JDLGtCQUFrQkMsZ0JBQWdCLEVBQUVDLFNBQVMsR0FBRzdCLGlEQUFVQSxDQUNsRixDQUFDOEI7UUFDQyxNQUFNQyxZQUFZdEIsTUFBTXVCLEdBQUcsQ0FBQ1A7UUFDNUIsSUFBSVEsT0FBT0MsRUFBRSxDQUFDSixJQUFJLENBQUMsRUFBRSxFQUFFQyxjQUFjRCxJQUFJLENBQUMsRUFBRSxLQUFLckIsU0FBU3FCLElBQUksQ0FBQyxFQUFFLEtBQUtMLE1BQU07WUFDMUUsT0FBT0s7UUFDVDtRQUNBLE9BQU87WUFBQ0M7WUFBV3RCO1lBQU9nQjtTQUFLO0lBQ2pDLEdBQ0EsS0FBSyxHQUNMLElBQU07WUFBQ2hCLE1BQU11QixHQUFHLENBQUNQO1lBQU9oQjtZQUFPZ0I7U0FBSztJQUV0QyxJQUFJWCxRQUFRWTtJQUNaLElBQUlDLHFCQUFxQmxCLFNBQVNtQixvQkFBb0JILE1BQU07UUFDMURJO1FBQ0FmLFFBQVFMLE1BQU11QixHQUFHLENBQUNQO0lBQ3BCO0lBQ0EsTUFBTVUsUUFBUTNCLFdBQVcsT0FBTyxLQUFLLElBQUlBLFFBQVEyQixLQUFLO0lBQ3REbEMsZ0RBQVNBLENBQUM7UUFDUixNQUFNbUMsUUFBUTNCLE1BQU00QixHQUFHLENBQUNaLE1BQU07WUFDNUIsSUFBSSxPQUFPVSxVQUFVLFVBQVU7Z0JBQzdCRyxXQUFXVCxVQUFVTTtnQkFDckI7WUFDRjtZQUNBTjtRQUNGO1FBQ0FBO1FBQ0EsT0FBT087SUFDVCxHQUFHO1FBQUMzQjtRQUFPZ0I7UUFBTVU7S0FBTTtJQUN2QmpDLG9EQUFhQSxDQUFDWTtJQUNkLE9BQU9DLGNBQWNELFNBQVNJLElBQUlKLFNBQVNBO0FBQzdDO0FBRUEsU0FBU3lCLFdBQVdkLElBQUksRUFBRWpCLE9BQU87SUFDL0IsTUFBTUMsUUFBUUYsU0FBU0M7SUFDdkIsTUFBTWdDLFVBQVVyQyxrREFBV0EsQ0FDekIsQ0FBQyxHQUFHc0M7UUFDRixJQUFJLENBQUMsTUFBZSxHQUFHLENBQW9CLEdBQUcsS0FBSyxPQUFPLGdCQUFnQixDQUFFLFlBQVdoQixJQUFHLEdBQUk7WUFDNUYsTUFBTSxJQUFJbUIsTUFBTTtRQUNsQjtRQUNBLE9BQU9uQyxNQUFNb0MsR0FBRyxDQUFDcEIsU0FBU2dCO0lBQzVCLEdBQ0E7UUFBQ2hDO1FBQU9nQjtLQUFLO0lBRWYsT0FBT2U7QUFDVDtBQUVBLFNBQVNNLFFBQVFyQixJQUFJLEVBQUVqQixPQUFPO0lBQzVCLE9BQU87UUFDTGdCLGFBQWFDLE1BQU1qQjtRQUNuQix1RUFBdUU7UUFDdkUrQixXQUFXZCxNQUFNakI7S0FDbEI7QUFDSDtBQUVpRSIsInNvdXJjZXMiOlsid2VicGFjazovL2hhd2EtZG9jcy8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vam90YWlAMi42LjFfQHR5cGVzK3JlYWN0QDE4LjIuNDdfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9qb3RhaS9lc20vcmVhY3QubWpzP2MwM2QiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuaW1wb3J0IFJlYWN0RXhwb3J0cywgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VSZWYsIGNyZWF0ZUVsZW1lbnQsIHVzZVJlZHVjZXIsIHVzZUVmZmVjdCwgdXNlRGVidWdWYWx1ZSwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBnZXREZWZhdWx0U3RvcmUsIGNyZWF0ZVN0b3JlIH0gZnJvbSAnam90YWkvdmFuaWxsYSc7XG5cbmNvbnN0IFN0b3JlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQodm9pZCAwKTtcbmNvbnN0IHVzZVN0b3JlID0gKG9wdGlvbnMpID0+IHtcbiAgY29uc3Qgc3RvcmUgPSB1c2VDb250ZXh0KFN0b3JlQ29udGV4dCk7XG4gIHJldHVybiAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5zdG9yZSkgfHwgc3RvcmUgfHwgZ2V0RGVmYXVsdFN0b3JlKCk7XG59O1xuY29uc3QgUHJvdmlkZXIgPSAoe1xuICBjaGlsZHJlbixcbiAgc3RvcmVcbn0pID0+IHtcbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VSZWYoKTtcbiAgaWYgKCFzdG9yZSAmJiAhc3RvcmVSZWYuY3VycmVudCkge1xuICAgIHN0b3JlUmVmLmN1cnJlbnQgPSBjcmVhdGVTdG9yZSgpO1xuICB9XG4gIHJldHVybiBjcmVhdGVFbGVtZW50KFxuICAgIFN0b3JlQ29udGV4dC5Qcm92aWRlcixcbiAgICB7XG4gICAgICB2YWx1ZTogc3RvcmUgfHwgc3RvcmVSZWYuY3VycmVudFxuICAgIH0sXG4gICAgY2hpbGRyZW5cbiAgKTtcbn07XG5cbmNvbnN0IGlzUHJvbWlzZUxpa2UgPSAoeCkgPT4gdHlwZW9mICh4ID09IG51bGwgPyB2b2lkIDAgOiB4LnRoZW4pID09PSBcImZ1bmN0aW9uXCI7XG5jb25zdCB1c2UgPSBSZWFjdEV4cG9ydHMudXNlIHx8ICgocHJvbWlzZSkgPT4ge1xuICBpZiAocHJvbWlzZS5zdGF0dXMgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgdGhyb3cgcHJvbWlzZTtcbiAgfSBlbHNlIGlmIChwcm9taXNlLnN0YXR1cyA9PT0gXCJmdWxmaWxsZWRcIikge1xuICAgIHJldHVybiBwcm9taXNlLnZhbHVlO1xuICB9IGVsc2UgaWYgKHByb21pc2Uuc3RhdHVzID09PSBcInJlamVjdGVkXCIpIHtcbiAgICB0aHJvdyBwcm9taXNlLnJlYXNvbjtcbiAgfSBlbHNlIHtcbiAgICBwcm9taXNlLnN0YXR1cyA9IFwicGVuZGluZ1wiO1xuICAgIHByb21pc2UudGhlbihcbiAgICAgICh2KSA9PiB7XG4gICAgICAgIHByb21pc2Uuc3RhdHVzID0gXCJmdWxmaWxsZWRcIjtcbiAgICAgICAgcHJvbWlzZS52YWx1ZSA9IHY7XG4gICAgICB9LFxuICAgICAgKGUpID0+IHtcbiAgICAgICAgcHJvbWlzZS5zdGF0dXMgPSBcInJlamVjdGVkXCI7XG4gICAgICAgIHByb21pc2UucmVhc29uID0gZTtcbiAgICAgIH1cbiAgICApO1xuICAgIHRocm93IHByb21pc2U7XG4gIH1cbn0pO1xuZnVuY3Rpb24gdXNlQXRvbVZhbHVlKGF0b20sIG9wdGlvbnMpIHtcbiAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZShvcHRpb25zKTtcbiAgY29uc3QgW1t2YWx1ZUZyb21SZWR1Y2VyLCBzdG9yZUZyb21SZWR1Y2VyLCBhdG9tRnJvbVJlZHVjZXJdLCByZXJlbmRlcl0gPSB1c2VSZWR1Y2VyKFxuICAgIChwcmV2KSA9PiB7XG4gICAgICBjb25zdCBuZXh0VmFsdWUgPSBzdG9yZS5nZXQoYXRvbSk7XG4gICAgICBpZiAoT2JqZWN0LmlzKHByZXZbMF0sIG5leHRWYWx1ZSkgJiYgcHJldlsxXSA9PT0gc3RvcmUgJiYgcHJldlsyXSA9PT0gYXRvbSkge1xuICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbbmV4dFZhbHVlLCBzdG9yZSwgYXRvbV07XG4gICAgfSxcbiAgICB2b2lkIDAsXG4gICAgKCkgPT4gW3N0b3JlLmdldChhdG9tKSwgc3RvcmUsIGF0b21dXG4gICk7XG4gIGxldCB2YWx1ZSA9IHZhbHVlRnJvbVJlZHVjZXI7XG4gIGlmIChzdG9yZUZyb21SZWR1Y2VyICE9PSBzdG9yZSB8fCBhdG9tRnJvbVJlZHVjZXIgIT09IGF0b20pIHtcbiAgICByZXJlbmRlcigpO1xuICAgIHZhbHVlID0gc3RvcmUuZ2V0KGF0b20pO1xuICB9XG4gIGNvbnN0IGRlbGF5ID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5kZWxheTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCB1bnN1YiA9IHN0b3JlLnN1YihhdG9tLCAoKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGRlbGF5ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHNldFRpbWVvdXQocmVyZW5kZXIsIGRlbGF5KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVyZW5kZXIoKTtcbiAgICB9KTtcbiAgICByZXJlbmRlcigpO1xuICAgIHJldHVybiB1bnN1YjtcbiAgfSwgW3N0b3JlLCBhdG9tLCBkZWxheV0pO1xuICB1c2VEZWJ1Z1ZhbHVlKHZhbHVlKTtcbiAgcmV0dXJuIGlzUHJvbWlzZUxpa2UodmFsdWUpID8gdXNlKHZhbHVlKSA6IHZhbHVlO1xufVxuXG5mdW5jdGlvbiB1c2VTZXRBdG9tKGF0b20sIG9wdGlvbnMpIHtcbiAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZShvcHRpb25zKTtcbiAgY29uc3Qgc2V0QXRvbSA9IHVzZUNhbGxiYWNrKFxuICAgICguLi5hcmdzKSA9PiB7XG4gICAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIShcIndyaXRlXCIgaW4gYXRvbSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IHdyaXRhYmxlIGF0b21cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RvcmUuc2V0KGF0b20sIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgW3N0b3JlLCBhdG9tXVxuICApO1xuICByZXR1cm4gc2V0QXRvbTtcbn1cblxuZnVuY3Rpb24gdXNlQXRvbShhdG9tLCBvcHRpb25zKSB7XG4gIHJldHVybiBbXG4gICAgdXNlQXRvbVZhbHVlKGF0b20sIG9wdGlvbnMpLFxuICAgIC8vIFdlIGRvIHdyb25nIHR5cGUgYXNzZXJ0aW9uIGhlcmUsIHdoaWNoIHJlc3VsdHMgaW4gdGhyb3dpbmcgYW4gZXJyb3IuXG4gICAgdXNlU2V0QXRvbShhdG9tLCBvcHRpb25zKVxuICBdO1xufVxuXG5leHBvcnQgeyBQcm92aWRlciwgdXNlQXRvbSwgdXNlQXRvbVZhbHVlLCB1c2VTZXRBdG9tLCB1c2VTdG9yZSB9O1xuIl0sIm5hbWVzIjpbIlJlYWN0RXhwb3J0cyIsImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlUmVmIiwiY3JlYXRlRWxlbWVudCIsInVzZVJlZHVjZXIiLCJ1c2VFZmZlY3QiLCJ1c2VEZWJ1Z1ZhbHVlIiwidXNlQ2FsbGJhY2siLCJnZXREZWZhdWx0U3RvcmUiLCJjcmVhdGVTdG9yZSIsIlN0b3JlQ29udGV4dCIsInVzZVN0b3JlIiwib3B0aW9ucyIsInN0b3JlIiwiUHJvdmlkZXIiLCJjaGlsZHJlbiIsInN0b3JlUmVmIiwiY3VycmVudCIsInZhbHVlIiwiaXNQcm9taXNlTGlrZSIsIngiLCJ0aGVuIiwidXNlIiwicHJvbWlzZSIsInN0YXR1cyIsInJlYXNvbiIsInYiLCJlIiwidXNlQXRvbVZhbHVlIiwiYXRvbSIsInZhbHVlRnJvbVJlZHVjZXIiLCJzdG9yZUZyb21SZWR1Y2VyIiwiYXRvbUZyb21SZWR1Y2VyIiwicmVyZW5kZXIiLCJwcmV2IiwibmV4dFZhbHVlIiwiZ2V0IiwiT2JqZWN0IiwiaXMiLCJkZWxheSIsInVuc3ViIiwic3ViIiwic2V0VGltZW91dCIsInVzZVNldEF0b20iLCJzZXRBdG9tIiwiYXJncyIsImVudiIsIk1PREUiLCJFcnJvciIsInNldCIsInVzZUF0b20iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/jotai@2.6.1_@types+react@18.2.47_react@18.2.0/node_modules/jotai/esm/react.mjs\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/jotai@2.6.1_@types+react@18.2.47_react@18.2.0/node_modules/jotai/esm/vanilla.mjs":
/*!*****************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/jotai@2.6.1_@types+react@18.2.47_react@18.2.0/node_modules/jotai/esm/vanilla.mjs ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   atom: () => (/* binding */ atom),\n/* harmony export */   createStore: () => (/* binding */ createStore),\n/* harmony export */   getDefaultStore: () => (/* binding */ getDefaultStore)\n/* harmony export */ });\nlet keyCount = 0;\nfunction atom(read, write) {\n    const key = `atom${++keyCount}`;\n    const config = {\n        toString: ()=>key\n    };\n    if (typeof read === \"function\") {\n        config.read = read;\n    } else {\n        config.init = read;\n        config.read = function(get) {\n            return get(this);\n        };\n        config.write = function(get, set, arg) {\n            return set(this, typeof arg === \"function\" ? arg(get(this)) : arg);\n        };\n    }\n    if (write) {\n        config.write = write;\n    }\n    return config;\n}\nconst hasInitialValue = (atom)=>\"init\" in atom;\nconst isActuallyWritableAtom = (atom)=>!!atom.write;\nconst cancelPromiseMap = /* @__PURE__ */ new WeakMap();\nconst registerCancelPromise = (promise, cancel)=>{\n    cancelPromiseMap.set(promise, cancel);\n    promise.catch(()=>{}).finally(()=>cancelPromiseMap.delete(promise));\n};\nconst cancelPromise = (promise, next)=>{\n    const cancel = cancelPromiseMap.get(promise);\n    if (cancel) {\n        cancelPromiseMap.delete(promise);\n        cancel(next);\n    }\n};\nconst resolvePromise = (promise, value)=>{\n    promise.status = \"fulfilled\";\n    promise.value = value;\n};\nconst rejectPromise = (promise, e)=>{\n    promise.status = \"rejected\";\n    promise.reason = e;\n};\nconst isPromiseLike = (x)=>typeof (x == null ? void 0 : x.then) === \"function\";\nconst isEqualAtomValue = (a, b)=>!!a && \"v\" in a && \"v\" in b && Object.is(a.v, b.v);\nconst isEqualAtomError = (a, b)=>!!a && \"e\" in a && \"e\" in b && Object.is(a.e, b.e);\nconst hasPromiseAtomValue = (a)=>!!a && \"v\" in a && a.v instanceof Promise;\nconst isEqualPromiseAtomValue = (a, b)=>\"v\" in a && \"v\" in b && a.v.orig && a.v.orig === b.v.orig;\nconst returnAtomValue = (atomState)=>{\n    if (\"e\" in atomState) {\n        throw atomState.e;\n    }\n    return atomState.v;\n};\nconst createStore = ()=>{\n    const atomStateMap = /* @__PURE__ */ new WeakMap();\n    const mountedMap = /* @__PURE__ */ new WeakMap();\n    const pendingMap = /* @__PURE__ */ new Map();\n    let storeListenersRev2;\n    let mountedAtoms;\n    if (( false ? 0 : void 0) !== \"production\") {\n        storeListenersRev2 = /* @__PURE__ */ new Set();\n        mountedAtoms = /* @__PURE__ */ new Set();\n    }\n    const getAtomState = (atom)=>atomStateMap.get(atom);\n    const setAtomState = (atom, atomState)=>{\n        if (( false ? 0 : void 0) !== \"production\") {\n            Object.freeze(atomState);\n        }\n        const prevAtomState = atomStateMap.get(atom);\n        atomStateMap.set(atom, atomState);\n        if (!pendingMap.has(atom)) {\n            pendingMap.set(atom, prevAtomState);\n        }\n        if (hasPromiseAtomValue(prevAtomState)) {\n            const next = \"v\" in atomState ? atomState.v instanceof Promise ? atomState.v : Promise.resolve(atomState.v) : Promise.reject(atomState.e);\n            if (prevAtomState.v !== next) {\n                cancelPromise(prevAtomState.v, next);\n            }\n        }\n    };\n    const updateDependencies = (atom, nextAtomState, nextDependencies)=>{\n        const dependencies = /* @__PURE__ */ new Map();\n        let changed = false;\n        nextDependencies.forEach((aState, a)=>{\n            if (!aState && a === atom) {\n                aState = nextAtomState;\n            }\n            if (aState) {\n                dependencies.set(a, aState);\n                if (nextAtomState.d.get(a) !== aState) {\n                    changed = true;\n                }\n            } else if (( false ? 0 : void 0) !== \"production\") {\n                console.warn(\"[Bug] atom state not found\");\n            }\n        });\n        if (changed || nextAtomState.d.size !== dependencies.size) {\n            nextAtomState.d = dependencies;\n        }\n    };\n    const setAtomValue = (atom, value, nextDependencies)=>{\n        const prevAtomState = getAtomState(atom);\n        const nextAtomState = {\n            d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n            v: value\n        };\n        if (nextDependencies) {\n            updateDependencies(atom, nextAtomState, nextDependencies);\n        }\n        if (isEqualAtomValue(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n            return prevAtomState;\n        }\n        if (hasPromiseAtomValue(prevAtomState) && hasPromiseAtomValue(nextAtomState) && isEqualPromiseAtomValue(prevAtomState, nextAtomState)) {\n            if (prevAtomState.d === nextAtomState.d) {\n                return prevAtomState;\n            } else {\n                nextAtomState.v = prevAtomState.v;\n            }\n        }\n        setAtomState(atom, nextAtomState);\n        return nextAtomState;\n    };\n    const setAtomValueOrPromise = (atom, valueOrPromise, nextDependencies, abortPromise)=>{\n        if (isPromiseLike(valueOrPromise)) {\n            let continuePromise;\n            const updatePromiseDependencies = ()=>{\n                const prevAtomState = getAtomState(atom);\n                if (!hasPromiseAtomValue(prevAtomState) || prevAtomState.v !== promise) {\n                    return;\n                }\n                const nextAtomState = setAtomValue(atom, promise, nextDependencies);\n                if (mountedMap.has(atom) && prevAtomState.d !== nextAtomState.d) {\n                    mountDependencies(atom, nextAtomState, prevAtomState.d);\n                }\n            };\n            const promise = new Promise((resolve, reject)=>{\n                let settled = false;\n                valueOrPromise.then((v)=>{\n                    if (!settled) {\n                        settled = true;\n                        resolvePromise(promise, v);\n                        resolve(v);\n                        updatePromiseDependencies();\n                    }\n                }, (e)=>{\n                    if (!settled) {\n                        settled = true;\n                        rejectPromise(promise, e);\n                        reject(e);\n                        updatePromiseDependencies();\n                    }\n                });\n                continuePromise = (next)=>{\n                    if (!settled) {\n                        settled = true;\n                        next.then((v)=>resolvePromise(promise, v), (e)=>rejectPromise(promise, e));\n                        resolve(next);\n                    }\n                };\n            });\n            promise.orig = valueOrPromise;\n            promise.status = \"pending\";\n            registerCancelPromise(promise, (next)=>{\n                if (next) {\n                    continuePromise(next);\n                }\n                abortPromise == null ? void 0 : abortPromise();\n            });\n            return setAtomValue(atom, promise, nextDependencies);\n        }\n        return setAtomValue(atom, valueOrPromise, nextDependencies);\n    };\n    const setAtomError = (atom, error, nextDependencies)=>{\n        const prevAtomState = getAtomState(atom);\n        const nextAtomState = {\n            d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n            e: error\n        };\n        if (nextDependencies) {\n            updateDependencies(atom, nextAtomState, nextDependencies);\n        }\n        if (isEqualAtomError(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n            return prevAtomState;\n        }\n        setAtomState(atom, nextAtomState);\n        return nextAtomState;\n    };\n    const readAtomState = (atom, force)=>{\n        const atomState = getAtomState(atom);\n        if (!force && atomState) {\n            if (mountedMap.has(atom)) {\n                return atomState;\n            }\n            if (Array.from(atomState.d).every(([a, s])=>{\n                if (a === atom) {\n                    return true;\n                }\n                const aState = readAtomState(a);\n                return aState === s || isEqualAtomValue(aState, s);\n            })) {\n                return atomState;\n            }\n        }\n        const nextDependencies = /* @__PURE__ */ new Map();\n        let isSync = true;\n        const getter = (a)=>{\n            if (a === atom) {\n                const aState2 = getAtomState(a);\n                if (aState2) {\n                    nextDependencies.set(a, aState2);\n                    return returnAtomValue(aState2);\n                }\n                if (hasInitialValue(a)) {\n                    nextDependencies.set(a, void 0);\n                    return a.init;\n                }\n                throw new Error(\"no atom init\");\n            }\n            const aState = readAtomState(a);\n            nextDependencies.set(a, aState);\n            return returnAtomValue(aState);\n        };\n        let controller;\n        let setSelf;\n        const options = {\n            get signal () {\n                if (!controller) {\n                    controller = new AbortController();\n                }\n                return controller.signal;\n            },\n            get setSelf () {\n                if (( false ? 0 : void 0) !== \"production\" && !isActuallyWritableAtom(atom)) {\n                    console.warn(\"setSelf function cannot be used with read-only atom\");\n                }\n                if (!setSelf && isActuallyWritableAtom(atom)) {\n                    setSelf = (...args)=>{\n                        if (( false ? 0 : void 0) !== \"production\" && isSync) {\n                            console.warn(\"setSelf function cannot be called in sync\");\n                        }\n                        if (!isSync) {\n                            return writeAtom(atom, ...args);\n                        }\n                    };\n                }\n                return setSelf;\n            }\n        };\n        try {\n            const valueOrPromise = atom.read(getter, options);\n            return setAtomValueOrPromise(atom, valueOrPromise, nextDependencies, ()=>controller == null ? void 0 : controller.abort());\n        } catch (error) {\n            return setAtomError(atom, error, nextDependencies);\n        } finally{\n            isSync = false;\n        }\n    };\n    const readAtom = (atom)=>returnAtomValue(readAtomState(atom));\n    const addAtom = (atom)=>{\n        let mounted = mountedMap.get(atom);\n        if (!mounted) {\n            mounted = mountAtom(atom);\n        }\n        return mounted;\n    };\n    const canUnmountAtom = (atom, mounted)=>!mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n    const delAtom = (atom)=>{\n        const mounted = mountedMap.get(atom);\n        if (mounted && canUnmountAtom(atom, mounted)) {\n            unmountAtom(atom);\n        }\n    };\n    const recomputeDependents = (atom)=>{\n        const dependencyMap = /* @__PURE__ */ new Map();\n        const dirtyMap = /* @__PURE__ */ new WeakMap();\n        const getDependents = (a)=>{\n            var _a;\n            const dependents = new Set((_a = mountedMap.get(a)) == null ? void 0 : _a.t);\n            pendingMap.forEach((_, pendingAtom)=>{\n                var _a2;\n                if ((_a2 = getAtomState(pendingAtom)) == null ? void 0 : _a2.d.has(a)) {\n                    dependents.add(pendingAtom);\n                }\n            });\n            return dependents;\n        };\n        const loop1 = (a)=>{\n            getDependents(a).forEach((dependent)=>{\n                if (dependent !== a) {\n                    dependencyMap.set(dependent, (dependencyMap.get(dependent) || /* @__PURE__ */ new Set()).add(a));\n                    dirtyMap.set(dependent, (dirtyMap.get(dependent) || 0) + 1);\n                    loop1(dependent);\n                }\n            });\n        };\n        loop1(atom);\n        const loop2 = (a)=>{\n            getDependents(a).forEach((dependent)=>{\n                var _a;\n                if (dependent !== a) {\n                    let dirtyCount = dirtyMap.get(dependent);\n                    if (dirtyCount) {\n                        dirtyMap.set(dependent, --dirtyCount);\n                    }\n                    if (!dirtyCount) {\n                        let isChanged = !!((_a = dependencyMap.get(dependent)) == null ? void 0 : _a.size);\n                        if (isChanged) {\n                            const prevAtomState = getAtomState(dependent);\n                            const nextAtomState = readAtomState(dependent, true);\n                            isChanged = !isEqualAtomValue(prevAtomState, nextAtomState);\n                        }\n                        if (!isChanged) {\n                            dependencyMap.forEach((s)=>s.delete(dependent));\n                        }\n                    }\n                    loop2(dependent);\n                }\n            });\n        };\n        loop2(atom);\n    };\n    const writeAtomState = (atom, ...args)=>{\n        let isSync = true;\n        const getter = (a)=>returnAtomValue(readAtomState(a));\n        const setter = (a, ...args2)=>{\n            let r;\n            if (a === atom) {\n                if (!hasInitialValue(a)) {\n                    throw new Error(\"atom not writable\");\n                }\n                const prevAtomState = getAtomState(a);\n                const nextAtomState = setAtomValueOrPromise(a, args2[0]);\n                if (!isEqualAtomValue(prevAtomState, nextAtomState)) {\n                    recomputeDependents(a);\n                }\n            } else {\n                r = writeAtomState(a, ...args2);\n            }\n            if (!isSync) {\n                const flushed = flushPending();\n                if (( false ? 0 : void 0) !== \"production\") {\n                    storeListenersRev2.forEach((l)=>l({\n                            type: \"async-write\",\n                            flushed\n                        }));\n                }\n            }\n            return r;\n        };\n        const result = atom.write(getter, setter, ...args);\n        isSync = false;\n        return result;\n    };\n    const writeAtom = (atom, ...args)=>{\n        const result = writeAtomState(atom, ...args);\n        const flushed = flushPending();\n        if (( false ? 0 : void 0) !== \"production\") {\n            storeListenersRev2.forEach((l)=>l({\n                    type: \"write\",\n                    flushed\n                }));\n        }\n        return result;\n    };\n    const mountAtom = (atom, initialDependent, onMountQueue)=>{\n        var _a;\n        const queue = onMountQueue || [];\n        (_a = getAtomState(atom)) == null ? void 0 : _a.d.forEach((_, a)=>{\n            const aMounted = mountedMap.get(a);\n            if (aMounted) {\n                aMounted.t.add(atom);\n            } else {\n                if (a !== atom) {\n                    mountAtom(a, atom, queue);\n                }\n            }\n        });\n        readAtomState(atom);\n        const mounted = {\n            t: new Set(initialDependent && [\n                initialDependent\n            ]),\n            l: /* @__PURE__ */ new Set()\n        };\n        mountedMap.set(atom, mounted);\n        if (( false ? 0 : void 0) !== \"production\") {\n            mountedAtoms.add(atom);\n        }\n        if (isActuallyWritableAtom(atom) && atom.onMount) {\n            const { onMount } = atom;\n            queue.push(()=>{\n                const onUnmount = onMount((...args)=>writeAtom(atom, ...args));\n                if (onUnmount) {\n                    mounted.u = onUnmount;\n                }\n            });\n        }\n        if (!onMountQueue) {\n            queue.forEach((f)=>f());\n        }\n        return mounted;\n    };\n    const unmountAtom = (atom)=>{\n        var _a;\n        const onUnmount = (_a = mountedMap.get(atom)) == null ? void 0 : _a.u;\n        if (onUnmount) {\n            onUnmount();\n        }\n        mountedMap.delete(atom);\n        if (( false ? 0 : void 0) !== \"production\") {\n            mountedAtoms.delete(atom);\n        }\n        const atomState = getAtomState(atom);\n        if (atomState) {\n            if (hasPromiseAtomValue(atomState)) {\n                cancelPromise(atomState.v);\n            }\n            atomState.d.forEach((_, a)=>{\n                if (a !== atom) {\n                    const mounted = mountedMap.get(a);\n                    if (mounted) {\n                        mounted.t.delete(atom);\n                        if (canUnmountAtom(a, mounted)) {\n                            unmountAtom(a);\n                        }\n                    }\n                }\n            });\n        } else if (( false ? 0 : void 0) !== \"production\") {\n            console.warn(\"[Bug] could not find atom state to unmount\", atom);\n        }\n    };\n    const mountDependencies = (atom, atomState, prevDependencies)=>{\n        const depSet = new Set(atomState.d.keys());\n        prevDependencies == null ? void 0 : prevDependencies.forEach((_, a)=>{\n            if (depSet.has(a)) {\n                depSet.delete(a);\n                return;\n            }\n            const mounted = mountedMap.get(a);\n            if (mounted) {\n                mounted.t.delete(atom);\n                if (canUnmountAtom(a, mounted)) {\n                    unmountAtom(a);\n                }\n            }\n        });\n        depSet.forEach((a)=>{\n            const mounted = mountedMap.get(a);\n            if (mounted) {\n                mounted.t.add(atom);\n            } else if (mountedMap.has(atom)) {\n                mountAtom(a, atom);\n            }\n        });\n    };\n    const flushPending = ()=>{\n        let flushed;\n        if (( false ? 0 : void 0) !== \"production\") {\n            flushed = /* @__PURE__ */ new Set();\n        }\n        while(pendingMap.size){\n            const pending = Array.from(pendingMap);\n            pendingMap.clear();\n            pending.forEach(([atom, prevAtomState])=>{\n                const atomState = getAtomState(atom);\n                if (atomState) {\n                    const mounted = mountedMap.get(atom);\n                    if (mounted && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n                        mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n                    }\n                    if (mounted && !// Maybe we could `mountDependencies` in `setAtomState`?\n                    (!hasPromiseAtomValue(prevAtomState) && (isEqualAtomValue(prevAtomState, atomState) || isEqualAtomError(prevAtomState, atomState)))) {\n                        mounted.l.forEach((listener)=>listener());\n                        if (( false ? 0 : void 0) !== \"production\") {\n                            flushed.add(atom);\n                        }\n                    }\n                } else if (( false ? 0 : void 0) !== \"production\") {\n                    console.warn(\"[Bug] no atom state to flush\");\n                }\n            });\n        }\n        if (( false ? 0 : void 0) !== \"production\") {\n            return flushed;\n        }\n    };\n    const subscribeAtom = (atom, listener)=>{\n        const mounted = addAtom(atom);\n        const flushed = flushPending();\n        const listeners = mounted.l;\n        listeners.add(listener);\n        if (( false ? 0 : void 0) !== \"production\") {\n            storeListenersRev2.forEach((l)=>l({\n                    type: \"sub\",\n                    flushed\n                }));\n        }\n        return ()=>{\n            listeners.delete(listener);\n            delAtom(atom);\n            if (( false ? 0 : void 0) !== \"production\") {\n                storeListenersRev2.forEach((l)=>l({\n                        type: \"unsub\"\n                    }));\n            }\n        };\n    };\n    if (( false ? 0 : void 0) !== \"production\") {\n        return {\n            get: readAtom,\n            set: writeAtom,\n            sub: subscribeAtom,\n            // store dev methods (these are tentative and subject to change without notice)\n            dev_subscribe_store: (l, rev)=>{\n                if (rev !== 2) {\n                    throw new Error(\"The current StoreListener revision is 2.\");\n                }\n                storeListenersRev2.add(l);\n                return ()=>{\n                    storeListenersRev2.delete(l);\n                };\n            },\n            dev_get_mounted_atoms: ()=>mountedAtoms.values(),\n            dev_get_atom_state: (a)=>atomStateMap.get(a),\n            dev_get_mounted: (a)=>mountedMap.get(a),\n            dev_restore_atoms: (values)=>{\n                for (const [atom, valueOrPromise] of values){\n                    if (hasInitialValue(atom)) {\n                        setAtomValueOrPromise(atom, valueOrPromise);\n                        recomputeDependents(atom);\n                    }\n                }\n                const flushed = flushPending();\n                storeListenersRev2.forEach((l)=>l({\n                        type: \"restore\",\n                        flushed\n                    }));\n            }\n        };\n    }\n    return {\n        get: readAtom,\n        set: writeAtom,\n        sub: subscribeAtom\n    };\n};\nlet defaultStore;\nif (( false ? 0 : void 0) !== \"production\") {\n    if (typeof globalThis.__NUMBER_OF_JOTAI_INSTANCES__ === \"number\") {\n        ++globalThis.__NUMBER_OF_JOTAI_INSTANCES__;\n    } else {\n        globalThis.__NUMBER_OF_JOTAI_INSTANCES__ = 1;\n    }\n}\nconst getDefaultStore = ()=>{\n    if (!defaultStore) {\n        if (( false ? 0 : void 0) !== \"production\" && globalThis.__NUMBER_OF_JOTAI_INSTANCES__ !== 1) {\n            console.warn(\"Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044\");\n        }\n        defaultStore = createStore();\n    }\n    return defaultStore;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2pvdGFpQDIuNi4xX0B0eXBlcytyZWFjdEAxOC4yLjQ3X3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvam90YWkvZXNtL3ZhbmlsbGEubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLElBQUlBLFdBQVc7QUFDZixTQUFTQyxLQUFLQyxJQUFJLEVBQUVDLEtBQUs7SUFDdkIsTUFBTUMsTUFBTSxDQUFDLElBQUksRUFBRSxFQUFFSixTQUFTLENBQUM7SUFDL0IsTUFBTUssU0FBUztRQUNiQyxVQUFVLElBQU1GO0lBQ2xCO0lBQ0EsSUFBSSxPQUFPRixTQUFTLFlBQVk7UUFDOUJHLE9BQU9ILElBQUksR0FBR0E7SUFDaEIsT0FBTztRQUNMRyxPQUFPRSxJQUFJLEdBQUdMO1FBQ2RHLE9BQU9ILElBQUksR0FBRyxTQUFTTSxHQUFHO1lBQ3hCLE9BQU9BLElBQUksSUFBSTtRQUNqQjtRQUNBSCxPQUFPRixLQUFLLEdBQUcsU0FBU0ssR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUc7WUFDbkMsT0FBT0QsSUFDTCxJQUFJLEVBQ0osT0FBT0MsUUFBUSxhQUFhQSxJQUFJRixJQUFJLElBQUksS0FBS0U7UUFFakQ7SUFDRjtJQUNBLElBQUlQLE9BQU87UUFDVEUsT0FBT0YsS0FBSyxHQUFHQTtJQUNqQjtJQUNBLE9BQU9FO0FBQ1Q7QUFFQSxNQUFNTSxrQkFBa0IsQ0FBQ1YsT0FBUyxVQUFVQTtBQUM1QyxNQUFNVyx5QkFBeUIsQ0FBQ1gsT0FBUyxDQUFDLENBQUNBLEtBQUtFLEtBQUs7QUFDckQsTUFBTVUsbUJBQW1CLGFBQWEsR0FBRyxJQUFJQztBQUM3QyxNQUFNQyx3QkFBd0IsQ0FBQ0MsU0FBU0M7SUFDdENKLGlCQUFpQkosR0FBRyxDQUFDTyxTQUFTQztJQUM5QkQsUUFBUUUsS0FBSyxDQUFDLEtBQ2QsR0FBR0MsT0FBTyxDQUFDLElBQU1OLGlCQUFpQk8sTUFBTSxDQUFDSjtBQUMzQztBQUNBLE1BQU1LLGdC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LE1BQU07d0JBQVdGO29CQUFRO1lBRXhDO1FBQ0Y7SUFDRjtJQUNBLE9BQU87UUFDTHpILEtBQUs2RjtRQUNMNUYsS0FBSzBGO1FBQ0xtRCxLQUFLRjtJQUNQO0FBQ0Y7QUFDQSxJQUFJVTtBQUNKLElBQUksQ0FBQyxNQUFlLEdBQUcsQ0FBb0IsR0FBRyxLQUFLLE9BQU8sY0FBYztJQUN0RSxJQUFJLE9BQU9DLFdBQVdDLDZCQUE2QixLQUFLLFVBQVU7UUFDaEUsRUFBRUQsV0FBV0MsNkJBQTZCO0lBQzVDLE9BQU87UUFDTEQsV0FBV0MsNkJBQTZCLEdBQUc7SUFDN0M7QUFDRjtBQUNBLE1BQU1DLGtCQUFrQjtJQUN0QixJQUFJLENBQUNILGNBQWM7UUFDakIsSUFBSSxDQUFDLE1BQWUsR0FBRyxDQUFvQixHQUFHLEtBQUssT0FBTyxnQkFBZ0JDLFdBQVdDLDZCQUE2QixLQUFLLEdBQUc7WUFDeEgxRixRQUFRQyxJQUFJLENBQ1Y7UUFFSjtRQUNBdUYsZUFBZWpIO0lBQ2pCO0lBQ0EsT0FBT2lIO0FBQ1Q7QUFFOEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oYXdhLWRvY3MvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2pvdGFpQDIuNi4xX0B0eXBlcytyZWFjdEAxOC4yLjQ3X3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvam90YWkvZXNtL3ZhbmlsbGEubWpzPzg2MzQiXSwic291cmNlc0NvbnRlbnQiOlsibGV0IGtleUNvdW50ID0gMDtcbmZ1bmN0aW9uIGF0b20ocmVhZCwgd3JpdGUpIHtcbiAgY29uc3Qga2V5ID0gYGF0b20keysra2V5Q291bnR9YDtcbiAgY29uc3QgY29uZmlnID0ge1xuICAgIHRvU3RyaW5nOiAoKSA9PiBrZXlcbiAgfTtcbiAgaWYgKHR5cGVvZiByZWFkID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjb25maWcucmVhZCA9IHJlYWQ7XG4gIH0gZWxzZSB7XG4gICAgY29uZmlnLmluaXQgPSByZWFkO1xuICAgIGNvbmZpZy5yZWFkID0gZnVuY3Rpb24oZ2V0KSB7XG4gICAgICByZXR1cm4gZ2V0KHRoaXMpO1xuICAgIH07XG4gICAgY29uZmlnLndyaXRlID0gZnVuY3Rpb24oZ2V0LCBzZXQsIGFyZykge1xuICAgICAgcmV0dXJuIHNldChcbiAgICAgICAgdGhpcyxcbiAgICAgICAgdHlwZW9mIGFyZyA9PT0gXCJmdW5jdGlvblwiID8gYXJnKGdldCh0aGlzKSkgOiBhcmdcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuICBpZiAod3JpdGUpIHtcbiAgICBjb25maWcud3JpdGUgPSB3cml0ZTtcbiAgfVxuICByZXR1cm4gY29uZmlnO1xufVxuXG5jb25zdCBoYXNJbml0aWFsVmFsdWUgPSAoYXRvbSkgPT4gXCJpbml0XCIgaW4gYXRvbTtcbmNvbnN0IGlzQWN0dWFsbHlXcml0YWJsZUF0b20gPSAoYXRvbSkgPT4gISFhdG9tLndyaXRlO1xuY29uc3QgY2FuY2VsUHJvbWlzZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuY29uc3QgcmVnaXN0ZXJDYW5jZWxQcm9taXNlID0gKHByb21pc2UsIGNhbmNlbCkgPT4ge1xuICBjYW5jZWxQcm9taXNlTWFwLnNldChwcm9taXNlLCBjYW5jZWwpO1xuICBwcm9taXNlLmNhdGNoKCgpID0+IHtcbiAgfSkuZmluYWxseSgoKSA9PiBjYW5jZWxQcm9taXNlTWFwLmRlbGV0ZShwcm9taXNlKSk7XG59O1xuY29uc3QgY2FuY2VsUHJvbWlzZSA9IChwcm9taXNlLCBuZXh0KSA9PiB7XG4gIGNvbnN0IGNhbmNlbCA9IGNhbmNlbFByb21pc2VNYXAuZ2V0KHByb21pc2UpO1xuICBpZiAoY2FuY2VsKSB7XG4gICAgY2FuY2VsUHJvbWlzZU1hcC5kZWxldGUocHJvbWlzZSk7XG4gICAgY2FuY2VsKG5leHQpO1xuICB9XG59O1xuY29uc3QgcmVzb2x2ZVByb21pc2UgPSAocHJvbWlzZSwgdmFsdWUpID0+IHtcbiAgcHJvbWlzZS5zdGF0dXMgPSBcImZ1bGZpbGxlZFwiO1xuICBwcm9taXNlLnZhbHVlID0gdmFsdWU7XG59O1xuY29uc3QgcmVqZWN0UHJvbWlzZSA9IChwcm9taXNlLCBlKSA9PiB7XG4gIHByb21pc2Uuc3RhdHVzID0gXCJyZWplY3RlZFwiO1xuICBwcm9taXNlLnJlYXNvbiA9IGU7XG59O1xuY29uc3QgaXNQcm9taXNlTGlrZSA9ICh4KSA9PiB0eXBlb2YgKHggPT0gbnVsbCA/IHZvaWQgMCA6IHgudGhlbikgPT09IFwiZnVuY3Rpb25cIjtcbmNvbnN0IGlzRXF1YWxBdG9tVmFsdWUgPSAoYSwgYikgPT4gISFhICYmIFwidlwiIGluIGEgJiYgXCJ2XCIgaW4gYiAmJiBPYmplY3QuaXMoYS52LCBiLnYpO1xuY29uc3QgaXNFcXVhbEF0b21FcnJvciA9IChhLCBiKSA9PiAhIWEgJiYgXCJlXCIgaW4gYSAmJiBcImVcIiBpbiBiICYmIE9iamVjdC5pcyhhLmUsIGIuZSk7XG5jb25zdCBoYXNQcm9taXNlQXRvbVZhbHVlID0gKGEpID0+ICEhYSAmJiBcInZcIiBpbiBhICYmIGEudiBpbnN0YW5jZW9mIFByb21pc2U7XG5jb25zdCBpc0VxdWFsUHJvbWlzZUF0b21WYWx1ZSA9IChhLCBiKSA9PiBcInZcIiBpbiBhICYmIFwidlwiIGluIGIgJiYgYS52Lm9yaWcgJiYgYS52Lm9yaWcgPT09IGIudi5vcmlnO1xuY29uc3QgcmV0dXJuQXRvbVZhbHVlID0gKGF0b21TdGF0ZSkgPT4ge1xuICBpZiAoXCJlXCIgaW4gYXRvbVN0YXRlKSB7XG4gICAgdGhyb3cgYXRvbVN0YXRlLmU7XG4gIH1cbiAgcmV0dXJuIGF0b21TdGF0ZS52O1xufTtcbmNvbnN0IGNyZWF0ZVN0b3JlID0gKCkgPT4ge1xuICBjb25zdCBhdG9tU3RhdGVNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgY29uc3QgbW91bnRlZE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICBjb25zdCBwZW5kaW5nTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgbGV0IHN0b3JlTGlzdGVuZXJzUmV2MjtcbiAgbGV0IG1vdW50ZWRBdG9tcztcbiAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgc3RvcmVMaXN0ZW5lcnNSZXYyID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBtb3VudGVkQXRvbXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICB9XG4gIGNvbnN0IGdldEF0b21TdGF0ZSA9IChhdG9tKSA9PiBhdG9tU3RhdGVNYXAuZ2V0KGF0b20pO1xuICBjb25zdCBzZXRBdG9tU3RhdGUgPSAoYXRvbSwgYXRvbVN0YXRlKSA9PiB7XG4gICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGF0b21TdGF0ZSk7XG4gICAgfVxuICAgIGNvbnN0IHByZXZBdG9tU3RhdGUgPSBhdG9tU3RhdGVNYXAuZ2V0KGF0b20pO1xuICAgIGF0b21TdGF0ZU1hcC5zZXQoYXRvbSwgYXRvbVN0YXRlKTtcbiAgICBpZiAoIXBlbmRpbmdNYXAuaGFzKGF0b20pKSB7XG4gICAgICBwZW5kaW5nTWFwLnNldChhdG9tLCBwcmV2QXRvbVN0YXRlKTtcbiAgICB9XG4gICAgaWYgKGhhc1Byb21pc2VBdG9tVmFsdWUocHJldkF0b21TdGF0ZSkpIHtcbiAgICAgIGNvbnN0IG5leHQgPSBcInZcIiBpbiBhdG9tU3RhdGUgPyBhdG9tU3RhdGUudiBpbnN0YW5jZW9mIFByb21pc2UgPyBhdG9tU3RhdGUudiA6IFByb21pc2UucmVzb2x2ZShhdG9tU3RhdGUudikgOiBQcm9taXNlLnJlamVjdChhdG9tU3RhdGUuZSk7XG4gICAgICBpZiAocHJldkF0b21TdGF0ZS52ICE9PSBuZXh0KSB7XG4gICAgICAgIGNhbmNlbFByb21pc2UocHJldkF0b21TdGF0ZS52LCBuZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IHVwZGF0ZURlcGVuZGVuY2llcyA9IChhdG9tLCBuZXh0QXRvbVN0YXRlLCBuZXh0RGVwZW5kZW5jaWVzKSA9PiB7XG4gICAgY29uc3QgZGVwZW5kZW5jaWVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xuICAgIG5leHREZXBlbmRlbmNpZXMuZm9yRWFjaCgoYVN0YXRlLCBhKSA9PiB7XG4gICAgICBpZiAoIWFTdGF0ZSAmJiBhID09PSBhdG9tKSB7XG4gICAgICAgIGFTdGF0ZSA9IG5leHRBdG9tU3RhdGU7XG4gICAgICB9XG4gICAgICBpZiAoYVN0YXRlKSB7XG4gICAgICAgIGRlcGVuZGVuY2llcy5zZXQoYSwgYVN0YXRlKTtcbiAgICAgICAgaWYgKG5leHRBdG9tU3RhdGUuZC5nZXQoYSkgIT09IGFTdGF0ZSkge1xuICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIltCdWddIGF0b20gc3RhdGUgbm90IGZvdW5kXCIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChjaGFuZ2VkIHx8IG5leHRBdG9tU3RhdGUuZC5zaXplICE9PSBkZXBlbmRlbmNpZXMuc2l6ZSkge1xuICAgICAgbmV4dEF0b21TdGF0ZS5kID0gZGVwZW5kZW5jaWVzO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc2V0QXRvbVZhbHVlID0gKGF0b20sIHZhbHVlLCBuZXh0RGVwZW5kZW5jaWVzKSA9PiB7XG4gICAgY29uc3QgcHJldkF0b21TdGF0ZSA9IGdldEF0b21TdGF0ZShhdG9tKTtcbiAgICBjb25zdCBuZXh0QXRvbVN0YXRlID0ge1xuICAgICAgZDogKHByZXZBdG9tU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXZBdG9tU3RhdGUuZCkgfHwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICAgIHY6IHZhbHVlXG4gICAgfTtcbiAgICBpZiAobmV4dERlcGVuZGVuY2llcykge1xuICAgICAgdXBkYXRlRGVwZW5kZW5jaWVzKGF0b20sIG5leHRBdG9tU3RhdGUsIG5leHREZXBlbmRlbmNpZXMpO1xuICAgIH1cbiAgICBpZiAoaXNFcXVhbEF0b21WYWx1ZShwcmV2QXRvbVN0YXRlLCBuZXh0QXRvbVN0YXRlKSAmJiBwcmV2QXRvbVN0YXRlLmQgPT09IG5leHRBdG9tU3RhdGUuZCkge1xuICAgICAgcmV0dXJuIHByZXZBdG9tU3RhdGU7XG4gICAgfVxuICAgIGlmIChoYXNQcm9taXNlQXRvbVZhbHVlKHByZXZBdG9tU3RhdGUpICYmIGhhc1Byb21pc2VBdG9tVmFsdWUobmV4dEF0b21TdGF0ZSkgJiYgaXNFcXVhbFByb21pc2VBdG9tVmFsdWUocHJldkF0b21TdGF0ZSwgbmV4dEF0b21TdGF0ZSkpIHtcbiAgICAgIGlmIChwcmV2QXRvbVN0YXRlLmQgPT09IG5leHRBdG9tU3RhdGUuZCkge1xuICAgICAgICByZXR1cm4gcHJldkF0b21TdGF0ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRBdG9tU3RhdGUudiA9IHByZXZBdG9tU3RhdGUudjtcbiAgICAgIH1cbiAgICB9XG4gICAgc2V0QXRvbVN0YXRlKGF0b20sIG5leHRBdG9tU3RhdGUpO1xuICAgIHJldHVybiBuZXh0QXRvbVN0YXRlO1xuICB9O1xuICBjb25zdCBzZXRBdG9tVmFsdWVPclByb21pc2UgPSAoYXRvbSwgdmFsdWVPclByb21pc2UsIG5leHREZXBlbmRlbmNpZXMsIGFib3J0UHJvbWlzZSkgPT4ge1xuICAgIGlmIChpc1Byb21pc2VMaWtlKHZhbHVlT3JQcm9taXNlKSkge1xuICAgICAgbGV0IGNvbnRpbnVlUHJvbWlzZTtcbiAgICAgIGNvbnN0IHVwZGF0ZVByb21pc2VEZXBlbmRlbmNpZXMgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHByZXZBdG9tU3RhdGUgPSBnZXRBdG9tU3RhdGUoYXRvbSk7XG4gICAgICAgIGlmICghaGFzUHJvbWlzZUF0b21WYWx1ZShwcmV2QXRvbVN0YXRlKSB8fCBwcmV2QXRvbVN0YXRlLnYgIT09IHByb21pc2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV4dEF0b21TdGF0ZSA9IHNldEF0b21WYWx1ZShcbiAgICAgICAgICBhdG9tLFxuICAgICAgICAgIHByb21pc2UsXG4gICAgICAgICAgbmV4dERlcGVuZGVuY2llc1xuICAgICAgICApO1xuICAgICAgICBpZiAobW91bnRlZE1hcC5oYXMoYXRvbSkgJiYgcHJldkF0b21TdGF0ZS5kICE9PSBuZXh0QXRvbVN0YXRlLmQpIHtcbiAgICAgICAgICBtb3VudERlcGVuZGVuY2llcyhhdG9tLCBuZXh0QXRvbVN0YXRlLCBwcmV2QXRvbVN0YXRlLmQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgbGV0IHNldHRsZWQgPSBmYWxzZTtcbiAgICAgICAgdmFsdWVPclByb21pc2UudGhlbihcbiAgICAgICAgICAodikgPT4ge1xuICAgICAgICAgICAgaWYgKCFzZXR0bGVkKSB7XG4gICAgICAgICAgICAgIHNldHRsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICByZXNvbHZlUHJvbWlzZShwcm9taXNlLCB2KTtcbiAgICAgICAgICAgICAgcmVzb2x2ZSh2KTtcbiAgICAgICAgICAgICAgdXBkYXRlUHJvbWlzZURlcGVuZGVuY2llcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgKGUpID0+IHtcbiAgICAgICAgICAgIGlmICghc2V0dGxlZCkge1xuICAgICAgICAgICAgICBzZXR0bGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcmVqZWN0UHJvbWlzZShwcm9taXNlLCBlKTtcbiAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICB1cGRhdGVQcm9taXNlRGVwZW5kZW5jaWVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICBjb250aW51ZVByb21pc2UgPSAobmV4dCkgPT4ge1xuICAgICAgICAgIGlmICghc2V0dGxlZCkge1xuICAgICAgICAgICAgc2V0dGxlZCA9IHRydWU7XG4gICAgICAgICAgICBuZXh0LnRoZW4oXG4gICAgICAgICAgICAgICh2KSA9PiByZXNvbHZlUHJvbWlzZShwcm9taXNlLCB2KSxcbiAgICAgICAgICAgICAgKGUpID0+IHJlamVjdFByb21pc2UocHJvbWlzZSwgZSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXNvbHZlKG5leHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgcHJvbWlzZS5vcmlnID0gdmFsdWVPclByb21pc2U7XG4gICAgICBwcm9taXNlLnN0YXR1cyA9IFwicGVuZGluZ1wiO1xuICAgICAgcmVnaXN0ZXJDYW5jZWxQcm9taXNlKHByb21pc2UsIChuZXh0KSA9PiB7XG4gICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgY29udGludWVQcm9taXNlKG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIGFib3J0UHJvbWlzZSA9PSBudWxsID8gdm9pZCAwIDogYWJvcnRQcm9taXNlKCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzZXRBdG9tVmFsdWUoYXRvbSwgcHJvbWlzZSwgbmV4dERlcGVuZGVuY2llcyk7XG4gICAgfVxuICAgIHJldHVybiBzZXRBdG9tVmFsdWUoYXRvbSwgdmFsdWVPclByb21pc2UsIG5leHREZXBlbmRlbmNpZXMpO1xuICB9O1xuICBjb25zdCBzZXRBdG9tRXJyb3IgPSAoYXRvbSwgZXJyb3IsIG5leHREZXBlbmRlbmNpZXMpID0+IHtcbiAgICBjb25zdCBwcmV2QXRvbVN0YXRlID0gZ2V0QXRvbVN0YXRlKGF0b20pO1xuICAgIGNvbnN0IG5leHRBdG9tU3RhdGUgPSB7XG4gICAgICBkOiAocHJldkF0b21TdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogcHJldkF0b21TdGF0ZS5kKSB8fCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgICAgZTogZXJyb3JcbiAgICB9O1xuICAgIGlmIChuZXh0RGVwZW5kZW5jaWVzKSB7XG4gICAgICB1cGRhdGVEZXBlbmRlbmNpZXMoYXRvbSwgbmV4dEF0b21TdGF0ZSwgbmV4dERlcGVuZGVuY2llcyk7XG4gICAgfVxuICAgIGlmIChpc0VxdWFsQXRvbUVycm9yKHByZXZBdG9tU3RhdGUsIG5leHRBdG9tU3RhdGUpICYmIHByZXZBdG9tU3RhdGUuZCA9PT0gbmV4dEF0b21TdGF0ZS5kKSB7XG4gICAgICByZXR1cm4gcHJldkF0b21TdGF0ZTtcbiAgICB9XG4gICAgc2V0QXRvbVN0YXRlKGF0b20sIG5leHRBdG9tU3RhdGUpO1xuICAgIHJldHVybiBuZXh0QXRvbVN0YXRlO1xuICB9O1xuICBjb25zdCByZWFkQXRvbVN0YXRlID0gKGF0b20sIGZvcmNlKSA9PiB7XG4gICAgY29uc3QgYXRvbVN0YXRlID0gZ2V0QXRvbVN0YXRlKGF0b20pO1xuICAgIGlmICghZm9yY2UgJiYgYXRvbVN0YXRlKSB7XG4gICAgICBpZiAobW91bnRlZE1hcC5oYXMoYXRvbSkpIHtcbiAgICAgICAgcmV0dXJuIGF0b21TdGF0ZTtcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5mcm9tKGF0b21TdGF0ZS5kKS5ldmVyeSgoW2EsIHNdKSA9PiB7XG4gICAgICAgIGlmIChhID09PSBhdG9tKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYVN0YXRlID0gcmVhZEF0b21TdGF0ZShhKTtcbiAgICAgICAgcmV0dXJuIGFTdGF0ZSA9PT0gcyB8fCBpc0VxdWFsQXRvbVZhbHVlKGFTdGF0ZSwgcyk7XG4gICAgICB9KSkge1xuICAgICAgICByZXR1cm4gYXRvbVN0YXRlO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBuZXh0RGVwZW5kZW5jaWVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBsZXQgaXNTeW5jID0gdHJ1ZTtcbiAgICBjb25zdCBnZXR0ZXIgPSAoYSkgPT4ge1xuICAgICAgaWYgKGEgPT09IGF0b20pIHtcbiAgICAgICAgY29uc3QgYVN0YXRlMiA9IGdldEF0b21TdGF0ZShhKTtcbiAgICAgICAgaWYgKGFTdGF0ZTIpIHtcbiAgICAgICAgICBuZXh0RGVwZW5kZW5jaWVzLnNldChhLCBhU3RhdGUyKTtcbiAgICAgICAgICByZXR1cm4gcmV0dXJuQXRvbVZhbHVlKGFTdGF0ZTIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNJbml0aWFsVmFsdWUoYSkpIHtcbiAgICAgICAgICBuZXh0RGVwZW5kZW5jaWVzLnNldChhLCB2b2lkIDApO1xuICAgICAgICAgIHJldHVybiBhLmluaXQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gYXRvbSBpbml0XCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgYVN0YXRlID0gcmVhZEF0b21TdGF0ZShhKTtcbiAgICAgIG5leHREZXBlbmRlbmNpZXMuc2V0KGEsIGFTdGF0ZSk7XG4gICAgICByZXR1cm4gcmV0dXJuQXRvbVZhbHVlKGFTdGF0ZSk7XG4gICAgfTtcbiAgICBsZXQgY29udHJvbGxlcjtcbiAgICBsZXQgc2V0U2VsZjtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgZ2V0IHNpZ25hbCgpIHtcbiAgICAgICAgaWYgKCFjb250cm9sbGVyKSB7XG4gICAgICAgICAgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udHJvbGxlci5zaWduYWw7XG4gICAgICB9LFxuICAgICAgZ2V0IHNldFNlbGYoKSB7XG4gICAgICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhaXNBY3R1YWxseVdyaXRhYmxlQXRvbShhdG9tKSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcInNldFNlbGYgZnVuY3Rpb24gY2Fubm90IGJlIHVzZWQgd2l0aCByZWFkLW9ubHkgYXRvbVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNldFNlbGYgJiYgaXNBY3R1YWxseVdyaXRhYmxlQXRvbShhdG9tKSkge1xuICAgICAgICAgIHNldFNlbGYgPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiICYmIGlzU3luYykge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJzZXRTZWxmIGZ1bmN0aW9uIGNhbm5vdCBiZSBjYWxsZWQgaW4gc3luY1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNTeW5jKSB7XG4gICAgICAgICAgICAgIHJldHVybiB3cml0ZUF0b20oYXRvbSwgLi4uYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2V0U2VsZjtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB2YWx1ZU9yUHJvbWlzZSA9IGF0b20ucmVhZChnZXR0ZXIsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHNldEF0b21WYWx1ZU9yUHJvbWlzZShcbiAgICAgICAgYXRvbSxcbiAgICAgICAgdmFsdWVPclByb21pc2UsXG4gICAgICAgIG5leHREZXBlbmRlbmNpZXMsXG4gICAgICAgICgpID0+IGNvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRyb2xsZXIuYWJvcnQoKVxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIHNldEF0b21FcnJvcihhdG9tLCBlcnJvciwgbmV4dERlcGVuZGVuY2llcyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlzU3luYyA9IGZhbHNlO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcmVhZEF0b20gPSAoYXRvbSkgPT4gcmV0dXJuQXRvbVZhbHVlKHJlYWRBdG9tU3RhdGUoYXRvbSkpO1xuICBjb25zdCBhZGRBdG9tID0gKGF0b20pID0+IHtcbiAgICBsZXQgbW91bnRlZCA9IG1vdW50ZWRNYXAuZ2V0KGF0b20pO1xuICAgIGlmICghbW91bnRlZCkge1xuICAgICAgbW91bnRlZCA9IG1vdW50QXRvbShhdG9tKTtcbiAgICB9XG4gICAgcmV0dXJuIG1vdW50ZWQ7XG4gIH07XG4gIGNvbnN0IGNhblVubW91bnRBdG9tID0gKGF0b20sIG1vdW50ZWQpID0+ICFtb3VudGVkLmwuc2l6ZSAmJiAoIW1vdW50ZWQudC5zaXplIHx8IG1vdW50ZWQudC5zaXplID09PSAxICYmIG1vdW50ZWQudC5oYXMoYXRvbSkpO1xuICBjb25zdCBkZWxBdG9tID0gKGF0b20pID0+IHtcbiAgICBjb25zdCBtb3VudGVkID0gbW91bnRlZE1hcC5nZXQoYXRvbSk7XG4gICAgaWYgKG1vdW50ZWQgJiYgY2FuVW5tb3VudEF0b20oYXRvbSwgbW91bnRlZCkpIHtcbiAgICAgIHVubW91bnRBdG9tKGF0b20pO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcmVjb21wdXRlRGVwZW5kZW50cyA9IChhdG9tKSA9PiB7XG4gICAgY29uc3QgZGVwZW5kZW5jeU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgY29uc3QgZGlydHlNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgICBjb25zdCBnZXREZXBlbmRlbnRzID0gKGEpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IGRlcGVuZGVudHMgPSBuZXcgU2V0KChfYSA9IG1vdW50ZWRNYXAuZ2V0KGEpKSA9PSBudWxsID8gdm9pZCAwIDogX2EudCk7XG4gICAgICBwZW5kaW5nTWFwLmZvckVhY2goKF8sIHBlbmRpbmdBdG9tKSA9PiB7XG4gICAgICAgIHZhciBfYTI7XG4gICAgICAgIGlmICgoX2EyID0gZ2V0QXRvbVN0YXRlKHBlbmRpbmdBdG9tKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5kLmhhcyhhKSkge1xuICAgICAgICAgIGRlcGVuZGVudHMuYWRkKHBlbmRpbmdBdG9tKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZGVwZW5kZW50cztcbiAgICB9O1xuICAgIGNvbnN0IGxvb3AxID0gKGEpID0+IHtcbiAgICAgIGdldERlcGVuZGVudHMoYSkuZm9yRWFjaCgoZGVwZW5kZW50KSA9PiB7XG4gICAgICAgIGlmIChkZXBlbmRlbnQgIT09IGEpIHtcbiAgICAgICAgICBkZXBlbmRlbmN5TWFwLnNldChcbiAgICAgICAgICAgIGRlcGVuZGVudCxcbiAgICAgICAgICAgIChkZXBlbmRlbmN5TWFwLmdldChkZXBlbmRlbnQpIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpLmFkZChhKVxuICAgICAgICAgICk7XG4gICAgICAgICAgZGlydHlNYXAuc2V0KGRlcGVuZGVudCwgKGRpcnR5TWFwLmdldChkZXBlbmRlbnQpIHx8IDApICsgMSk7XG4gICAgICAgICAgbG9vcDEoZGVwZW5kZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBsb29wMShhdG9tKTtcbiAgICBjb25zdCBsb29wMiA9IChhKSA9PiB7XG4gICAgICBnZXREZXBlbmRlbnRzKGEpLmZvckVhY2goKGRlcGVuZGVudCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChkZXBlbmRlbnQgIT09IGEpIHtcbiAgICAgICAgICBsZXQgZGlydHlDb3VudCA9IGRpcnR5TWFwLmdldChkZXBlbmRlbnQpO1xuICAgICAgICAgIGlmIChkaXJ0eUNvdW50KSB7XG4gICAgICAgICAgICBkaXJ0eU1hcC5zZXQoZGVwZW5kZW50LCAtLWRpcnR5Q291bnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWRpcnR5Q291bnQpIHtcbiAgICAgICAgICAgIGxldCBpc0NoYW5nZWQgPSAhISgoX2EgPSBkZXBlbmRlbmN5TWFwLmdldChkZXBlbmRlbnQpKSA9PSBudWxsID8gdm9pZCAwIDogX2Euc2l6ZSk7XG4gICAgICAgICAgICBpZiAoaXNDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHByZXZBdG9tU3RhdGUgPSBnZXRBdG9tU3RhdGUoZGVwZW5kZW50KTtcbiAgICAgICAgICAgICAgY29uc3QgbmV4dEF0b21TdGF0ZSA9IHJlYWRBdG9tU3RhdGUoZGVwZW5kZW50LCB0cnVlKTtcbiAgICAgICAgICAgICAgaXNDaGFuZ2VkID0gIWlzRXF1YWxBdG9tVmFsdWUocHJldkF0b21TdGF0ZSwgbmV4dEF0b21TdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzQ2hhbmdlZCkge1xuICAgICAgICAgICAgICBkZXBlbmRlbmN5TWFwLmZvckVhY2goKHMpID0+IHMuZGVsZXRlKGRlcGVuZGVudCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBsb29wMihkZXBlbmRlbnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGxvb3AyKGF0b20pO1xuICB9O1xuICBjb25zdCB3cml0ZUF0b21TdGF0ZSA9IChhdG9tLCAuLi5hcmdzKSA9PiB7XG4gICAgbGV0IGlzU3luYyA9IHRydWU7XG4gICAgY29uc3QgZ2V0dGVyID0gKGEpID0+IHJldHVybkF0b21WYWx1ZShyZWFkQXRvbVN0YXRlKGEpKTtcbiAgICBjb25zdCBzZXR0ZXIgPSAoYSwgLi4uYXJnczIpID0+IHtcbiAgICAgIGxldCByO1xuICAgICAgaWYgKGEgPT09IGF0b20pIHtcbiAgICAgICAgaWYgKCFoYXNJbml0aWFsVmFsdWUoYSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhdG9tIG5vdCB3cml0YWJsZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV2QXRvbVN0YXRlID0gZ2V0QXRvbVN0YXRlKGEpO1xuICAgICAgICBjb25zdCBuZXh0QXRvbVN0YXRlID0gc2V0QXRvbVZhbHVlT3JQcm9taXNlKGEsIGFyZ3MyWzBdKTtcbiAgICAgICAgaWYgKCFpc0VxdWFsQXRvbVZhbHVlKHByZXZBdG9tU3RhdGUsIG5leHRBdG9tU3RhdGUpKSB7XG4gICAgICAgICAgcmVjb21wdXRlRGVwZW5kZW50cyhhKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgciA9IHdyaXRlQXRvbVN0YXRlKGEsIC4uLmFyZ3MyKTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNTeW5jKSB7XG4gICAgICAgIGNvbnN0IGZsdXNoZWQgPSBmbHVzaFBlbmRpbmcoKTtcbiAgICAgICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgc3RvcmVMaXN0ZW5lcnNSZXYyLmZvckVhY2goXG4gICAgICAgICAgICAobCkgPT4gbCh7IHR5cGU6IFwiYXN5bmMtd3JpdGVcIiwgZmx1c2hlZCB9KVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgY29uc3QgcmVzdWx0ID0gYXRvbS53cml0ZShnZXR0ZXIsIHNldHRlciwgLi4uYXJncyk7XG4gICAgaXNTeW5jID0gZmFsc2U7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgY29uc3Qgd3JpdGVBdG9tID0gKGF0b20sIC4uLmFyZ3MpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSB3cml0ZUF0b21TdGF0ZShhdG9tLCAuLi5hcmdzKTtcbiAgICBjb25zdCBmbHVzaGVkID0gZmx1c2hQZW5kaW5nKCk7XG4gICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBzdG9yZUxpc3RlbmVyc1JldjIuZm9yRWFjaChcbiAgICAgICAgKGwpID0+IGwoeyB0eXBlOiBcIndyaXRlXCIsIGZsdXNoZWQgfSlcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIGNvbnN0IG1vdW50QXRvbSA9IChhdG9tLCBpbml0aWFsRGVwZW5kZW50LCBvbk1vdW50UXVldWUpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgcXVldWUgPSBvbk1vdW50UXVldWUgfHwgW107XG4gICAgKF9hID0gZ2V0QXRvbVN0YXRlKGF0b20pKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZC5mb3JFYWNoKChfLCBhKSA9PiB7XG4gICAgICBjb25zdCBhTW91bnRlZCA9IG1vdW50ZWRNYXAuZ2V0KGEpO1xuICAgICAgaWYgKGFNb3VudGVkKSB7XG4gICAgICAgIGFNb3VudGVkLnQuYWRkKGF0b20pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGEgIT09IGF0b20pIHtcbiAgICAgICAgICBtb3VudEF0b20oYSwgYXRvbSwgcXVldWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmVhZEF0b21TdGF0ZShhdG9tKTtcbiAgICBjb25zdCBtb3VudGVkID0ge1xuICAgICAgdDogbmV3IFNldChpbml0aWFsRGVwZW5kZW50ICYmIFtpbml0aWFsRGVwZW5kZW50XSksXG4gICAgICBsOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpXG4gICAgfTtcbiAgICBtb3VudGVkTWFwLnNldChhdG9tLCBtb3VudGVkKTtcbiAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIG1vdW50ZWRBdG9tcy5hZGQoYXRvbSk7XG4gICAgfVxuICAgIGlmIChpc0FjdHVhbGx5V3JpdGFibGVBdG9tKGF0b20pICYmIGF0b20ub25Nb3VudCkge1xuICAgICAgY29uc3QgeyBvbk1vdW50IH0gPSBhdG9tO1xuICAgICAgcXVldWUucHVzaCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IG9uVW5tb3VudCA9IG9uTW91bnQoKC4uLmFyZ3MpID0+IHdyaXRlQXRvbShhdG9tLCAuLi5hcmdzKSk7XG4gICAgICAgIGlmIChvblVubW91bnQpIHtcbiAgICAgICAgICBtb3VudGVkLnUgPSBvblVubW91bnQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIW9uTW91bnRRdWV1ZSkge1xuICAgICAgcXVldWUuZm9yRWFjaCgoZikgPT4gZigpKTtcbiAgICB9XG4gICAgcmV0dXJuIG1vdW50ZWQ7XG4gIH07XG4gIGNvbnN0IHVubW91bnRBdG9tID0gKGF0b20pID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3Qgb25Vbm1vdW50ID0gKF9hID0gbW91bnRlZE1hcC5nZXQoYXRvbSkpID09IG51bGwgPyB2b2lkIDAgOiBfYS51O1xuICAgIGlmIChvblVubW91bnQpIHtcbiAgICAgIG9uVW5tb3VudCgpO1xuICAgIH1cbiAgICBtb3VudGVkTWFwLmRlbGV0ZShhdG9tKTtcbiAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIG1vdW50ZWRBdG9tcy5kZWxldGUoYXRvbSk7XG4gICAgfVxuICAgIGNvbnN0IGF0b21TdGF0ZSA9IGdldEF0b21TdGF0ZShhdG9tKTtcbiAgICBpZiAoYXRvbVN0YXRlKSB7XG4gICAgICBpZiAoaGFzUHJvbWlzZUF0b21WYWx1ZShhdG9tU3RhdGUpKSB7XG4gICAgICAgIGNhbmNlbFByb21pc2UoYXRvbVN0YXRlLnYpO1xuICAgICAgfVxuICAgICAgYXRvbVN0YXRlLmQuZm9yRWFjaCgoXywgYSkgPT4ge1xuICAgICAgICBpZiAoYSAhPT0gYXRvbSkge1xuICAgICAgICAgIGNvbnN0IG1vdW50ZWQgPSBtb3VudGVkTWFwLmdldChhKTtcbiAgICAgICAgICBpZiAobW91bnRlZCkge1xuICAgICAgICAgICAgbW91bnRlZC50LmRlbGV0ZShhdG9tKTtcbiAgICAgICAgICAgIGlmIChjYW5Vbm1vdW50QXRvbShhLCBtb3VudGVkKSkge1xuICAgICAgICAgICAgICB1bm1vdW50QXRvbShhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIltCdWddIGNvdWxkIG5vdCBmaW5kIGF0b20gc3RhdGUgdG8gdW5tb3VudFwiLCBhdG9tKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IG1vdW50RGVwZW5kZW5jaWVzID0gKGF0b20sIGF0b21TdGF0ZSwgcHJldkRlcGVuZGVuY2llcykgPT4ge1xuICAgIGNvbnN0IGRlcFNldCA9IG5ldyBTZXQoYXRvbVN0YXRlLmQua2V5cygpKTtcbiAgICBwcmV2RGVwZW5kZW5jaWVzID09IG51bGwgPyB2b2lkIDAgOiBwcmV2RGVwZW5kZW5jaWVzLmZvckVhY2goKF8sIGEpID0+IHtcbiAgICAgIGlmIChkZXBTZXQuaGFzKGEpKSB7XG4gICAgICAgIGRlcFNldC5kZWxldGUoYSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1vdW50ZWQgPSBtb3VudGVkTWFwLmdldChhKTtcbiAgICAgIGlmIChtb3VudGVkKSB7XG4gICAgICAgIG1vdW50ZWQudC5kZWxldGUoYXRvbSk7XG4gICAgICAgIGlmIChjYW5Vbm1vdW50QXRvbShhLCBtb3VudGVkKSkge1xuICAgICAgICAgIHVubW91bnRBdG9tKGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgZGVwU2V0LmZvckVhY2goKGEpID0+IHtcbiAgICAgIGNvbnN0IG1vdW50ZWQgPSBtb3VudGVkTWFwLmdldChhKTtcbiAgICAgIGlmIChtb3VudGVkKSB7XG4gICAgICAgIG1vdW50ZWQudC5hZGQoYXRvbSk7XG4gICAgICB9IGVsc2UgaWYgKG1vdW50ZWRNYXAuaGFzKGF0b20pKSB7XG4gICAgICAgIG1vdW50QXRvbShhLCBhdG9tKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgZmx1c2hQZW5kaW5nID0gKCkgPT4ge1xuICAgIGxldCBmbHVzaGVkO1xuICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgZmx1c2hlZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgfVxuICAgIHdoaWxlIChwZW5kaW5nTWFwLnNpemUpIHtcbiAgICAgIGNvbnN0IHBlbmRpbmcgPSBBcnJheS5mcm9tKHBlbmRpbmdNYXApO1xuICAgICAgcGVuZGluZ01hcC5jbGVhcigpO1xuICAgICAgcGVuZGluZy5mb3JFYWNoKChbYXRvbSwgcHJldkF0b21TdGF0ZV0pID0+IHtcbiAgICAgICAgY29uc3QgYXRvbVN0YXRlID0gZ2V0QXRvbVN0YXRlKGF0b20pO1xuICAgICAgICBpZiAoYXRvbVN0YXRlKSB7XG4gICAgICAgICAgY29uc3QgbW91bnRlZCA9IG1vdW50ZWRNYXAuZ2V0KGF0b20pO1xuICAgICAgICAgIGlmIChtb3VudGVkICYmIGF0b21TdGF0ZS5kICE9PSAocHJldkF0b21TdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogcHJldkF0b21TdGF0ZS5kKSkge1xuICAgICAgICAgICAgbW91bnREZXBlbmRlbmNpZXMoYXRvbSwgYXRvbVN0YXRlLCBwcmV2QXRvbVN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBwcmV2QXRvbVN0YXRlLmQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobW91bnRlZCAmJiAhLy8gVE9ETyBUaGlzIHNlZW1zIHByZXR0eSBoYWNreS4gSG9wZSB0byBmaXggaXQuXG4gICAgICAgICAgLy8gTWF5YmUgd2UgY291bGQgYG1vdW50RGVwZW5kZW5jaWVzYCBpbiBgc2V0QXRvbVN0YXRlYD9cbiAgICAgICAgICAoIWhhc1Byb21pc2VBdG9tVmFsdWUocHJldkF0b21TdGF0ZSkgJiYgKGlzRXF1YWxBdG9tVmFsdWUocHJldkF0b21TdGF0ZSwgYXRvbVN0YXRlKSB8fCBpc0VxdWFsQXRvbUVycm9yKHByZXZBdG9tU3RhdGUsIGF0b21TdGF0ZSkpKSkge1xuICAgICAgICAgICAgbW91bnRlZC5sLmZvckVhY2goKGxpc3RlbmVyKSA9PiBsaXN0ZW5lcigpKTtcbiAgICAgICAgICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICBmbHVzaGVkLmFkZChhdG9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJbQnVnXSBubyBhdG9tIHN0YXRlIHRvIGZsdXNoXCIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICByZXR1cm4gZmx1c2hlZDtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN1YnNjcmliZUF0b20gPSAoYXRvbSwgbGlzdGVuZXIpID0+IHtcbiAgICBjb25zdCBtb3VudGVkID0gYWRkQXRvbShhdG9tKTtcbiAgICBjb25zdCBmbHVzaGVkID0gZmx1c2hQZW5kaW5nKCk7XG4gICAgY29uc3QgbGlzdGVuZXJzID0gbW91bnRlZC5sO1xuICAgIGxpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xuICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgc3RvcmVMaXN0ZW5lcnNSZXYyLmZvckVhY2goXG4gICAgICAgIChsKSA9PiBsKHsgdHlwZTogXCJzdWJcIiwgZmx1c2hlZCB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGxpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xuICAgICAgZGVsQXRvbShhdG9tKTtcbiAgICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBzdG9yZUxpc3RlbmVyc1JldjIuZm9yRWFjaCgobCkgPT4gbCh7IHR5cGU6IFwidW5zdWJcIiB9KSk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdldDogcmVhZEF0b20sXG4gICAgICBzZXQ6IHdyaXRlQXRvbSxcbiAgICAgIHN1Yjogc3Vic2NyaWJlQXRvbSxcbiAgICAgIC8vIHN0b3JlIGRldiBtZXRob2RzICh0aGVzZSBhcmUgdGVudGF0aXZlIGFuZCBzdWJqZWN0IHRvIGNoYW5nZSB3aXRob3V0IG5vdGljZSlcbiAgICAgIGRldl9zdWJzY3JpYmVfc3RvcmU6IChsLCByZXYpID0+IHtcbiAgICAgICAgaWYgKHJldiAhPT0gMikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBjdXJyZW50IFN0b3JlTGlzdGVuZXIgcmV2aXNpb24gaXMgMi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgc3RvcmVMaXN0ZW5lcnNSZXYyLmFkZChsKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICBzdG9yZUxpc3RlbmVyc1JldjIuZGVsZXRlKGwpO1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGRldl9nZXRfbW91bnRlZF9hdG9tczogKCkgPT4gbW91bnRlZEF0b21zLnZhbHVlcygpLFxuICAgICAgZGV2X2dldF9hdG9tX3N0YXRlOiAoYSkgPT4gYXRvbVN0YXRlTWFwLmdldChhKSxcbiAgICAgIGRldl9nZXRfbW91bnRlZDogKGEpID0+IG1vdW50ZWRNYXAuZ2V0KGEpLFxuICAgICAgZGV2X3Jlc3RvcmVfYXRvbXM6ICh2YWx1ZXMpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBbYXRvbSwgdmFsdWVPclByb21pc2VdIG9mIHZhbHVlcykge1xuICAgICAgICAgIGlmIChoYXNJbml0aWFsVmFsdWUoYXRvbSkpIHtcbiAgICAgICAgICAgIHNldEF0b21WYWx1ZU9yUHJvbWlzZShhdG9tLCB2YWx1ZU9yUHJvbWlzZSk7XG4gICAgICAgICAgICByZWNvbXB1dGVEZXBlbmRlbnRzKGF0b20pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmbHVzaGVkID0gZmx1c2hQZW5kaW5nKCk7XG4gICAgICAgIHN0b3JlTGlzdGVuZXJzUmV2Mi5mb3JFYWNoKFxuICAgICAgICAgIChsKSA9PiBsKHsgdHlwZTogXCJyZXN0b3JlXCIsIGZsdXNoZWQgfSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgZ2V0OiByZWFkQXRvbSxcbiAgICBzZXQ6IHdyaXRlQXRvbSxcbiAgICBzdWI6IHN1YnNjcmliZUF0b21cbiAgfTtcbn07XG5sZXQgZGVmYXVsdFN0b3JlO1xuaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIGlmICh0eXBlb2YgZ2xvYmFsVGhpcy5fX05VTUJFUl9PRl9KT1RBSV9JTlNUQU5DRVNfXyA9PT0gXCJudW1iZXJcIikge1xuICAgICsrZ2xvYmFsVGhpcy5fX05VTUJFUl9PRl9KT1RBSV9JTlNUQU5DRVNfXztcbiAgfSBlbHNlIHtcbiAgICBnbG9iYWxUaGlzLl9fTlVNQkVSX09GX0pPVEFJX0lOU1RBTkNFU19fID0gMTtcbiAgfVxufVxuY29uc3QgZ2V0RGVmYXVsdFN0b3JlID0gKCkgPT4ge1xuICBpZiAoIWRlZmF1bHRTdG9yZSkge1xuICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIiAmJiBnbG9iYWxUaGlzLl9fTlVNQkVSX09GX0pPVEFJX0lOU1RBTkNFU19fICE9PSAxKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIFwiRGV0ZWN0ZWQgbXVsdGlwbGUgSm90YWkgaW5zdGFuY2VzLiBJdCBtYXkgY2F1c2UgdW5leHBlY3RlZCBiZWhhdmlvciB3aXRoIHRoZSBkZWZhdWx0IHN0b3JlLiBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL2pvdGFpL2Rpc2N1c3Npb25zLzIwNDRcIlxuICAgICAgKTtcbiAgICB9XG4gICAgZGVmYXVsdFN0b3JlID0gY3JlYXRlU3RvcmUoKTtcbiAgfVxuICByZXR1cm4gZGVmYXVsdFN0b3JlO1xufTtcblxuZXhwb3J0IHsgYXRvbSwgY3JlYXRlU3RvcmUsIGdldERlZmF1bHRTdG9yZSB9O1xuIl0sIm5hbWVzIjpbImtleUNvdW50IiwiYXRvbSIsInJlYWQiLCJ3cml0ZSIsImtleSIsImNvbmZpZyIsInRvU3RyaW5nIiwiaW5pdCIsImdldCIsInNldCIsImFyZyIsImhhc0luaXRpYWxWYWx1ZSIsImlzQWN0dWFsbHlXcml0YWJsZUF0b20iLCJjYW5jZWxQcm9taXNlTWFwIiwiV2Vha01hcCIsInJlZ2lzdGVyQ2FuY2VsUHJvbWlzZSIsInByb21pc2UiLCJjYW5jZWwiLCJjYXRjaCIsImZpbmFsbHkiLCJkZWxldGUiLCJjYW5jZWxQcm9taXNlIiwibmV4dCIsInJlc29sdmVQcm9taXNlIiwidmFsdWUiLCJzdGF0dXMiLCJyZWplY3RQcm9taXNlIiwiZSIsInJlYXNvbiIsImlzUHJvbWlzZUxpa2UiLCJ4IiwidGhlbiIsImlzRXF1YWxBdG9tVmFsdWUiLCJhIiwiYiIsIk9iamVjdCIsImlzIiwidiIsImlzRXF1YWxBdG9tRXJyb3IiLCJoYXNQcm9taXNlQXRvbVZhbHVlIiwiUHJvbWlzZSIsImlzRXF1YWxQcm9taXNlQXRvbVZhbHVlIiwib3JpZyIsInJldHVybkF0b21WYWx1ZSIsImF0b21TdGF0ZSIsImNyZWF0ZVN0b3JlIiwiYXRvbVN0YXRlTWFwIiwibW91bnRlZE1hcCIsInBlbmRpbmdNYXAiLCJNYXAiLCJzdG9yZUxpc3RlbmVyc1JldjIiLCJtb3VudGVkQXRvbXMiLCJlbnYiLCJNT0RFIiwiU2V0IiwiZ2V0QXRvbVN0YXRlIiwic2V0QXRvbVN0YXRlIiwiZnJlZXplIiwicHJldkF0b21TdGF0ZSIsImhhcyIsInJlc29sdmUiLCJyZWplY3QiLCJ1cGRhdGVEZXBlbmRlbmNpZXMiLCJuZXh0QXRvbVN0YXRlIiwibmV4dERlcGVuZGVuY2llcyIsImRlcGVuZGVuY2llcyIsImNoYW5nZWQiLCJmb3JFYWNoIiwiYVN0YXRlIiwiZCIsImNvbnNvbGUiLCJ3YXJuIiwic2l6ZSIsInNldEF0b21WYWx1ZSIsInNldEF0b21WYWx1ZU9yUHJvbWlzZSIsInZhbHVlT3JQcm9taXNlIiwiYWJvcnRQcm9taXNlIiwiY29udGludWVQcm9taXNlIiwidXBkYXRlUHJvbWlzZURlcGVuZGVuY2llcyIsIm1vdW50RGVwZW5kZW5jaWVzIiwic2V0dGxlZCIsInNldEF0b21FcnJvciIsImVycm9yIiwicmVhZEF0b21TdGF0ZSIsImZvcmNlIiwiQXJyYXkiLCJmcm9tIiwiZXZlcnkiLCJzIiwiaXNTeW5jIiwiZ2V0dGVyIiwiYVN0YXRlMiIsIkVycm9yIiwiY29udHJvbGxlciIsInNldFNlbGYiLCJvcHRpb25zIiwic2lnbmFsIiwiQWJvcnRDb250cm9sbGVyIiwiYXJncyIsIndyaXRlQXRvbSIsImFib3J0IiwicmVhZEF0b20iLCJhZGRBdG9tIiwibW91bnRlZCIsIm1vdW50QXRvbSIsImNhblVubW91bnRBdG9tIiwibCIsInQiLCJkZWxBdG9tIiwidW5tb3VudEF0b20iLCJyZWNvbXB1dGVEZXBlbmRlbnRzIiwiZGVwZW5kZW5jeU1hcCIsImRpcnR5TWFwIiwiZ2V0RGVwZW5kZW50cyIsIl9hIiwiZGVwZW5kZW50cyIsIl8iLCJwZW5kaW5nQXRvbSIsIl9hMiIsImFkZCIsImxvb3AxIiwiZGVwZW5kZW50IiwibG9vcDIiLCJkaXJ0eUNvdW50IiwiaXNDaGFuZ2VkIiwid3JpdGVBdG9tU3RhdGUiLCJzZXR0ZXIiLCJhcmdzMiIsInIiLCJmbHVzaGVkIiwiZmx1c2hQZW5kaW5nIiwidHlwZSIsInJlc3VsdCIsImluaXRpYWxEZXBlbmRlbnQiLCJvbk1vdW50UXVldWUiLCJxdWV1ZSIsImFNb3VudGVkIiwib25Nb3VudCIsInB1c2giLCJvblVubW91bnQiLCJ1IiwiZiIsInByZXZEZXBlbmRlbmNpZXMiLCJkZXBTZXQiLCJrZXlzIiwicGVuZGluZyIsImNsZWFyIiwibGlzdGVuZXIiLCJzdWJzY3JpYmVBdG9tIiwibGlzdGVuZXJzIiwic3ViIiwiZGV2X3N1YnNjcmliZV9zdG9yZSIsInJldiIsImRldl9nZXRfbW91bnRlZF9hdG9tcyIsInZhbHVlcyIsImRldl9nZXRfYXRvbV9zdGF0ZSIsImRldl9nZXRfbW91bnRlZCIsImRldl9yZXN0b3JlX2F0b21zIiwiZGVmYXVsdFN0b3JlIiwiZ2xvYmFsVGhpcyIsIl9fTlVNQkVSX09GX0pPVEFJX0lOU1RBTkNFU19fIiwiZ2V0RGVmYXVsdFN0b3JlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/jotai@2.6.1_@types+react@18.2.47_react@18.2.0/node_modules/jotai/esm/vanilla.mjs\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/jotai@2.6.1_@types+react@18.2.47_react@18.2.0/node_modules/jotai/esm/vanilla/utils.mjs":
/*!***********************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/jotai@2.6.1_@types+react@18.2.47_react@18.2.0/node_modules/jotai/esm/vanilla/utils.mjs ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RESET: () => (/* binding */ RESET),\n/* harmony export */   atomFamily: () => (/* binding */ atomFamily),\n/* harmony export */   atomWithDefault: () => (/* binding */ atomWithDefault),\n/* harmony export */   atomWithObservable: () => (/* binding */ atomWithObservable),\n/* harmony export */   atomWithReducer: () => (/* binding */ atomWithReducer),\n/* harmony export */   atomWithReset: () => (/* binding */ atomWithReset),\n/* harmony export */   atomWithStorage: () => (/* binding */ atomWithStorage),\n/* harmony export */   createJSONStorage: () => (/* binding */ createJSONStorage),\n/* harmony export */   freezeAtom: () => (/* binding */ freezeAtom),\n/* harmony export */   freezeAtomCreator: () => (/* binding */ freezeAtomCreator),\n/* harmony export */   loadable: () => (/* binding */ loadable),\n/* harmony export */   selectAtom: () => (/* binding */ selectAtom),\n/* harmony export */   splitAtom: () => (/* binding */ splitAtom),\n/* harmony export */   unwrap: () => (/* binding */ unwrap)\n/* harmony export */ });\n/* harmony import */ var jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jotai/vanilla */ \"(ssr)/../../node_modules/.pnpm/jotai@2.6.1_@types+react@18.2.47_react@18.2.0/node_modules/jotai/esm/vanilla.mjs\");\n\nconst RESET = Symbol(( false ? 0 : void 0) !== \"production\" ? \"RESET\" : \"\");\nfunction atomWithReset(initialValue) {\n    const anAtom = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)(initialValue, (get, set, update)=>{\n        const nextValue = typeof update === \"function\" ? update(get(anAtom)) : update;\n        set(anAtom, nextValue === RESET ? initialValue : nextValue);\n    });\n    return anAtom;\n}\nfunction atomWithReducer(initialValue, reducer) {\n    const anAtom = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)(initialValue, (get, set, action)=>set(anAtom, reducer(get(anAtom), action)));\n    return anAtom;\n}\nfunction atomFamily(initializeAtom, areEqual) {\n    let shouldRemove = null;\n    const atoms = /* @__PURE__ */ new Map();\n    const createAtom = (param)=>{\n        let item;\n        if (areEqual === void 0) {\n            item = atoms.get(param);\n        } else {\n            for (const [key, value] of atoms){\n                if (areEqual(key, param)) {\n                    item = value;\n                    break;\n                }\n            }\n        }\n        if (item !== void 0) {\n            if (shouldRemove == null ? void 0 : shouldRemove(item[1], param)) {\n                createAtom.remove(param);\n            } else {\n                return item[0];\n            }\n        }\n        const newAtom = initializeAtom(param);\n        atoms.set(param, [\n            newAtom,\n            Date.now()\n        ]);\n        return newAtom;\n    };\n    createAtom.remove = (param)=>{\n        if (areEqual === void 0) {\n            atoms.delete(param);\n        } else {\n            for (const [key] of atoms){\n                if (areEqual(key, param)) {\n                    atoms.delete(key);\n                    break;\n                }\n            }\n        }\n    };\n    createAtom.setShouldRemove = (fn)=>{\n        shouldRemove = fn;\n        if (!shouldRemove) return;\n        for (const [key, value] of atoms){\n            if (shouldRemove(value[1], key)) {\n                atoms.delete(key);\n            }\n        }\n    };\n    return createAtom;\n}\nconst getCached$2 = (c, m, k)=>(m.has(k) ? m : m.set(k, c())).get(k);\nconst cache1$4 = /* @__PURE__ */ new WeakMap();\nconst memo3 = (create, dep1, dep2, dep3)=>{\n    const cache2 = getCached$2(()=>/* @__PURE__ */ new WeakMap(), cache1$4, dep1);\n    const cache3 = getCached$2(()=>/* @__PURE__ */ new WeakMap(), cache2, dep2);\n    return getCached$2(create, cache3, dep3);\n};\nfunction selectAtom(anAtom, selector, equalityFn = Object.is) {\n    return memo3(()=>{\n        const EMPTY = Symbol();\n        const selectValue = ([value, prevSlice])=>{\n            if (prevSlice === EMPTY) {\n                return selector(value);\n            }\n            const slice = selector(value, prevSlice);\n            return equalityFn(prevSlice, slice) ? prevSlice : slice;\n        };\n        const derivedAtom = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)((get)=>{\n            const prev = get(derivedAtom);\n            const value = get(anAtom);\n            if (value instanceof Promise || prev instanceof Promise) {\n                return Promise.all([\n                    value,\n                    prev\n                ]).then(selectValue);\n            }\n            return selectValue([\n                value,\n                prev\n            ]);\n        });\n        derivedAtom.init = EMPTY;\n        return derivedAtom;\n    }, anAtom, selector, equalityFn);\n}\nconst cache1$3 = /* @__PURE__ */ new WeakMap();\nconst memo1$1 = (create, dep1)=>(cache1$3.has(dep1) ? cache1$3 : cache1$3.set(dep1, create())).get(dep1);\nconst deepFreeze = (obj)=>{\n    if (typeof obj !== \"object\" || obj === null) return;\n    Object.freeze(obj);\n    const propNames = Object.getOwnPropertyNames(obj);\n    for (const name of propNames){\n        const value = obj[name];\n        deepFreeze(value);\n    }\n    return obj;\n};\nfunction freezeAtom(anAtom) {\n    return memo1$1(()=>{\n        const frozenAtom = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)((get)=>deepFreeze(get(anAtom)), (_get, set, arg)=>set(anAtom, arg));\n        return frozenAtom;\n    }, anAtom);\n}\nfunction freezeAtomCreator(createAtom) {\n    return (...params)=>{\n        const anAtom = createAtom(...params);\n        const origRead = anAtom.read;\n        anAtom.read = function(get, options) {\n            return deepFreeze(origRead.call(this, get, options));\n        };\n        return anAtom;\n    };\n}\nconst getCached$1 = (c, m, k)=>(m.has(k) ? m : m.set(k, c())).get(k);\nconst cache1$2 = /* @__PURE__ */ new WeakMap();\nconst memo2$1 = (create, dep1, dep2)=>{\n    const cache2 = getCached$1(()=>/* @__PURE__ */ new WeakMap(), cache1$2, dep1);\n    return getCached$1(create, cache2, dep2);\n};\nconst cacheKeyForEmptyKeyExtractor = {};\nconst isWritable = (atom2)=>!!atom2.write;\nconst isFunction = (x)=>typeof x === \"function\";\nfunction splitAtom(arrAtom, keyExtractor) {\n    return memo2$1(()=>{\n        const mappingCache = /* @__PURE__ */ new WeakMap();\n        const getMapping = (arr, prev)=>{\n            let mapping = mappingCache.get(arr);\n            if (mapping) {\n                return mapping;\n            }\n            const prevMapping = prev && mappingCache.get(prev);\n            const atomList = [];\n            const keyList = [];\n            arr.forEach((item, index)=>{\n                const key = keyExtractor ? keyExtractor(item) : index;\n                keyList[index] = key;\n                const cachedAtom = prevMapping && prevMapping.atomList[prevMapping.keyList.indexOf(key)];\n                if (cachedAtom) {\n                    atomList[index] = cachedAtom;\n                    return;\n                }\n                const read = (get)=>{\n                    const prev2 = get(mappingAtom);\n                    const currArr = get(arrAtom);\n                    const mapping2 = getMapping(currArr, prev2 == null ? void 0 : prev2.arr);\n                    const index2 = mapping2.keyList.indexOf(key);\n                    if (index2 < 0 || index2 >= currArr.length) {\n                        const prevItem = arr[getMapping(arr).keyList.indexOf(key)];\n                        if (prevItem) {\n                            return prevItem;\n                        }\n                        throw new Error(\"splitAtom: index out of bounds for read\");\n                    }\n                    return currArr[index2];\n                };\n                const write = (get, set, update)=>{\n                    const prev2 = get(mappingAtom);\n                    const arr2 = get(arrAtom);\n                    const mapping2 = getMapping(arr2, prev2 == null ? void 0 : prev2.arr);\n                    const index2 = mapping2.keyList.indexOf(key);\n                    if (index2 < 0 || index2 >= arr2.length) {\n                        throw new Error(\"splitAtom: index out of bounds for write\");\n                    }\n                    const nextItem = isFunction(update) ? update(arr2[index2]) : update;\n                    if (!Object.is(arr2[index2], nextItem)) {\n                        set(arrAtom, [\n                            ...arr2.slice(0, index2),\n                            nextItem,\n                            ...arr2.slice(index2 + 1)\n                        ]);\n                    }\n                };\n                atomList[index] = isWritable(arrAtom) ? (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)(read, write) : (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)(read);\n            });\n            if (prevMapping && prevMapping.keyList.length === keyList.length && prevMapping.keyList.every((x, i)=>x === keyList[i])) {\n                mapping = prevMapping;\n            } else {\n                mapping = {\n                    arr,\n                    atomList,\n                    keyList\n                };\n            }\n            mappingCache.set(arr, mapping);\n            return mapping;\n        };\n        const mappingAtom = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)((get)=>{\n            const prev = get(mappingAtom);\n            const arr = get(arrAtom);\n            const mapping = getMapping(arr, prev == null ? void 0 : prev.arr);\n            return mapping;\n        });\n        if (( false ? 0 : void 0) !== \"production\") {\n            mappingAtom.debugPrivate = true;\n        }\n        mappingAtom.init = void 0;\n        const splittedAtom = isWritable(arrAtom) ? (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)((get)=>get(mappingAtom).atomList, (get, set, action)=>{\n            switch(action.type){\n                case \"remove\":\n                    {\n                        const index = get(splittedAtom).indexOf(action.atom);\n                        if (index >= 0) {\n                            const arr = get(arrAtom);\n                            set(arrAtom, [\n                                ...arr.slice(0, index),\n                                ...arr.slice(index + 1)\n                            ]);\n                        }\n                        break;\n                    }\n                case \"insert\":\n                    {\n                        const index = action.before ? get(splittedAtom).indexOf(action.before) : get(splittedAtom).length;\n                        if (index >= 0) {\n                            const arr = get(arrAtom);\n                            set(arrAtom, [\n                                ...arr.slice(0, index),\n                                action.value,\n                                ...arr.slice(index)\n                            ]);\n                        }\n                        break;\n                    }\n                case \"move\":\n                    {\n                        const index1 = get(splittedAtom).indexOf(action.atom);\n                        const index2 = action.before ? get(splittedAtom).indexOf(action.before) : get(splittedAtom).length;\n                        if (index1 >= 0 && index2 >= 0) {\n                            const arr = get(arrAtom);\n                            if (index1 < index2) {\n                                set(arrAtom, [\n                                    ...arr.slice(0, index1),\n                                    ...arr.slice(index1 + 1, index2),\n                                    arr[index1],\n                                    ...arr.slice(index2)\n                                ]);\n                            } else {\n                                set(arrAtom, [\n                                    ...arr.slice(0, index2),\n                                    arr[index1],\n                                    ...arr.slice(index2, index1),\n                                    ...arr.slice(index1 + 1)\n                                ]);\n                            }\n                        }\n                        break;\n                    }\n            }\n        }) : (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)((get)=>get(mappingAtom).atomList);\n        return splittedAtom;\n    }, arrAtom, keyExtractor || cacheKeyForEmptyKeyExtractor);\n}\nfunction atomWithDefault(getDefault) {\n    const EMPTY = Symbol();\n    const overwrittenAtom = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)(EMPTY);\n    if (( false ? 0 : void 0) !== \"production\") {\n        overwrittenAtom.debugPrivate = true;\n    }\n    const anAtom = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)((get, options)=>{\n        const overwritten = get(overwrittenAtom);\n        if (overwritten !== EMPTY) {\n            return overwritten;\n        }\n        return getDefault(get, options);\n    }, (get, set, update)=>{\n        if (update === RESET) {\n            set(overwrittenAtom, EMPTY);\n        } else if (typeof update === \"function\") {\n            const prevValue = get(anAtom);\n            set(overwrittenAtom, update(prevValue));\n        } else {\n            set(overwrittenAtom, update);\n        }\n    });\n    return anAtom;\n}\nconst isPromiseLike = (x)=>typeof (x == null ? void 0 : x.then) === \"function\";\nfunction createJSONStorage(getStringStorage) {\n    let lastStr;\n    let lastValue;\n    const storage = {\n        getItem: (key, initialValue)=>{\n            var _a, _b;\n            const parse = (str2)=>{\n                str2 = str2 || \"\";\n                if (lastStr !== str2) {\n                    try {\n                        lastValue = JSON.parse(str2);\n                    } catch  {\n                        return initialValue;\n                    }\n                    lastStr = str2;\n                }\n                return lastValue;\n            };\n            const str = (_b = (_a = getStringStorage()) == null ? void 0 : _a.getItem(key)) != null ? _b : null;\n            if (isPromiseLike(str)) {\n                return str.then(parse);\n            }\n            return parse(str);\n        },\n        setItem: (key, newValue)=>{\n            var _a;\n            return (_a = getStringStorage()) == null ? void 0 : _a.setItem(key, JSON.stringify(newValue));\n        },\n        removeItem: (key)=>{\n            var _a;\n            return (_a = getStringStorage()) == null ? void 0 : _a.removeItem(key);\n        }\n    };\n    if (false) {}\n    return storage;\n}\nconst defaultStorage = createJSONStorage(()=> false ? 0 : void 0);\nfunction atomWithStorage(key, initialValue, storage = defaultStorage, options) {\n    const getOnInit = options == null ? void 0 : options.getOnInit;\n    const baseAtom = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)(getOnInit ? storage.getItem(key, initialValue) : initialValue);\n    if (( false ? 0 : void 0) !== \"production\") {\n        baseAtom.debugPrivate = true;\n    }\n    baseAtom.onMount = (setAtom)=>{\n        if (!getOnInit) {\n            setAtom(storage.getItem(key, initialValue));\n        }\n        let unsub;\n        if (storage.subscribe) {\n            unsub = storage.subscribe(key, setAtom, initialValue);\n        }\n        return unsub;\n    };\n    const anAtom = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)((get)=>get(baseAtom), (get, set, update)=>{\n        const nextValue = typeof update === \"function\" ? update(get(baseAtom)) : update;\n        if (nextValue === RESET) {\n            set(baseAtom, initialValue);\n            return storage.removeItem(key);\n        }\n        if (nextValue instanceof Promise) {\n            return nextValue.then((resolvedValue)=>{\n                set(baseAtom, resolvedValue);\n                return storage.setItem(key, resolvedValue);\n            });\n        }\n        set(baseAtom, nextValue);\n        return storage.setItem(key, nextValue);\n    });\n    return anAtom;\n}\nfunction atomWithObservable(getObservable, options) {\n    const returnResultData = (result)=>{\n        if (\"e\" in result) {\n            throw result.e;\n        }\n        return result.d;\n    };\n    const observableResultAtom = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)((get)=>{\n        var _a;\n        let observable = getObservable(get);\n        const itself = (_a = observable[Symbol.observable]) == null ? void 0 : _a.call(observable);\n        if (itself) {\n            observable = itself;\n        }\n        let resolve;\n        const makePending = ()=>new Promise((r)=>{\n                resolve = r;\n            });\n        const initialResult = options && \"initialValue\" in options ? {\n            d: typeof options.initialValue === \"function\" ? options.initialValue() : options.initialValue\n        } : makePending();\n        let setResult;\n        let lastResult;\n        const listener = (result)=>{\n            lastResult = result;\n            resolve == null ? void 0 : resolve(result);\n            setResult == null ? void 0 : setResult(result);\n        };\n        let subscription;\n        let timer;\n        const isNotMounted = ()=>!setResult;\n        const start = ()=>{\n            if (subscription) {\n                clearTimeout(timer);\n                subscription.unsubscribe();\n            }\n            subscription = observable.subscribe({\n                next: (d)=>listener({\n                        d\n                    }),\n                error: (e)=>listener({\n                        e\n                    }),\n                complete: ()=>{}\n            });\n            if (isNotMounted() && (options == null ? void 0 : options.unstable_timeout)) {\n                timer = setTimeout(()=>{\n                    if (subscription) {\n                        subscription.unsubscribe();\n                        subscription = void 0;\n                    }\n                }, options.unstable_timeout);\n            }\n        };\n        start();\n        const resultAtom = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)(lastResult || initialResult);\n        if (( false ? 0 : void 0) !== \"production\") {\n            resultAtom.debugPrivate = true;\n        }\n        resultAtom.onMount = (update)=>{\n            setResult = update;\n            if (lastResult) {\n                update(lastResult);\n            }\n            if (subscription) {\n                clearTimeout(timer);\n            } else {\n                start();\n            }\n            return ()=>{\n                setResult = void 0;\n                if (subscription) {\n                    subscription.unsubscribe();\n                    subscription = void 0;\n                }\n            };\n        };\n        return [\n            resultAtom,\n            observable,\n            makePending,\n            start,\n            isNotMounted\n        ];\n    });\n    if (( false ? 0 : void 0) !== \"production\") {\n        observableResultAtom.debugPrivate = true;\n    }\n    const observableAtom = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)((get)=>{\n        const [resultAtom] = get(observableResultAtom);\n        const result = get(resultAtom);\n        if (result instanceof Promise) {\n            return result.then(returnResultData);\n        }\n        return returnResultData(result);\n    }, (get, set, data)=>{\n        const [resultAtom, observable, makePending, start, isNotMounted] = get(observableResultAtom);\n        if (\"next\" in observable) {\n            if (isNotMounted()) {\n                set(resultAtom, makePending());\n                start();\n            }\n            observable.next(data);\n        } else {\n            throw new Error(\"observable is not subject\");\n        }\n    });\n    return observableAtom;\n}\nconst cache1$1 = /* @__PURE__ */ new WeakMap();\nconst memo1 = (create, dep1)=>(cache1$1.has(dep1) ? cache1$1 : cache1$1.set(dep1, create())).get(dep1);\nconst LOADING = {\n    state: \"loading\"\n};\nfunction loadable(anAtom) {\n    return memo1(()=>{\n        const loadableCache = /* @__PURE__ */ new WeakMap();\n        const refreshAtom = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)(0);\n        if (( false ? 0 : void 0) !== \"production\") {\n            refreshAtom.debugPrivate = true;\n        }\n        const derivedAtom = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)((get, { setSelf })=>{\n            get(refreshAtom);\n            let value;\n            try {\n                value = get(anAtom);\n            } catch (error) {\n                return {\n                    state: \"hasError\",\n                    error\n                };\n            }\n            if (!(value instanceof Promise)) {\n                return {\n                    state: \"hasData\",\n                    data: value\n                };\n            }\n            const promise = value;\n            const cached = loadableCache.get(promise);\n            if (cached) {\n                return cached;\n            }\n            loadableCache.set(promise, LOADING);\n            promise.then((data)=>{\n                loadableCache.set(promise, {\n                    state: \"hasData\",\n                    data\n                });\n            }, (error)=>{\n                loadableCache.set(promise, {\n                    state: \"hasError\",\n                    error\n                });\n            }).finally(setSelf);\n            return LOADING;\n        }, (_get, set)=>{\n            set(refreshAtom, (c)=>c + 1);\n        });\n        if (( false ? 0 : void 0) !== \"production\") {\n            derivedAtom.debugPrivate = true;\n        }\n        return (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)((get)=>get(derivedAtom));\n    }, anAtom);\n}\nconst getCached = (c, m, k)=>(m.has(k) ? m : m.set(k, c())).get(k);\nconst cache1 = /* @__PURE__ */ new WeakMap();\nconst memo2 = (create, dep1, dep2)=>{\n    const cache2 = getCached(()=>/* @__PURE__ */ new WeakMap(), cache1, dep1);\n    return getCached(create, cache2, dep2);\n};\nconst defaultFallback = ()=>void 0;\nfunction unwrap(anAtom, fallback = defaultFallback) {\n    return memo2(()=>{\n        const promiseErrorCache = /* @__PURE__ */ new WeakMap();\n        const promiseResultCache = /* @__PURE__ */ new WeakMap();\n        const refreshAtom = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)(0);\n        if (( false ? 0 : void 0) !== \"production\") {\n            refreshAtom.debugPrivate = true;\n        }\n        const promiseAndValueAtom = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)((get, { setSelf })=>{\n            get(refreshAtom);\n            const prev = get(promiseAndValueAtom);\n            const promise = get(anAtom);\n            if (!(promise instanceof Promise)) {\n                return {\n                    v: promise\n                };\n            }\n            if (promise === (prev == null ? void 0 : prev.p)) {\n                if (promiseErrorCache.has(promise)) {\n                    throw promiseErrorCache.get(promise);\n                }\n                if (promiseResultCache.has(promise)) {\n                    return {\n                        p: promise,\n                        v: promiseResultCache.get(promise)\n                    };\n                }\n            }\n            if (promise !== (prev == null ? void 0 : prev.p)) {\n                promise.then((v)=>promiseResultCache.set(promise, v), (e)=>promiseErrorCache.set(promise, e)).finally(setSelf);\n            }\n            if (prev && \"v\" in prev) {\n                return {\n                    p: promise,\n                    f: fallback(prev.v),\n                    v: prev.v\n                };\n            }\n            return {\n                p: promise,\n                f: fallback()\n            };\n        }, (_get, set)=>{\n            set(refreshAtom, (c)=>c + 1);\n        });\n        promiseAndValueAtom.init = void 0;\n        if (( false ? 0 : void 0) !== \"production\") {\n            promiseAndValueAtom.debugPrivate = true;\n        }\n        return (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)((get)=>{\n            const state = get(promiseAndValueAtom);\n            if (\"f\" in state) {\n                return state.f;\n            }\n            return state.v;\n        }, (_get, set, ...args)=>set(anAtom, ...args));\n    }, anAtom, fallback);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2pvdGFpQDIuNi4xX0B0eXBlcytyZWFjdEAxOC4yLjQ3X3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvam90YWkvZXNtL3ZhbmlsbGEvdXRpbHMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFxQztBQUVyQyxNQUFNQyxRQUFRQyxPQUNaLENBQUMsTUFBZSxHQUFHLENBQW9CLEdBQUcsS0FBSyxPQUFPLGVBQWUsVUFBVTtBQUdqRixTQUFTRyxjQUFjQyxZQUFZO0lBQ2pDLE1BQU1DLFNBQVNQLG1EQUFJQSxDQUNqQk0sY0FDQSxDQUFDRSxLQUFLQyxLQUFLQztRQUNULE1BQU1DLFlBQVksT0FBT0QsV0FBVyxhQUFhQSxPQUFPRixJQUFJRCxXQUFXRztRQUN2RUQsSUFBSUYsUUFBUUksY0FBY1YsUUFBUUssZUFBZUs7SUFDbkQ7SUFFRixPQUFPSjtBQUNUO0FBRUEsU0FBU0ssZ0JBQWdCTixZQUFZLEVBQUVPLE9BQU87SUFDNUMsTUFBTU4sU0FBU1AsbURBQUlBLENBQ2pCTSxjQUNBLENBQUNFLEtBQUtDLEtBQUtLLFNBQVdMLElBQUlGLFFBQVFNLFFBQVFMLElBQUlELFNBQVNPO0lBRXpELE9BQU9QO0FBQ1Q7QUFFQSxTQUFTUSxXQUFXQyxjQUFjLEVBQUVDLFFBQVE7SUFDMUMsSUFBSUMsZUFBZTtJQUNuQixNQUFNQyxRQUFRLGFBQWEsR0FBRyxJQUFJQztJQUNsQyxNQUFNQyxhQUFhLENBQUNDO1FBQ2xCLElBQUlDO1FBQ0osSUFBSU4sYUFBYSxLQUFLLEdBQUc7WUFDdkJNLE9BQU9KLE1BQU1YLEdBQUcsQ0FBQ2M7UUFDbkIsT0FBTztZQUNMLEtBQUssTUFBTSxDQUFDRSxLQUFLQyxNQUFNLElBQUlOLE1BQU87Z0JBQ2hDLElBQUlGLFNBQVNPLEtBQUtGLFFBQVE7b0JBQ3hCQyxPQUFPRTtvQkFDUDtnQkFDRjtZQUNGO1FBQ0Y7UUFDQSxJQUFJRixTQUFTLEtBQUssR0FBRztZQUNu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LEtBQUssR0FBRzJNLE9BQVMzTSxJQUFJRixXQUFXNk07SUFFM0MsR0FDQTdNLFFBQ0FzTTtBQUVKO0FBRThNIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGF3YS1kb2NzLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9qb3RhaUAyLjYuMV9AdHlwZXMrcmVhY3RAMTguMi40N19yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL2pvdGFpL2VzbS92YW5pbGxhL3V0aWxzLm1qcz82Y2QyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGF0b20gfSBmcm9tICdqb3RhaS92YW5pbGxhJztcblxuY29uc3QgUkVTRVQgPSBTeW1ib2woXG4gIChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiID8gXCJSRVNFVFwiIDogXCJcIlxuKTtcblxuZnVuY3Rpb24gYXRvbVdpdGhSZXNldChpbml0aWFsVmFsdWUpIHtcbiAgY29uc3QgYW5BdG9tID0gYXRvbShcbiAgICBpbml0aWFsVmFsdWUsXG4gICAgKGdldCwgc2V0LCB1cGRhdGUpID0+IHtcbiAgICAgIGNvbnN0IG5leHRWYWx1ZSA9IHR5cGVvZiB1cGRhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHVwZGF0ZShnZXQoYW5BdG9tKSkgOiB1cGRhdGU7XG4gICAgICBzZXQoYW5BdG9tLCBuZXh0VmFsdWUgPT09IFJFU0VUID8gaW5pdGlhbFZhbHVlIDogbmV4dFZhbHVlKTtcbiAgICB9XG4gICk7XG4gIHJldHVybiBhbkF0b207XG59XG5cbmZ1bmN0aW9uIGF0b21XaXRoUmVkdWNlcihpbml0aWFsVmFsdWUsIHJlZHVjZXIpIHtcbiAgY29uc3QgYW5BdG9tID0gYXRvbShcbiAgICBpbml0aWFsVmFsdWUsXG4gICAgKGdldCwgc2V0LCBhY3Rpb24pID0+IHNldChhbkF0b20sIHJlZHVjZXIoZ2V0KGFuQXRvbSksIGFjdGlvbikpXG4gICk7XG4gIHJldHVybiBhbkF0b207XG59XG5cbmZ1bmN0aW9uIGF0b21GYW1pbHkoaW5pdGlhbGl6ZUF0b20sIGFyZUVxdWFsKSB7XG4gIGxldCBzaG91bGRSZW1vdmUgPSBudWxsO1xuICBjb25zdCBhdG9tcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IGNyZWF0ZUF0b20gPSAocGFyYW0pID0+IHtcbiAgICBsZXQgaXRlbTtcbiAgICBpZiAoYXJlRXF1YWwgPT09IHZvaWQgMCkge1xuICAgICAgaXRlbSA9IGF0b21zLmdldChwYXJhbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGF0b21zKSB7XG4gICAgICAgIGlmIChhcmVFcXVhbChrZXksIHBhcmFtKSkge1xuICAgICAgICAgIGl0ZW0gPSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXRlbSAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAoc2hvdWxkUmVtb3ZlID09IG51bGwgPyB2b2lkIDAgOiBzaG91bGRSZW1vdmUoaXRlbVsxXSwgcGFyYW0pKSB7XG4gICAgICAgIGNyZWF0ZUF0b20ucmVtb3ZlKHBhcmFtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBpdGVtWzBdO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBuZXdBdG9tID0gaW5pdGlhbGl6ZUF0b20ocGFyYW0pO1xuICAgIGF0b21zLnNldChwYXJhbSwgW25ld0F0b20sIERhdGUubm93KCldKTtcbiAgICByZXR1cm4gbmV3QXRvbTtcbiAgfTtcbiAgY3JlYXRlQXRvbS5yZW1vdmUgPSAocGFyYW0pID0+IHtcbiAgICBpZiAoYXJlRXF1YWwgPT09IHZvaWQgMCkge1xuICAgICAgYXRvbXMuZGVsZXRlKHBhcmFtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChjb25zdCBba2V5XSBvZiBhdG9tcykge1xuICAgICAgICBpZiAoYXJlRXF1YWwoa2V5LCBwYXJhbSkpIHtcbiAgICAgICAgICBhdG9tcy5kZWxldGUoa2V5KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY3JlYXRlQXRvbS5zZXRTaG91bGRSZW1vdmUgPSAoZm4pID0+IHtcbiAgICBzaG91bGRSZW1vdmUgPSBmbjtcbiAgICBpZiAoIXNob3VsZFJlbW92ZSlcbiAgICAgIHJldHVybjtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBhdG9tcykge1xuICAgICAgaWYgKHNob3VsZFJlbW92ZSh2YWx1ZVsxXSwga2V5KSkge1xuICAgICAgICBhdG9tcy5kZWxldGUoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiBjcmVhdGVBdG9tO1xufVxuXG5jb25zdCBnZXRDYWNoZWQkMiA9IChjLCBtLCBrKSA9PiAobS5oYXMoaykgPyBtIDogbS5zZXQoaywgYygpKSkuZ2V0KGspO1xuY29uc3QgY2FjaGUxJDQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IG1lbW8zID0gKGNyZWF0ZSwgZGVwMSwgZGVwMiwgZGVwMykgPT4ge1xuICBjb25zdCBjYWNoZTIgPSBnZXRDYWNoZWQkMigoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgY2FjaGUxJDQsIGRlcDEpO1xuICBjb25zdCBjYWNoZTMgPSBnZXRDYWNoZWQkMigoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgY2FjaGUyLCBkZXAyKTtcbiAgcmV0dXJuIGdldENhY2hlZCQyKGNyZWF0ZSwgY2FjaGUzLCBkZXAzKTtcbn07XG5mdW5jdGlvbiBzZWxlY3RBdG9tKGFuQXRvbSwgc2VsZWN0b3IsIGVxdWFsaXR5Rm4gPSBPYmplY3QuaXMpIHtcbiAgcmV0dXJuIG1lbW8zKFxuICAgICgpID0+IHtcbiAgICAgIGNvbnN0IEVNUFRZID0gU3ltYm9sKCk7XG4gICAgICBjb25zdCBzZWxlY3RWYWx1ZSA9IChbdmFsdWUsIHByZXZTbGljZV0pID0+IHtcbiAgICAgICAgaWYgKHByZXZTbGljZSA9PT0gRU1QVFkpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZWN0b3IodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNsaWNlID0gc2VsZWN0b3IodmFsdWUsIHByZXZTbGljZSk7XG4gICAgICAgIHJldHVybiBlcXVhbGl0eUZuKHByZXZTbGljZSwgc2xpY2UpID8gcHJldlNsaWNlIDogc2xpY2U7XG4gICAgICB9O1xuICAgICAgY29uc3QgZGVyaXZlZEF0b20gPSBhdG9tKChnZXQpID0+IHtcbiAgICAgICAgY29uc3QgcHJldiA9IGdldChkZXJpdmVkQXRvbSk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0KGFuQXRvbSk7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UgfHwgcHJldiBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW3ZhbHVlLCBwcmV2XSkudGhlbihzZWxlY3RWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGVjdFZhbHVlKFt2YWx1ZSwgcHJldl0pO1xuICAgICAgfSk7XG4gICAgICBkZXJpdmVkQXRvbS5pbml0ID0gRU1QVFk7XG4gICAgICByZXR1cm4gZGVyaXZlZEF0b207XG4gICAgfSxcbiAgICBhbkF0b20sXG4gICAgc2VsZWN0b3IsXG4gICAgZXF1YWxpdHlGblxuICApO1xufVxuXG5jb25zdCBjYWNoZTEkMyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuY29uc3QgbWVtbzEkMSA9IChjcmVhdGUsIGRlcDEpID0+IChjYWNoZTEkMy5oYXMoZGVwMSkgPyBjYWNoZTEkMyA6IGNhY2hlMSQzLnNldChkZXAxLCBjcmVhdGUoKSkpLmdldChkZXAxKTtcbmNvbnN0IGRlZXBGcmVlemUgPSAob2JqKSA9PiB7XG4gIGlmICh0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiIHx8IG9iaiA9PT0gbnVsbClcbiAgICByZXR1cm47XG4gIE9iamVjdC5mcmVlemUob2JqKTtcbiAgY29uc3QgcHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKTtcbiAgZm9yIChjb25zdCBuYW1lIG9mIHByb3BOYW1lcykge1xuICAgIGNvbnN0IHZhbHVlID0gb2JqW25hbWVdO1xuICAgIGRlZXBGcmVlemUodmFsdWUpO1xuICB9XG4gIHJldHVybiBvYmo7XG59O1xuZnVuY3Rpb24gZnJlZXplQXRvbShhbkF0b20pIHtcbiAgcmV0dXJuIG1lbW8xJDEoKCkgPT4ge1xuICAgIGNvbnN0IGZyb3plbkF0b20gPSBhdG9tKFxuICAgICAgKGdldCkgPT4gZGVlcEZyZWV6ZShnZXQoYW5BdG9tKSksXG4gICAgICAoX2dldCwgc2V0LCBhcmcpID0+IHNldChhbkF0b20sIGFyZylcbiAgICApO1xuICAgIHJldHVybiBmcm96ZW5BdG9tO1xuICB9LCBhbkF0b20pO1xufVxuZnVuY3Rpb24gZnJlZXplQXRvbUNyZWF0b3IoY3JlYXRlQXRvbSkge1xuICByZXR1cm4gKC4uLnBhcmFtcykgPT4ge1xuICAgIGNvbnN0IGFuQXRvbSA9IGNyZWF0ZUF0b20oLi4ucGFyYW1zKTtcbiAgICBjb25zdCBvcmlnUmVhZCA9IGFuQXRvbS5yZWFkO1xuICAgIGFuQXRvbS5yZWFkID0gZnVuY3Rpb24oZ2V0LCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gZGVlcEZyZWV6ZShvcmlnUmVhZC5jYWxsKHRoaXMsIGdldCwgb3B0aW9ucykpO1xuICAgIH07XG4gICAgcmV0dXJuIGFuQXRvbTtcbiAgfTtcbn1cblxuY29uc3QgZ2V0Q2FjaGVkJDEgPSAoYywgbSwgaykgPT4gKG0uaGFzKGspID8gbSA6IG0uc2V0KGssIGMoKSkpLmdldChrKTtcbmNvbnN0IGNhY2hlMSQyID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jb25zdCBtZW1vMiQxID0gKGNyZWF0ZSwgZGVwMSwgZGVwMikgPT4ge1xuICBjb25zdCBjYWNoZTIgPSBnZXRDYWNoZWQkMSgoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgY2FjaGUxJDIsIGRlcDEpO1xuICByZXR1cm4gZ2V0Q2FjaGVkJDEoY3JlYXRlLCBjYWNoZTIsIGRlcDIpO1xufTtcbmNvbnN0IGNhY2hlS2V5Rm9yRW1wdHlLZXlFeHRyYWN0b3IgPSB7fTtcbmNvbnN0IGlzV3JpdGFibGUgPSAoYXRvbTIpID0+ICEhYXRvbTIud3JpdGU7XG5jb25zdCBpc0Z1bmN0aW9uID0gKHgpID0+IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCI7XG5mdW5jdGlvbiBzcGxpdEF0b20oYXJyQXRvbSwga2V5RXh0cmFjdG9yKSB7XG4gIHJldHVybiBtZW1vMiQxKFxuICAgICgpID0+IHtcbiAgICAgIGNvbnN0IG1hcHBpbmdDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICAgICAgY29uc3QgZ2V0TWFwcGluZyA9IChhcnIsIHByZXYpID0+IHtcbiAgICAgICAgbGV0IG1hcHBpbmcgPSBtYXBwaW5nQ2FjaGUuZ2V0KGFycik7XG4gICAgICAgIGlmIChtYXBwaW5nKSB7XG4gICAgICAgICAgcmV0dXJuIG1hcHBpbmc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJldk1hcHBpbmcgPSBwcmV2ICYmIG1hcHBpbmdDYWNoZS5nZXQocHJldik7XG4gICAgICAgIGNvbnN0IGF0b21MaXN0ID0gW107XG4gICAgICAgIGNvbnN0IGtleUxpc3QgPSBbXTtcbiAgICAgICAgYXJyLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgY29uc3Qga2V5ID0ga2V5RXh0cmFjdG9yID8ga2V5RXh0cmFjdG9yKGl0ZW0pIDogaW5kZXg7XG4gICAgICAgICAga2V5TGlzdFtpbmRleF0gPSBrZXk7XG4gICAgICAgICAgY29uc3QgY2FjaGVkQXRvbSA9IHByZXZNYXBwaW5nICYmIHByZXZNYXBwaW5nLmF0b21MaXN0W3ByZXZNYXBwaW5nLmtleUxpc3QuaW5kZXhPZihrZXkpXTtcbiAgICAgICAgICBpZiAoY2FjaGVkQXRvbSkge1xuICAgICAgICAgICAgYXRvbUxpc3RbaW5kZXhdID0gY2FjaGVkQXRvbTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgcmVhZCA9IChnZXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHByZXYyID0gZ2V0KG1hcHBpbmdBdG9tKTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJBcnIgPSBnZXQoYXJyQXRvbSk7XG4gICAgICAgICAgICBjb25zdCBtYXBwaW5nMiA9IGdldE1hcHBpbmcoY3VyckFyciwgcHJldjIgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXYyLmFycik7XG4gICAgICAgICAgICBjb25zdCBpbmRleDIgPSBtYXBwaW5nMi5rZXlMaXN0LmluZGV4T2Yoa2V5KTtcbiAgICAgICAgICAgIGlmIChpbmRleDIgPCAwIHx8IGluZGV4MiA+PSBjdXJyQXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgICBjb25zdCBwcmV2SXRlbSA9IGFycltnZXRNYXBwaW5nKGFycikua2V5TGlzdC5pbmRleE9mKGtleSldO1xuICAgICAgICAgICAgICBpZiAocHJldkl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJldkl0ZW07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic3BsaXRBdG9tOiBpbmRleCBvdXQgb2YgYm91bmRzIGZvciByZWFkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGN1cnJBcnJbaW5kZXgyXTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IHdyaXRlID0gKGdldCwgc2V0LCB1cGRhdGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHByZXYyID0gZ2V0KG1hcHBpbmdBdG9tKTtcbiAgICAgICAgICAgIGNvbnN0IGFycjIgPSBnZXQoYXJyQXRvbSk7XG4gICAgICAgICAgICBjb25zdCBtYXBwaW5nMiA9IGdldE1hcHBpbmcoYXJyMiwgcHJldjIgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXYyLmFycik7XG4gICAgICAgICAgICBjb25zdCBpbmRleDIgPSBtYXBwaW5nMi5rZXlMaXN0LmluZGV4T2Yoa2V5KTtcbiAgICAgICAgICAgIGlmIChpbmRleDIgPCAwIHx8IGluZGV4MiA+PSBhcnIyLmxlbmd0aCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzcGxpdEF0b206IGluZGV4IG91dCBvZiBib3VuZHMgZm9yIHdyaXRlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV4dEl0ZW0gPSBpc0Z1bmN0aW9uKHVwZGF0ZSkgPyB1cGRhdGUoYXJyMltpbmRleDJdKSA6IHVwZGF0ZTtcbiAgICAgICAgICAgIGlmICghT2JqZWN0LmlzKGFycjJbaW5kZXgyXSwgbmV4dEl0ZW0pKSB7XG4gICAgICAgICAgICAgIHNldChhcnJBdG9tLCBbXG4gICAgICAgICAgICAgICAgLi4uYXJyMi5zbGljZSgwLCBpbmRleDIpLFxuICAgICAgICAgICAgICAgIG5leHRJdGVtLFxuICAgICAgICAgICAgICAgIC4uLmFycjIuc2xpY2UoaW5kZXgyICsgMSlcbiAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBhdG9tTGlzdFtpbmRleF0gPSBpc1dyaXRhYmxlKGFyckF0b20pID8gYXRvbShyZWFkLCB3cml0ZSkgOiBhdG9tKHJlYWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHByZXZNYXBwaW5nICYmIHByZXZNYXBwaW5nLmtleUxpc3QubGVuZ3RoID09PSBrZXlMaXN0Lmxlbmd0aCAmJiBwcmV2TWFwcGluZy5rZXlMaXN0LmV2ZXJ5KCh4LCBpKSA9PiB4ID09PSBrZXlMaXN0W2ldKSkge1xuICAgICAgICAgIG1hcHBpbmcgPSBwcmV2TWFwcGluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXBwaW5nID0geyBhcnIsIGF0b21MaXN0LCBrZXlMaXN0IH07XG4gICAgICAgIH1cbiAgICAgICAgbWFwcGluZ0NhY2hlLnNldChhcnIsIG1hcHBpbmcpO1xuICAgICAgICByZXR1cm4gbWFwcGluZztcbiAgICAgIH07XG4gICAgICBjb25zdCBtYXBwaW5nQXRvbSA9IGF0b20oKGdldCkgPT4ge1xuICAgICAgICBjb25zdCBwcmV2ID0gZ2V0KG1hcHBpbmdBdG9tKTtcbiAgICAgICAgY29uc3QgYXJyID0gZ2V0KGFyckF0b20pO1xuICAgICAgICBjb25zdCBtYXBwaW5nID0gZ2V0TWFwcGluZyhhcnIsIHByZXYgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXYuYXJyKTtcbiAgICAgICAgcmV0dXJuIG1hcHBpbmc7XG4gICAgICB9KTtcbiAgICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBtYXBwaW5nQXRvbS5kZWJ1Z1ByaXZhdGUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgbWFwcGluZ0F0b20uaW5pdCA9IHZvaWQgMDtcbiAgICAgIGNvbnN0IHNwbGl0dGVkQXRvbSA9IGlzV3JpdGFibGUoYXJyQXRvbSkgPyBhdG9tKFxuICAgICAgICAoZ2V0KSA9PiBnZXQobWFwcGluZ0F0b20pLmF0b21MaXN0LFxuICAgICAgICAoZ2V0LCBzZXQsIGFjdGlvbikgPT4ge1xuICAgICAgICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJyZW1vdmVcIjoge1xuICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGdldChzcGxpdHRlZEF0b20pLmluZGV4T2YoYWN0aW9uLmF0b20pO1xuICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyciA9IGdldChhcnJBdG9tKTtcbiAgICAgICAgICAgICAgICBzZXQoYXJyQXRvbSwgW1xuICAgICAgICAgICAgICAgICAgLi4uYXJyLnNsaWNlKDAsIGluZGV4KSxcbiAgICAgICAgICAgICAgICAgIC4uLmFyci5zbGljZShpbmRleCArIDEpXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiaW5zZXJ0XCI6IHtcbiAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBhY3Rpb24uYmVmb3JlID8gZ2V0KHNwbGl0dGVkQXRvbSkuaW5kZXhPZihhY3Rpb24uYmVmb3JlKSA6IGdldChzcGxpdHRlZEF0b20pLmxlbmd0aDtcbiAgICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcnIgPSBnZXQoYXJyQXRvbSk7XG4gICAgICAgICAgICAgICAgc2V0KGFyckF0b20sIFtcbiAgICAgICAgICAgICAgICAgIC4uLmFyci5zbGljZSgwLCBpbmRleCksXG4gICAgICAgICAgICAgICAgICBhY3Rpb24udmFsdWUsXG4gICAgICAgICAgICAgICAgICAuLi5hcnIuc2xpY2UoaW5kZXgpXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwibW92ZVwiOiB7XG4gICAgICAgICAgICAgIGNvbnN0IGluZGV4MSA9IGdldChzcGxpdHRlZEF0b20pLmluZGV4T2YoYWN0aW9uLmF0b20pO1xuICAgICAgICAgICAgICBjb25zdCBpbmRleDIgPSBhY3Rpb24uYmVmb3JlID8gZ2V0KHNwbGl0dGVkQXRvbSkuaW5kZXhPZihhY3Rpb24uYmVmb3JlKSA6IGdldChzcGxpdHRlZEF0b20pLmxlbmd0aDtcbiAgICAgICAgICAgICAgaWYgKGluZGV4MSA+PSAwICYmIGluZGV4MiA+PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJyID0gZ2V0KGFyckF0b20pO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleDEgPCBpbmRleDIpIHtcbiAgICAgICAgICAgICAgICAgIHNldChhcnJBdG9tLCBbXG4gICAgICAgICAgICAgICAgICAgIC4uLmFyci5zbGljZSgwLCBpbmRleDEpLFxuICAgICAgICAgICAgICAgICAgICAuLi5hcnIuc2xpY2UoaW5kZXgxICsgMSwgaW5kZXgyKSxcbiAgICAgICAgICAgICAgICAgICAgYXJyW2luZGV4MV0sXG4gICAgICAgICAgICAgICAgICAgIC4uLmFyci5zbGljZShpbmRleDIpXG4gICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgc2V0KGFyckF0b20sIFtcbiAgICAgICAgICAgICAgICAgICAgLi4uYXJyLnNsaWNlKDAsIGluZGV4MiksXG4gICAgICAgICAgICAgICAgICAgIGFycltpbmRleDFdLFxuICAgICAgICAgICAgICAgICAgICAuLi5hcnIuc2xpY2UoaW5kZXgyLCBpbmRleDEpLFxuICAgICAgICAgICAgICAgICAgICAuLi5hcnIuc2xpY2UoaW5kZXgxICsgMSlcbiAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICkgOiBhdG9tKChnZXQpID0+IGdldChtYXBwaW5nQXRvbSkuYXRvbUxpc3QpO1xuICAgICAgcmV0dXJuIHNwbGl0dGVkQXRvbTtcbiAgICB9LFxuICAgIGFyckF0b20sXG4gICAga2V5RXh0cmFjdG9yIHx8IGNhY2hlS2V5Rm9yRW1wdHlLZXlFeHRyYWN0b3JcbiAgKTtcbn1cblxuZnVuY3Rpb24gYXRvbVdpdGhEZWZhdWx0KGdldERlZmF1bHQpIHtcbiAgY29uc3QgRU1QVFkgPSBTeW1ib2woKTtcbiAgY29uc3Qgb3ZlcndyaXR0ZW5BdG9tID0gYXRvbShFTVBUWSk7XG4gIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIG92ZXJ3cml0dGVuQXRvbS5kZWJ1Z1ByaXZhdGUgPSB0cnVlO1xuICB9XG4gIGNvbnN0IGFuQXRvbSA9IGF0b20oXG4gICAgKGdldCwgb3B0aW9ucykgPT4ge1xuICAgICAgY29uc3Qgb3ZlcndyaXR0ZW4gPSBnZXQob3ZlcndyaXR0ZW5BdG9tKTtcbiAgICAgIGlmIChvdmVyd3JpdHRlbiAhPT0gRU1QVFkpIHtcbiAgICAgICAgcmV0dXJuIG92ZXJ3cml0dGVuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldERlZmF1bHQoZ2V0LCBvcHRpb25zKTtcbiAgICB9LFxuICAgIChnZXQsIHNldCwgdXBkYXRlKSA9PiB7XG4gICAgICBpZiAodXBkYXRlID09PSBSRVNFVCkge1xuICAgICAgICBzZXQob3ZlcndyaXR0ZW5BdG9tLCBFTVBUWSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB1cGRhdGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjb25zdCBwcmV2VmFsdWUgPSBnZXQoYW5BdG9tKTtcbiAgICAgICAgc2V0KG92ZXJ3cml0dGVuQXRvbSwgdXBkYXRlKHByZXZWYWx1ZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0KG92ZXJ3cml0dGVuQXRvbSwgdXBkYXRlKTtcbiAgICAgIH1cbiAgICB9XG4gICk7XG4gIHJldHVybiBhbkF0b207XG59XG5cbmNvbnN0IGlzUHJvbWlzZUxpa2UgPSAoeCkgPT4gdHlwZW9mICh4ID09IG51bGwgPyB2b2lkIDAgOiB4LnRoZW4pID09PSBcImZ1bmN0aW9uXCI7XG5mdW5jdGlvbiBjcmVhdGVKU09OU3RvcmFnZShnZXRTdHJpbmdTdG9yYWdlKSB7XG4gIGxldCBsYXN0U3RyO1xuICBsZXQgbGFzdFZhbHVlO1xuICBjb25zdCBzdG9yYWdlID0ge1xuICAgIGdldEl0ZW06IChrZXksIGluaXRpYWxWYWx1ZSkgPT4ge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIGNvbnN0IHBhcnNlID0gKHN0cjIpID0+IHtcbiAgICAgICAgc3RyMiA9IHN0cjIgfHwgXCJcIjtcbiAgICAgICAgaWYgKGxhc3RTdHIgIT09IHN0cjIpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGFzdFZhbHVlID0gSlNPTi5wYXJzZShzdHIyKTtcbiAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybiBpbml0aWFsVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxhc3RTdHIgPSBzdHIyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYXN0VmFsdWU7XG4gICAgICB9O1xuICAgICAgY29uc3Qgc3RyID0gKF9iID0gKF9hID0gZ2V0U3RyaW5nU3RvcmFnZSgpKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZ2V0SXRlbShrZXkpKSAhPSBudWxsID8gX2IgOiBudWxsO1xuICAgICAgaWYgKGlzUHJvbWlzZUxpa2Uoc3RyKSkge1xuICAgICAgICByZXR1cm4gc3RyLnRoZW4ocGFyc2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlKHN0cik7XG4gICAgfSxcbiAgICBzZXRJdGVtOiAoa2V5LCBuZXdWYWx1ZSkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgcmV0dXJuIChfYSA9IGdldFN0cmluZ1N0b3JhZ2UoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnNldEl0ZW0oa2V5LCBKU09OLnN0cmluZ2lmeShuZXdWYWx1ZSkpO1xuICAgIH0sXG4gICAgcmVtb3ZlSXRlbTogKGtleSkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgcmV0dXJuIChfYSA9IGdldFN0cmluZ1N0b3JhZ2UoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnJlbW92ZUl0ZW0oa2V5KTtcbiAgICB9XG4gIH07XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciA9PT0gXCJmdW5jdGlvblwiICYmIHdpbmRvdy5TdG9yYWdlKSB7XG4gICAgc3RvcmFnZS5zdWJzY3JpYmUgPSAoa2V5LCBjYWxsYmFjaywgaW5pdGlhbFZhbHVlKSA9PiB7XG4gICAgICBpZiAoIShnZXRTdHJpbmdTdG9yYWdlKCkgaW5zdGFuY2VvZiB3aW5kb3cuU3RvcmFnZSkpIHtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0b3JhZ2VFdmVudENhbGxiYWNrID0gKGUpID0+IHtcbiAgICAgICAgaWYgKGUuc3RvcmFnZUFyZWEgPT09IGdldFN0cmluZ1N0b3JhZ2UoKSAmJiBlLmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgbGV0IG5ld1ZhbHVlO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IEpTT04ucGFyc2UoZS5uZXdWYWx1ZSB8fCBcIlwiKTtcbiAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYWxsYmFjayhuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInN0b3JhZ2VcIiwgc3RvcmFnZUV2ZW50Q2FsbGJhY2spO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzdG9yYWdlXCIsIHN0b3JhZ2VFdmVudENhbGxiYWNrKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfVxuICByZXR1cm4gc3RvcmFnZTtcbn1cbmNvbnN0IGRlZmF1bHRTdG9yYWdlID0gY3JlYXRlSlNPTlN0b3JhZ2UoXG4gICgpID0+IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cubG9jYWxTdG9yYWdlIDogdm9pZCAwXG4pO1xuZnVuY3Rpb24gYXRvbVdpdGhTdG9yYWdlKGtleSwgaW5pdGlhbFZhbHVlLCBzdG9yYWdlID0gZGVmYXVsdFN0b3JhZ2UsIG9wdGlvbnMpIHtcbiAgY29uc3QgZ2V0T25Jbml0ID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5nZXRPbkluaXQ7XG4gIGNvbnN0IGJhc2VBdG9tID0gYXRvbShcbiAgICBnZXRPbkluaXQgPyBzdG9yYWdlLmdldEl0ZW0oa2V5LCBpbml0aWFsVmFsdWUpIDogaW5pdGlhbFZhbHVlXG4gICk7XG4gIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGJhc2VBdG9tLmRlYnVnUHJpdmF0ZSA9IHRydWU7XG4gIH1cbiAgYmFzZUF0b20ub25Nb3VudCA9IChzZXRBdG9tKSA9PiB7XG4gICAgaWYgKCFnZXRPbkluaXQpIHtcbiAgICAgIHNldEF0b20oc3RvcmFnZS5nZXRJdGVtKGtleSwgaW5pdGlhbFZhbHVlKSk7XG4gICAgfVxuICAgIGxldCB1bnN1YjtcbiAgICBpZiAoc3RvcmFnZS5zdWJzY3JpYmUpIHtcbiAgICAgIHVuc3ViID0gc3RvcmFnZS5zdWJzY3JpYmUoa2V5LCBzZXRBdG9tLCBpbml0aWFsVmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdW5zdWI7XG4gIH07XG4gIGNvbnN0IGFuQXRvbSA9IGF0b20oXG4gICAgKGdldCkgPT4gZ2V0KGJhc2VBdG9tKSxcbiAgICAoZ2V0LCBzZXQsIHVwZGF0ZSkgPT4ge1xuICAgICAgY29uc3QgbmV4dFZhbHVlID0gdHlwZW9mIHVwZGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gdXBkYXRlKGdldChiYXNlQXRvbSkpIDogdXBkYXRlO1xuICAgICAgaWYgKG5leHRWYWx1ZSA9PT0gUkVTRVQpIHtcbiAgICAgICAgc2V0KGJhc2VBdG9tLCBpbml0aWFsVmFsdWUpO1xuICAgICAgICByZXR1cm4gc3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gICAgICB9XG4gICAgICBpZiAobmV4dFZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICByZXR1cm4gbmV4dFZhbHVlLnRoZW4oKHJlc29sdmVkVmFsdWUpID0+IHtcbiAgICAgICAgICBzZXQoYmFzZUF0b20sIHJlc29sdmVkVmFsdWUpO1xuICAgICAgICAgIHJldHVybiBzdG9yYWdlLnNldEl0ZW0oa2V5LCByZXNvbHZlZFZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBzZXQoYmFzZUF0b20sIG5leHRWYWx1ZSk7XG4gICAgICByZXR1cm4gc3RvcmFnZS5zZXRJdGVtKGtleSwgbmV4dFZhbHVlKTtcbiAgICB9XG4gICk7XG4gIHJldHVybiBhbkF0b207XG59XG5cbmZ1bmN0aW9uIGF0b21XaXRoT2JzZXJ2YWJsZShnZXRPYnNlcnZhYmxlLCBvcHRpb25zKSB7XG4gIGNvbnN0IHJldHVyblJlc3VsdERhdGEgPSAocmVzdWx0KSA9PiB7XG4gICAgaWYgKFwiZVwiIGluIHJlc3VsdCkge1xuICAgICAgdGhyb3cgcmVzdWx0LmU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQuZDtcbiAgfTtcbiAgY29uc3Qgb2JzZXJ2YWJsZVJlc3VsdEF0b20gPSBhdG9tKChnZXQpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IG9ic2VydmFibGUgPSBnZXRPYnNlcnZhYmxlKGdldCk7XG4gICAgY29uc3QgaXRzZWxmID0gKF9hID0gb2JzZXJ2YWJsZVtTeW1ib2wub2JzZXJ2YWJsZV0pID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKG9ic2VydmFibGUpO1xuICAgIGlmIChpdHNlbGYpIHtcbiAgICAgIG9ic2VydmFibGUgPSBpdHNlbGY7XG4gICAgfVxuICAgIGxldCByZXNvbHZlO1xuICAgIGNvbnN0IG1ha2VQZW5kaW5nID0gKCkgPT4gbmV3IFByb21pc2UoKHIpID0+IHtcbiAgICAgIHJlc29sdmUgPSByO1xuICAgIH0pO1xuICAgIGNvbnN0IGluaXRpYWxSZXN1bHQgPSBvcHRpb25zICYmIFwiaW5pdGlhbFZhbHVlXCIgaW4gb3B0aW9ucyA/IHtcbiAgICAgIGQ6IHR5cGVvZiBvcHRpb25zLmluaXRpYWxWYWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gb3B0aW9ucy5pbml0aWFsVmFsdWUoKSA6IG9wdGlvbnMuaW5pdGlhbFZhbHVlXG4gICAgfSA6IG1ha2VQZW5kaW5nKCk7XG4gICAgbGV0IHNldFJlc3VsdDtcbiAgICBsZXQgbGFzdFJlc3VsdDtcbiAgICBjb25zdCBsaXN0ZW5lciA9IChyZXN1bHQpID0+IHtcbiAgICAgIGxhc3RSZXN1bHQgPSByZXN1bHQ7XG4gICAgICByZXNvbHZlID09IG51bGwgPyB2b2lkIDAgOiByZXNvbHZlKHJlc3VsdCk7XG4gICAgICBzZXRSZXN1bHQgPT0gbnVsbCA/IHZvaWQgMCA6IHNldFJlc3VsdChyZXN1bHQpO1xuICAgIH07XG4gICAgbGV0IHN1YnNjcmlwdGlvbjtcbiAgICBsZXQgdGltZXI7XG4gICAgY29uc3QgaXNOb3RNb3VudGVkID0gKCkgPT4gIXNldFJlc3VsdDtcbiAgICBjb25zdCBzdGFydCA9ICgpID0+IHtcbiAgICAgIGlmIChzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICB9XG4gICAgICBzdWJzY3JpcHRpb24gPSBvYnNlcnZhYmxlLnN1YnNjcmliZSh7XG4gICAgICAgIG5leHQ6IChkKSA9PiBsaXN0ZW5lcih7IGQgfSksXG4gICAgICAgIGVycm9yOiAoZSkgPT4gbGlzdGVuZXIoeyBlIH0pLFxuICAgICAgICBjb21wbGV0ZTogKCkgPT4ge1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChpc05vdE1vdW50ZWQoKSAmJiAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy51bnN0YWJsZV90aW1lb3V0KSkge1xuICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uID0gdm9pZCAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgb3B0aW9ucy51bnN0YWJsZV90aW1lb3V0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHN0YXJ0KCk7XG4gICAgY29uc3QgcmVzdWx0QXRvbSA9IGF0b20obGFzdFJlc3VsdCB8fCBpbml0aWFsUmVzdWx0KTtcbiAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIHJlc3VsdEF0b20uZGVidWdQcml2YXRlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmVzdWx0QXRvbS5vbk1vdW50ID0gKHVwZGF0ZSkgPT4ge1xuICAgICAgc2V0UmVzdWx0ID0gdXBkYXRlO1xuICAgICAgaWYgKGxhc3RSZXN1bHQpIHtcbiAgICAgICAgdXBkYXRlKGxhc3RSZXN1bHQpO1xuICAgICAgfVxuICAgICAgaWYgKHN1YnNjcmlwdGlvbikge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhcnQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHNldFJlc3VsdCA9IHZvaWQgMDtcbiAgICAgICAgaWYgKHN1YnNjcmlwdGlvbikge1xuICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgIHN1YnNjcmlwdGlvbiA9IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBbcmVzdWx0QXRvbSwgb2JzZXJ2YWJsZSwgbWFrZVBlbmRpbmcsIHN0YXJ0LCBpc05vdE1vdW50ZWRdO1xuICB9KTtcbiAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgb2JzZXJ2YWJsZVJlc3VsdEF0b20uZGVidWdQcml2YXRlID0gdHJ1ZTtcbiAgfVxuICBjb25zdCBvYnNlcnZhYmxlQXRvbSA9IGF0b20oXG4gICAgKGdldCkgPT4ge1xuICAgICAgY29uc3QgW3Jlc3VsdEF0b21dID0gZ2V0KG9ic2VydmFibGVSZXN1bHRBdG9tKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGdldChyZXN1bHRBdG9tKTtcbiAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQudGhlbihyZXR1cm5SZXN1bHREYXRhKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXR1cm5SZXN1bHREYXRhKHJlc3VsdCk7XG4gICAgfSxcbiAgICAoZ2V0LCBzZXQsIGRhdGEpID0+IHtcbiAgICAgIGNvbnN0IFtyZXN1bHRBdG9tLCBvYnNlcnZhYmxlLCBtYWtlUGVuZGluZywgc3RhcnQsIGlzTm90TW91bnRlZF0gPSBnZXQob2JzZXJ2YWJsZVJlc3VsdEF0b20pO1xuICAgICAgaWYgKFwibmV4dFwiIGluIG9ic2VydmFibGUpIHtcbiAgICAgICAgaWYgKGlzTm90TW91bnRlZCgpKSB7XG4gICAgICAgICAgc2V0KHJlc3VsdEF0b20sIG1ha2VQZW5kaW5nKCkpO1xuICAgICAgICAgIHN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgb2JzZXJ2YWJsZS5uZXh0KGRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwib2JzZXJ2YWJsZSBpcyBub3Qgc3ViamVjdFwiKTtcbiAgICAgIH1cbiAgICB9XG4gICk7XG4gIHJldHVybiBvYnNlcnZhYmxlQXRvbTtcbn1cblxuY29uc3QgY2FjaGUxJDEgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IG1lbW8xID0gKGNyZWF0ZSwgZGVwMSkgPT4gKGNhY2hlMSQxLmhhcyhkZXAxKSA/IGNhY2hlMSQxIDogY2FjaGUxJDEuc2V0KGRlcDEsIGNyZWF0ZSgpKSkuZ2V0KGRlcDEpO1xuY29uc3QgTE9BRElORyA9IHsgc3RhdGU6IFwibG9hZGluZ1wiIH07XG5mdW5jdGlvbiBsb2FkYWJsZShhbkF0b20pIHtcbiAgcmV0dXJuIG1lbW8xKCgpID0+IHtcbiAgICBjb25zdCBsb2FkYWJsZUNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gICAgY29uc3QgcmVmcmVzaEF0b20gPSBhdG9tKDApO1xuICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgcmVmcmVzaEF0b20uZGVidWdQcml2YXRlID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgZGVyaXZlZEF0b20gPSBhdG9tKFxuICAgICAgKGdldCwgeyBzZXRTZWxmIH0pID0+IHtcbiAgICAgICAgZ2V0KHJlZnJlc2hBdG9tKTtcbiAgICAgICAgbGV0IHZhbHVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhbHVlID0gZ2V0KGFuQXRvbSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHsgc3RhdGU6IFwiaGFzRXJyb3JcIiwgZXJyb3IgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpKSB7XG4gICAgICAgICAgcmV0dXJuIHsgc3RhdGU6IFwiaGFzRGF0YVwiLCBkYXRhOiB2YWx1ZSB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSB2YWx1ZTtcbiAgICAgICAgY29uc3QgY2FjaGVkID0gbG9hZGFibGVDYWNoZS5nZXQocHJvbWlzZSk7XG4gICAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgICAgICB9XG4gICAgICAgIGxvYWRhYmxlQ2FjaGUuc2V0KHByb21pc2UsIExPQURJTkcpO1xuICAgICAgICBwcm9taXNlLnRoZW4oXG4gICAgICAgICAgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGxvYWRhYmxlQ2FjaGUuc2V0KHByb21pc2UsIHsgc3RhdGU6IFwiaGFzRGF0YVwiLCBkYXRhIH0pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBsb2FkYWJsZUNhY2hlLnNldChwcm9taXNlLCB7IHN0YXRlOiBcImhhc0Vycm9yXCIsIGVycm9yIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgKS5maW5hbGx5KHNldFNlbGYpO1xuICAgICAgICByZXR1cm4gTE9BRElORztcbiAgICAgIH0sXG4gICAgICAoX2dldCwgc2V0KSA9PiB7XG4gICAgICAgIHNldChyZWZyZXNoQXRvbSwgKGMpID0+IGMgKyAxKTtcbiAgICAgIH1cbiAgICApO1xuICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgZGVyaXZlZEF0b20uZGVidWdQcml2YXRlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGF0b20oKGdldCkgPT4gZ2V0KGRlcml2ZWRBdG9tKSk7XG4gIH0sIGFuQXRvbSk7XG59XG5cbmNvbnN0IGdldENhY2hlZCA9IChjLCBtLCBrKSA9PiAobS5oYXMoaykgPyBtIDogbS5zZXQoaywgYygpKSkuZ2V0KGspO1xuY29uc3QgY2FjaGUxID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jb25zdCBtZW1vMiA9IChjcmVhdGUsIGRlcDEsIGRlcDIpID0+IHtcbiAgY29uc3QgY2FjaGUyID0gZ2V0Q2FjaGVkKCgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBjYWNoZTEsIGRlcDEpO1xuICByZXR1cm4gZ2V0Q2FjaGVkKGNyZWF0ZSwgY2FjaGUyLCBkZXAyKTtcbn07XG5jb25zdCBkZWZhdWx0RmFsbGJhY2sgPSAoKSA9PiB2b2lkIDA7XG5mdW5jdGlvbiB1bndyYXAoYW5BdG9tLCBmYWxsYmFjayA9IGRlZmF1bHRGYWxsYmFjaykge1xuICByZXR1cm4gbWVtbzIoXG4gICAgKCkgPT4ge1xuICAgICAgY29uc3QgcHJvbWlzZUVycm9yQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgICAgIGNvbnN0IHByb21pc2VSZXN1bHRDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICAgICAgY29uc3QgcmVmcmVzaEF0b20gPSBhdG9tKDApO1xuICAgICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIHJlZnJlc2hBdG9tLmRlYnVnUHJpdmF0ZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBjb25zdCBwcm9taXNlQW5kVmFsdWVBdG9tID0gYXRvbShcbiAgICAgICAgKGdldCwgeyBzZXRTZWxmIH0pID0+IHtcbiAgICAgICAgICBnZXQocmVmcmVzaEF0b20pO1xuICAgICAgICAgIGNvbnN0IHByZXYgPSBnZXQocHJvbWlzZUFuZFZhbHVlQXRvbSk7XG4gICAgICAgICAgY29uc3QgcHJvbWlzZSA9IGdldChhbkF0b20pO1xuICAgICAgICAgIGlmICghKHByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdjogcHJvbWlzZSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJvbWlzZSA9PT0gKHByZXYgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXYucCkpIHtcbiAgICAgICAgICAgIGlmIChwcm9taXNlRXJyb3JDYWNoZS5oYXMocHJvbWlzZSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgcHJvbWlzZUVycm9yQ2FjaGUuZ2V0KHByb21pc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb21pc2VSZXN1bHRDYWNoZS5oYXMocHJvbWlzZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwOiBwcm9taXNlLFxuICAgICAgICAgICAgICAgIHY6IHByb21pc2VSZXN1bHRDYWNoZS5nZXQocHJvbWlzZSlcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHByb21pc2UgIT09IChwcmV2ID09IG51bGwgPyB2b2lkIDAgOiBwcmV2LnApKSB7XG4gICAgICAgICAgICBwcm9taXNlLnRoZW4oXG4gICAgICAgICAgICAgICh2KSA9PiBwcm9taXNlUmVzdWx0Q2FjaGUuc2V0KHByb21pc2UsIHYpLFxuICAgICAgICAgICAgICAoZSkgPT4gcHJvbWlzZUVycm9yQ2FjaGUuc2V0KHByb21pc2UsIGUpXG4gICAgICAgICAgICApLmZpbmFsbHkoc2V0U2VsZik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcmV2ICYmIFwidlwiIGluIHByZXYpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHA6IHByb21pc2UsIGY6IGZhbGxiYWNrKHByZXYudiksIHY6IHByZXYudiB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4geyBwOiBwcm9taXNlLCBmOiBmYWxsYmFjaygpIH07XG4gICAgICAgIH0sXG4gICAgICAgIChfZ2V0LCBzZXQpID0+IHtcbiAgICAgICAgICBzZXQocmVmcmVzaEF0b20sIChjKSA9PiBjICsgMSk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBwcm9taXNlQW5kVmFsdWVBdG9tLmluaXQgPSB2b2lkIDA7XG4gICAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgcHJvbWlzZUFuZFZhbHVlQXRvbS5kZWJ1Z1ByaXZhdGUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGF0b20oXG4gICAgICAgIChnZXQpID0+IHtcbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IGdldChwcm9taXNlQW5kVmFsdWVBdG9tKTtcbiAgICAgICAgICBpZiAoXCJmXCIgaW4gc3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZS5mO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc3RhdGUudjtcbiAgICAgICAgfSxcbiAgICAgICAgKF9nZXQsIHNldCwgLi4uYXJncykgPT4gc2V0KGFuQXRvbSwgLi4uYXJncylcbiAgICAgICk7XG4gICAgfSxcbiAgICBhbkF0b20sXG4gICAgZmFsbGJhY2tcbiAgKTtcbn1cblxuZXhwb3J0IHsgUkVTRVQsIGF0b21GYW1pbHksIGF0b21XaXRoRGVmYXVsdCwgYXRvbVdpdGhPYnNlcnZhYmxlLCBhdG9tV2l0aFJlZHVjZXIsIGF0b21XaXRoUmVzZXQsIGF0b21XaXRoU3RvcmFnZSwgY3JlYXRlSlNPTlN0b3JhZ2UsIGZyZWV6ZUF0b20sIGZyZWV6ZUF0b21DcmVhdG9yLCBsb2FkYWJsZSwgc2VsZWN0QXRvbSwgc3BsaXRBdG9tLCB1bndyYXAgfTtcbiJdLCJuYW1lcyI6WyJhdG9tIiwiUkVTRVQiLCJTeW1ib2wiLCJlbnYiLCJNT0RFIiwiYXRvbVdpdGhSZXNldCIsImluaXRpYWxWYWx1ZSIsImFuQXRvbSIsImdldCIsInNldCIsInVwZGF0ZSIsIm5leHRWYWx1ZSIsImF0b21XaXRoUmVkdWNlciIsInJlZHVjZXIiLCJhY3Rpb24iLCJhdG9tRmFtaWx5IiwiaW5pdGlhbGl6ZUF0b20iLCJhcmVFcXVhbCIsInNob3VsZFJlbW92ZSIsImF0b21zIiwiTWFwIiwiY3JlYXRlQXRvbSIsInBhcmFtIiwiaXRlbSIsImtleSIsInZhbHVlIiwicmVtb3ZlIiwibmV3QXRvbSIsIkRhdGUiLCJub3ciLCJkZWxldGUiLCJzZXRTaG91bGRSZW1vdmUiLCJmbiIsImdldENhY2hlZCQyIiwiYyIsIm0iLCJrIiwiaGFzIiwiY2FjaGUxJDQiLCJXZWFrTWFwIiwibWVtbzMiLCJjcmVhdGUiLCJkZXAxIiwiZGVwMiIsImRlcDMiLCJjYWNoZTIiLCJjYWNoZTMiLCJzZWxlY3RBdG9tIiwic2VsZWN0b3IiLCJlcXVhbGl0eUZuIiwiT2JqZWN0IiwiaXMiLCJFTVBUWSIsInNlbGVjdFZhbHVlIiwicHJldlNsaWNlIiwic2xpY2UiLCJkZXJpdmVkQXRvbSIsInByZXYiLCJQcm9taXNlIiwiYWxsIiwidGhlbiIsImluaXQiLCJjYWNoZTEkMyIsIm1lbW8xJDEiLCJkZWVwRnJlZXplIiwib2JqIiwiZnJlZXplIiwicHJvcE5hbWVzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsIm5hbWUiLCJmcmVlemVBdG9tIiwiZnJvemVuQXRvbSIsIl9nZXQiLCJhcmciLCJmcmVlemVBdG9tQ3JlYXRvciIsInBhcmFtcyIsIm9yaWdSZWFkIiwicmVhZCIsIm9wdGlvbnMiLCJjYWxsIiwiZ2V0Q2FjaGVkJDEiLCJjYWNoZTEkMiIsIm1lbW8yJDEiLCJjYWNoZUtleUZvckVtcHR5S2V5RXh0cmFjdG9yIiwiaXNXcml0YWJsZSIsImF0b20yIiwid3JpdGUiLCJpc0Z1bmN0aW9uIiwieCIsInNwbGl0QXRvbSIsImFyckF0b20iLCJrZXlFeHRyYWN0b3IiLCJtYXBwaW5nQ2FjaGUiLCJnZXRNYXBwaW5nIiwiYXJyIiwibWFwcGluZyIsInByZXZNYXBwaW5nIiwiYXRvbUxpc3QiLCJrZXlMaXN0IiwiZm9yRWFjaCIsImluZGV4IiwiY2FjaGVkQXRvbSIsImluZGV4T2YiLCJwcmV2MiIsIm1hcHBpbmdBdG9tIiwiY3VyckFyciIsIm1hcHBpbmcyIiwiaW5kZXgyIiwibGVuZ3RoIiwicHJldkl0ZW0iLCJFcnJvciIsImFycjIiLCJuZXh0SXRlbSIsImV2ZXJ5IiwiaSIsImRlYnVnUHJpdmF0ZSIsInNwbGl0dGVkQXRvbSIsInR5cGUiLCJiZWZvcmUiLCJpbmRleDEiLCJhdG9tV2l0aERlZmF1bHQiLCJnZXREZWZhdWx0Iiwib3ZlcndyaXR0ZW5BdG9tIiwib3ZlcndyaXR0ZW4iLCJwcmV2VmFsdWUiLCJpc1Byb21pc2VMaWtlIiwiY3JlYXRlSlNPTlN0b3JhZ2UiLCJnZXRTdHJpbmdTdG9yYWdlIiwibGFzdFN0ciIsImxhc3RWYWx1ZSIsInN0b3JhZ2UiLCJnZXRJdGVtIiwiX2EiLCJfYiIsInBhcnNlIiwic3RyMiIsIkpTT04iLCJzdHIiLCJzZXRJdGVtIiwibmV3VmFsdWUiLCJzdHJpbmdpZnkiLCJyZW1vdmVJdGVtIiwid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsIlN0b3JhZ2UiLCJzdWJzY3JpYmUiLCJjYWxsYmFjayIsInN0b3JhZ2VFdmVudENhbGxiYWNrIiwiZSIsInN0b3JhZ2VBcmVhIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImRlZmF1bHRTdG9yYWdlIiwibG9jYWxTdG9yYWdlIiwiYXRvbVdpdGhTdG9yYWdlIiwiZ2V0T25Jbml0IiwiYmFzZUF0b20iLCJvbk1vdW50Iiwic2V0QXRvbSIsInVuc3ViIiwicmVzb2x2ZWRWYWx1ZSIsImF0b21XaXRoT2JzZXJ2YWJsZSIsImdldE9ic2VydmFibGUiLCJyZXR1cm5SZXN1bHREYXRhIiwicmVzdWx0IiwiZCIsIm9ic2VydmFibGVSZXN1bHRBdG9tIiwib2JzZXJ2YWJsZSIsIml0c2VsZiIsInJlc29sdmUiLCJtYWtlUGVuZGluZyIsInIiLCJpbml0aWFsUmVzdWx0Iiwic2V0UmVzdWx0IiwibGFzdFJlc3VsdCIsImxpc3RlbmVyIiwic3Vic2NyaXB0aW9uIiwidGltZXIiLCJpc05vdE1vdW50ZWQiLCJzdGFydCIsImNsZWFyVGltZW91dCIsInVuc3Vic2NyaWJlIiwibmV4dCIsImVycm9yIiwiY29tcGxldGUiLCJ1bnN0YWJsZV90aW1lb3V0Iiwic2V0VGltZW91dCIsInJlc3VsdEF0b20iLCJvYnNlcnZhYmxlQXRvbSIsImRhdGEiLCJjYWNoZTEkMSIsIm1lbW8xIiwiTE9BRElORyIsInN0YXRlIiwibG9hZGFibGUiLCJsb2FkYWJsZUNhY2hlIiwicmVmcmVzaEF0b20iLCJzZXRTZWxmIiwicHJvbWlzZSIsImNhY2hlZCIsImZpbmFsbHkiLCJnZXRDYWNoZWQiLCJjYWNoZTEiLCJtZW1vMiIsImRlZmF1bHRGYWxsYmFjayIsInVud3JhcCIsImZhbGxiYWNrIiwicHJvbWlzZUVycm9yQ2FjaGUiLCJwcm9taXNlUmVzdWx0Q2FjaGUiLCJwcm9taXNlQW5kVmFsdWVBdG9tIiwidiIsInAiLCJmIiwiYXJncyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/jotai@2.6.1_@types+react@18.2.47_react@18.2.0/node_modules/jotai/esm/vanilla/utils.mjs\n");

/***/ })

};
;