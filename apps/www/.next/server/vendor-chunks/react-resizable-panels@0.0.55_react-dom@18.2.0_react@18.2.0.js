"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-resizable-panels@0.0.55_react-dom@18.2.0_react@18.2.0";
exports.ids = ["vendor-chunks/react-resizable-panels@0.0.55_react-dom@18.2.0_react@18.2.0"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/react-resizable-panels@0.0.55_react-dom@18.2.0_react@18.2.0/node_modules/react-resizable-panels/dist/react-resizable-panels.development.node.esm.js":
/*!************************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/react-resizable-panels@0.0.55_react-dom@18.2.0_react@18.2.0/node_modules/react-resizable-panels/dist/react-resizable-panels.development.node.esm.js ***!
  \************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Panel: () => (/* binding */ Panel),\n/* harmony export */   PanelGroup: () => (/* binding */ PanelGroup),\n/* harmony export */   PanelResizeHandle: () => (/* binding */ PanelResizeHandle),\n/* harmony export */   getAvailableGroupSizePixels: () => (/* binding */ getAvailableGroupSizePixels)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/../../node_modules/.pnpm/next@14.0.4_@opentelemetry+api@1.7.0_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n// This module exists to work around Webpack issue https://github.com/webpack/webpack/issues/14814\n// eslint-disable-next-line no-restricted-imports\nconst { createElement, createContext, forwardRef, useCallback, useContext, useEffect, useImperativeHandle, useLayoutEffect, useMemo, useRef, useState } = react__WEBPACK_IMPORTED_MODULE_0__;\n// `toString()` prevents bundlers from trying to `import { useId } from 'react'`\nconst useId = react__WEBPACK_IMPORTED_MODULE_0__[\"useId\".toString()];\nconst wrappedUseId = typeof useId === \"function\" ? useId : ()=>null;\nlet counter = 0;\nfunction useUniqueId(idFromParams = null) {\n    const idFromUseId = wrappedUseId();\n    const idRef = useRef(idFromParams || idFromUseId || null);\n    if (idRef.current === null) {\n        idRef.current = \"\" + counter++;\n    }\n    return idRef.current;\n}\nconst PanelGroupContext = createContext(null);\nPanelGroupContext.displayName = \"PanelGroupContext\";\nfunction PanelWithForwardedRef({ children = null, className: classNameFromProps = \"\", collapsedSize = 0, collapsible = false, defaultSize = null, forwardedRef, id: idFromProps = null, maxSize = null, minSize, onCollapse = null, onResize = null, order = null, style: styleFromProps = {}, tagName: Type = \"div\" }) {\n    const context = useContext(PanelGroupContext);\n    if (context === null) {\n        throw Error(`Panel components must be rendered within a PanelGroup container`);\n    }\n    const panelId = useUniqueId(idFromProps);\n    const { collapsePanel, expandPanel, getPanelSize, getPanelStyle, registerPanel, resizePanel, units, unregisterPanel } = context;\n    if (minSize == null) {\n        if (units === \"percentages\") {\n            // Mimics legacy default value for percentage based panel groups\n            minSize = 10;\n        } else {\n            // There is no meaningful minimum pixel default we can provide\n            minSize = 0;\n        }\n    }\n    // Use a ref to guard against users passing inline props\n    const callbacksRef = useRef({\n        onCollapse,\n        onResize\n    });\n    useEffect(()=>{\n        callbacksRef.current.onCollapse = onCollapse;\n        callbacksRef.current.onResize = onResize;\n    });\n    const style = getPanelStyle(panelId, defaultSize);\n    const committedValuesRef = useRef({\n        size: parseSizeFromStyle(style)\n    });\n    useRef({\n        callbacksRef,\n        collapsedSize,\n        collapsible,\n        defaultSize,\n        id: panelId,\n        idWasAutoGenerated: idFromProps == null,\n        maxSize,\n        minSize,\n        order\n    });\n    useImperativeHandle(forwardedRef, ()=>({\n            collapse: ()=>collapsePanel(panelId),\n            expand: ()=>expandPanel(panelId),\n            getCollapsed () {\n                return committedValuesRef.current.size === 0;\n            },\n            getId () {\n                return panelId;\n            },\n            getSize (units) {\n                return getPanelSize(panelId, units);\n            },\n            resize: (percentage, units)=>resizePanel(panelId, percentage, units)\n        }), [\n        collapsePanel,\n        expandPanel,\n        getPanelSize,\n        panelId,\n        resizePanel\n    ]);\n    return createElement(Type, {\n        children,\n        className: classNameFromProps,\n        \"data-panel\": \"\",\n        \"data-panel-collapsible\": collapsible || undefined,\n        \"data-panel-id\": panelId,\n        \"data-panel-size\": parseFloat(\"\" + style.flexGrow).toFixed(1),\n        id: `data-panel-id-${panelId}`,\n        style: {\n            ...style,\n            ...styleFromProps\n        }\n    });\n}\nconst Panel = forwardRef((props, ref)=>createElement(PanelWithForwardedRef, {\n        ...props,\n        forwardedRef: ref\n    }));\nPanelWithForwardedRef.displayName = \"Panel\";\nPanel.displayName = \"forwardRef(Panel)\";\n// HACK\nfunction parseSizeFromStyle(style) {\n    const { flexGrow } = style;\n    if (typeof flexGrow === \"string\") {\n        return parseFloat(flexGrow);\n    } else {\n        return flexGrow;\n    }\n}\nconst PRECISION = 10;\nfunction adjustByDelta(event, committedValues, idBefore, idAfter, deltaPixels, prevSizes, panelSizeBeforeCollapse, initialDragState) {\n    const { id: groupId, panels, units } = committedValues;\n    const groupSizePixels = units === \"pixels\" ? getAvailableGroupSizePixels(groupId) : NaN;\n    const { sizes: initialSizes } = initialDragState || {};\n    // If we're resizing by mouse or touch, use the initial sizes as a base.\n    // This has the benefit of causing force-collapsed panels to spring back open if drag is reversed.\n    const baseSizes = initialSizes || prevSizes;\n    const panelsArray = panelsMapToSortedArray(panels);\n    const nextSizes = baseSizes.concat();\n    let deltaApplied = 0;\n    // A resizing panel affects the panels before or after it.\n    //\n    // A negative delta means the panel immediately after the resizer should grow/expand by decreasing its offset.\n    // Other panels may also need to shrink/contract (and shift) to make room, depending on the min weights.\n    //\n    // A positive delta means the panel immediately before the resizer should \"expand\".\n    // This is accomplished by shrinking/contracting (and shifting) one or more of the panels after the resizer.\n    // Max-bounds check the panel being expanded first.\n    {\n        const pivotId = deltaPixels < 0 ? idAfter : idBefore;\n        const index = panelsArray.findIndex((panel)=>panel.current.id === pivotId);\n        const panel = panelsArray[index];\n        const baseSize = baseSizes[index];\n        const nextSize = safeResizePanel(units, groupSizePixels, panel, baseSize, baseSize + Math.abs(deltaPixels), event);\n        if (baseSize === nextSize) {\n            // If there's no room for the pivot panel to grow, we can ignore this drag update.\n            return baseSizes;\n        } else {\n            if (nextSize === 0 && baseSize > 0) {\n                panelSizeBeforeCollapse.set(pivotId, baseSize);\n            }\n            deltaPixels = deltaPixels < 0 ? baseSize - nextSize : nextSize - baseSize;\n        }\n    }\n    let pivotId = deltaPixels < 0 ? idBefore : idAfter;\n    let index = panelsArray.findIndex((panel)=>panel.current.id === pivotId);\n    while(true){\n        const panel = panelsArray[index];\n        const baseSize = baseSizes[index];\n        const deltaRemaining = Math.abs(deltaPixels) - Math.abs(deltaApplied);\n        const nextSize = safeResizePanel(units, groupSizePixels, panel, baseSize, baseSize - deltaRemaining, event);\n        if (baseSize !== nextSize) {\n            if (nextSize === 0 && baseSize > 0) {\n                panelSizeBeforeCollapse.set(panel.current.id, baseSize);\n            }\n            deltaApplied += baseSize - nextSize;\n            nextSizes[index] = nextSize;\n            if (deltaApplied.toPrecision(PRECISION).localeCompare(Math.abs(deltaPixels).toPrecision(PRECISION), undefined, {\n                numeric: true\n            }) >= 0) {\n                break;\n            }\n        }\n        if (deltaPixels < 0) {\n            if (--index < 0) {\n                break;\n            }\n        } else {\n            if (++index >= panelsArray.length) {\n                break;\n            }\n        }\n    }\n    // If we were unable to resize any of the panels panels, return the previous state.\n    // This will essentially bailout and ignore the \"mousemove\" event.\n    if (deltaApplied === 0) {\n        return baseSizes;\n    }\n    // Adjust the pivot panel before, but only by the amount that surrounding panels were able to shrink/contract.\n    pivotId = deltaPixels < 0 ? idAfter : idBefore;\n    index = panelsArray.findIndex((panel)=>panel.current.id === pivotId);\n    nextSizes[index] = baseSizes[index] + deltaApplied;\n    return nextSizes;\n}\nfunction callPanelCallbacks(panelsArray, sizes, panelIdToLastNotifiedSizeMap) {\n    sizes.forEach((size, index)=>{\n        const panelRef = panelsArray[index];\n        if (!panelRef) {\n            // Handle initial mount (when panels are registered too late to be in the panels array)\n            // The subsequent render+effects will handle the resize notification\n            return;\n        }\n        const { callbacksRef, collapsedSize, collapsible, id } = panelRef.current;\n        const lastNotifiedSize = panelIdToLastNotifiedSizeMap[id];\n        if (lastNotifiedSize !== size) {\n            panelIdToLastNotifiedSizeMap[id] = size;\n            const { onCollapse, onResize } = callbacksRef.current;\n            if (onResize) {\n                onResize(size, lastNotifiedSize);\n            }\n            if (collapsible && onCollapse) {\n                if ((lastNotifiedSize == null || lastNotifiedSize === collapsedSize) && size !== collapsedSize) {\n                    onCollapse(false);\n                } else if (lastNotifiedSize !== collapsedSize && size === collapsedSize) {\n                    onCollapse(true);\n                }\n            }\n        }\n    });\n}\nfunction getBeforeAndAfterIds(id, panelsArray) {\n    if (panelsArray.length < 2) {\n        return [\n            null,\n            null\n        ];\n    }\n    const index = panelsArray.findIndex((panel)=>panel.current.id === id);\n    if (index < 0) {\n        return [\n            null,\n            null\n        ];\n    }\n    const isLastPanel = index === panelsArray.length - 1;\n    const idBefore = isLastPanel ? panelsArray[index - 1].current.id : id;\n    const idAfter = isLastPanel ? id : panelsArray[index + 1].current.id;\n    return [\n        idBefore,\n        idAfter\n    ];\n}\nfunction getAvailableGroupSizePixels(groupId) {\n    const panelGroupElement = getPanelGroup(groupId);\n    if (panelGroupElement == null) {\n        return NaN;\n    }\n    const direction = panelGroupElement.getAttribute(\"data-panel-group-direction\");\n    const resizeHandles = getResizeHandlesForGroup(groupId);\n    if (direction === \"horizontal\") {\n        return panelGroupElement.offsetWidth - resizeHandles.reduce((accumulated, handle)=>{\n            return accumulated + handle.offsetWidth;\n        }, 0);\n    } else {\n        return panelGroupElement.offsetHeight - resizeHandles.reduce((accumulated, handle)=>{\n            return accumulated + handle.offsetHeight;\n        }, 0);\n    }\n}\n// This method returns a number between 1 and 100 representing\n// the % of the group's overall space this panel should occupy.\nfunction getFlexGrow(panels, id, sizes) {\n    if (panels.size === 1) {\n        return \"100\";\n    }\n    const panelsArray = panelsMapToSortedArray(panels);\n    const index = panelsArray.findIndex((panel)=>panel.current.id === id);\n    const size = sizes[index];\n    if (size == null) {\n        return \"0\";\n    }\n    return size.toPrecision(PRECISION);\n}\nfunction getPanel(id) {\n    const element = document.querySelector(`[data-panel-id=\"${id}\"]`);\n    if (element) {\n        return element;\n    }\n    return null;\n}\nfunction getPanelGroup(id) {\n    const element = document.querySelector(`[data-panel-group-id=\"${id}\"]`);\n    if (element) {\n        return element;\n    }\n    return null;\n}\nfunction getResizeHandle(id) {\n    const element = document.querySelector(`[data-panel-resize-handle-id=\"${id}\"]`);\n    if (element) {\n        return element;\n    }\n    return null;\n}\nfunction getResizeHandleIndex(id) {\n    const handles = getResizeHandles();\n    const index = handles.findIndex((handle)=>handle.getAttribute(\"data-panel-resize-handle-id\") === id);\n    return index ?? null;\n}\nfunction getResizeHandles() {\n    return Array.from(document.querySelectorAll(`[data-panel-resize-handle-id]`));\n}\nfunction getResizeHandlesForGroup(groupId) {\n    return Array.from(document.querySelectorAll(`[data-panel-resize-handle-id][data-panel-group-id=\"${groupId}\"]`));\n}\nfunction getResizeHandlePanelIds(groupId, handleId, panelsArray) {\n    const handle = getResizeHandle(handleId);\n    const handles = getResizeHandlesForGroup(groupId);\n    const index = handle ? handles.indexOf(handle) : -1;\n    const idBefore = panelsArray[index]?.current?.id ?? null;\n    const idAfter = panelsArray[index + 1]?.current?.id ?? null;\n    return [\n        idBefore,\n        idAfter\n    ];\n}\nfunction panelsMapToSortedArray(panels) {\n    return Array.from(panels.values()).sort((panelA, panelB)=>{\n        const orderA = panelA.current.order;\n        const orderB = panelB.current.order;\n        if (orderA == null && orderB == null) {\n            return 0;\n        } else if (orderA == null) {\n            return -1;\n        } else if (orderB == null) {\n            return 1;\n        } else {\n            return orderA - orderB;\n        }\n    });\n}\nfunction safeResizePanel(units, groupSizePixels, panel, prevSize, nextSize, event = null) {\n    let { collapsedSize, collapsible, maxSize, minSize } = panel.current;\n    if (units === \"pixels\") {\n        collapsedSize = collapsedSize / groupSizePixels * 100;\n        if (maxSize != null) {\n            maxSize = maxSize / groupSizePixels * 100;\n        }\n        minSize = minSize / groupSizePixels * 100;\n    }\n    if (collapsible) {\n        if (prevSize > collapsedSize) {\n            // Mimic VS COde behavior; collapse a panel if it's smaller than half of its min-size\n            if (nextSize <= minSize / 2 + collapsedSize) {\n                return collapsedSize;\n            }\n        } else {\n            const isKeyboardEvent = event?.type?.startsWith(\"key\");\n            if (!isKeyboardEvent) {\n                // Keyboard events should expand a collapsed panel to the min size,\n                // but mouse events should wait until the panel has reached its min size\n                // to avoid a visual flickering when dragging between collapsed and min size.\n                if (nextSize < minSize) {\n                    return collapsedSize;\n                }\n            }\n        }\n    }\n    return Math.min(maxSize != null ? maxSize : 100, Math.max(minSize, nextSize));\n}\nfunction validatePanelProps(units, panelData) {\n    const { collapsible, defaultSize, maxSize, minSize } = panelData.current;\n    // Basic props validation\n    if (minSize < 0 || units === \"percentages\" && minSize > 100) {\n        {\n            console.error(`Invalid Panel minSize provided, ${minSize}`);\n        }\n        panelData.current.minSize = 0;\n    }\n    if (maxSize != null) {\n        if (maxSize < 0 || units === \"percentages\" && maxSize > 100) {\n            {\n                console.error(`Invalid Panel maxSize provided, ${maxSize}`);\n            }\n            panelData.current.maxSize = null;\n        }\n    }\n    if (defaultSize !== null) {\n        if (defaultSize < 0 || units === \"percentages\" && defaultSize > 100) {\n            {\n                console.error(`Invalid Panel defaultSize provided, ${defaultSize}`);\n            }\n            panelData.current.defaultSize = null;\n        } else if (defaultSize < minSize && !collapsible) {\n            {\n                console.error(`Panel minSize (${minSize}) cannot be greater than defaultSize (${defaultSize})`);\n            }\n            panelData.current.defaultSize = minSize;\n        } else if (maxSize != null && defaultSize > maxSize) {\n            {\n                console.error(`Panel maxSize (${maxSize}) cannot be less than defaultSize (${defaultSize})`);\n            }\n            panelData.current.defaultSize = maxSize;\n        }\n    }\n}\nfunction validatePanelGroupLayout({ groupId, panels, nextSizes, prevSizes, units }) {\n    // Clone because this method modifies\n    nextSizes = [\n        ...nextSizes\n    ];\n    const panelsArray = panelsMapToSortedArray(panels);\n    const groupSizePixels = units === \"pixels\" ? getAvailableGroupSizePixels(groupId) : NaN;\n    let remainingSize = 0;\n    // First, check all of the proposed sizes against the min/max constraints\n    for(let index = 0; index < panelsArray.length; index++){\n        const panel = panelsArray[index];\n        const prevSize = prevSizes[index];\n        const nextSize = nextSizes[index];\n        const safeNextSize = safeResizePanel(units, groupSizePixels, panel, prevSize, nextSize);\n        if (nextSize != safeNextSize) {\n            remainingSize += nextSize - safeNextSize;\n            nextSizes[index] = safeNextSize;\n            {\n                console.error(`Invalid size (${nextSize}) specified for Panel \"${panel.current.id}\" given the panel's min/max size constraints`);\n            }\n        }\n    }\n    // If there is additional, left over space, assign it to any panel(s) that permits it\n    // (It's not worth taking multiple additional passes to evenly distribute)\n    if (remainingSize.toFixed(3) !== \"0.000\") {\n        for(let index = 0; index < panelsArray.length; index++){\n            const panel = panelsArray[index];\n            let { maxSize, minSize } = panel.current;\n            if (units === \"pixels\") {\n                minSize = minSize / groupSizePixels * 100;\n                if (maxSize != null) {\n                    maxSize = maxSize / groupSizePixels * 100;\n                }\n            }\n            const size = Math.min(maxSize != null ? maxSize : 100, Math.max(minSize, nextSizes[index] + remainingSize));\n            if (size !== nextSizes[index]) {\n                remainingSize -= size - nextSizes[index];\n                nextSizes[index] = size;\n                // Fuzzy comparison to account for imprecise floating point math\n                if (Math.abs(remainingSize).toFixed(3) === \"0.000\") {\n                    break;\n                }\n            }\n        }\n    }\n    // If we still have remainder, the requested layout wasn't valid and we should warn about it\n    if (remainingSize.toFixed(3) !== \"0.000\") {\n        {\n            console.error(`\"Invalid panel group configuration; default panel sizes should total 100% but was ${100 - remainingSize}%`);\n        }\n    }\n    return nextSizes;\n}\nfunction assert(expectedCondition, message = \"Assertion failed!\") {\n    if (!expectedCondition) {\n        console.error(message);\n        throw Error(message);\n    }\n}\n// https://www.w3.org/WAI/ARIA/apg/patterns/windowsplitter/\nfunction useWindowSplitterPanelGroupBehavior({ committedValuesRef, groupId, panels, setSizes, sizes, panelSizeBeforeCollapse }) {\n    useEffect(()=>{\n        const { direction, panels } = committedValuesRef.current;\n        const groupElement = getPanelGroup(groupId);\n        assert(groupElement != null, `No group found for id \"${groupId}\"`);\n        const { height, width } = groupElement.getBoundingClientRect();\n        const handles = getResizeHandlesForGroup(groupId);\n        const cleanupFunctions = handles.map((handle)=>{\n            const handleId = handle.getAttribute(\"data-panel-resize-handle-id\");\n            const panelsArray = panelsMapToSortedArray(panels);\n            const [idBefore, idAfter] = getResizeHandlePanelIds(groupId, handleId, panelsArray);\n            if (idBefore == null || idAfter == null) {\n                return ()=>{};\n            }\n            let currentMinSize = 0;\n            let currentMaxSize = 100;\n            let totalMinSize = 0;\n            let totalMaxSize = 0;\n            // A panel's effective min/max sizes also need to account for other panel's sizes.\n            panelsArray.forEach((panelData)=>{\n                const { id, maxSize, minSize } = panelData.current;\n                if (id === idBefore) {\n                    currentMinSize = minSize;\n                    currentMaxSize = maxSize != null ? maxSize : 100;\n                } else {\n                    totalMinSize += minSize;\n                    totalMaxSize += maxSize != null ? maxSize : 100;\n                }\n            });\n            const ariaValueMax = Math.min(currentMaxSize, 100 - totalMinSize);\n            const ariaValueMin = Math.max(currentMinSize, (panelsArray.length - 1) * 100 - totalMaxSize);\n            const flexGrow = getFlexGrow(panels, idBefore, sizes);\n            handle.setAttribute(\"aria-valuemax\", \"\" + Math.round(ariaValueMax));\n            handle.setAttribute(\"aria-valuemin\", \"\" + Math.round(ariaValueMin));\n            handle.setAttribute(\"aria-valuenow\", \"\" + Math.round(parseInt(flexGrow)));\n            const onKeyDown = (event)=>{\n                if (event.defaultPrevented) {\n                    return;\n                }\n                switch(event.key){\n                    case \"Enter\":\n                        {\n                            event.preventDefault();\n                            const index = panelsArray.findIndex((panel)=>panel.current.id === idBefore);\n                            if (index >= 0) {\n                                const panelData = panelsArray[index];\n                                const size = sizes[index];\n                                if (size != null) {\n                                    let delta = 0;\n                                    if (size.toPrecision(PRECISION) <= panelData.current.minSize.toPrecision(PRECISION)) {\n                                        delta = direction === \"horizontal\" ? width : height;\n                                    } else {\n                                        delta = -(direction === \"horizontal\" ? width : height);\n                                    }\n                                    const nextSizes = adjustByDelta(event, committedValuesRef.current, idBefore, idAfter, delta, sizes, panelSizeBeforeCollapse.current, null);\n                                    if (sizes !== nextSizes) {\n                                        setSizes(nextSizes);\n                                    }\n                                }\n                            }\n                            break;\n                        }\n                }\n            };\n            handle.addEventListener(\"keydown\", onKeyDown);\n            const panelBefore = getPanel(idBefore);\n            if (panelBefore != null) {\n                handle.setAttribute(\"aria-controls\", panelBefore.id);\n            }\n            return ()=>{\n                handle.removeAttribute(\"aria-valuemax\");\n                handle.removeAttribute(\"aria-valuemin\");\n                handle.removeAttribute(\"aria-valuenow\");\n                handle.removeEventListener(\"keydown\", onKeyDown);\n                if (panelBefore != null) {\n                    handle.removeAttribute(\"aria-controls\");\n                }\n            };\n        });\n        return ()=>{\n            cleanupFunctions.forEach((cleanupFunction)=>cleanupFunction());\n        };\n    }, [\n        committedValuesRef,\n        groupId,\n        panels,\n        panelSizeBeforeCollapse,\n        setSizes,\n        sizes\n    ]);\n}\nfunction useWindowSplitterResizeHandlerBehavior({ disabled, handleId, resizeHandler }) {\n    useEffect(()=>{\n        if (disabled || resizeHandler == null) {\n            return;\n        }\n        const handleElement = getResizeHandle(handleId);\n        if (handleElement == null) {\n            return;\n        }\n        const onKeyDown = (event)=>{\n            if (event.defaultPrevented) {\n                return;\n            }\n            switch(event.key){\n                case \"ArrowDown\":\n                case \"ArrowLeft\":\n                case \"ArrowRight\":\n                case \"ArrowUp\":\n                case \"End\":\n                case \"Home\":\n                    {\n                        event.preventDefault();\n                        resizeHandler(event);\n                        break;\n                    }\n                case \"F6\":\n                    {\n                        event.preventDefault();\n                        const handles = getResizeHandles();\n                        const index = getResizeHandleIndex(handleId);\n                        assert(index !== null);\n                        const nextIndex = event.shiftKey ? index > 0 ? index - 1 : handles.length - 1 : index + 1 < handles.length ? index + 1 : 0;\n                        const nextHandle = handles[nextIndex];\n                        nextHandle.focus();\n                        break;\n                    }\n            }\n        };\n        handleElement.addEventListener(\"keydown\", onKeyDown);\n        return ()=>{\n            handleElement.removeEventListener(\"keydown\", onKeyDown);\n        };\n    }, [\n        disabled,\n        handleId,\n        resizeHandler\n    ]);\n}\nfunction areEqual(arrayA, arrayB) {\n    if (arrayA.length !== arrayB.length) {\n        return false;\n    }\n    for(let index = 0; index < arrayA.length; index++){\n        if (arrayA[index] !== arrayB[index]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction getDragOffset(event, handleId, direction, initialOffset = 0, initialHandleElementRect = null) {\n    const isHorizontal = direction === \"horizontal\";\n    let pointerOffset = 0;\n    if (isMouseEvent(event)) {\n        pointerOffset = isHorizontal ? event.clientX : event.clientY;\n    } else if (isTouchEvent(event)) {\n        const firstTouch = event.touches[0];\n        pointerOffset = isHorizontal ? firstTouch.screenX : firstTouch.screenY;\n    } else {\n        return 0;\n    }\n    const handleElement = getResizeHandle(handleId);\n    const rect = initialHandleElementRect || handleElement.getBoundingClientRect();\n    const elementOffset = isHorizontal ? rect.left : rect.top;\n    return pointerOffset - elementOffset - initialOffset;\n}\n// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/movementX\nfunction getMovement(event, groupId, handleId, panelsArray, direction, prevSizes, initialDragState) {\n    const { dragOffset = 0, dragHandleRect, sizes: initialSizes } = initialDragState || {};\n    // If we're resizing by mouse or touch, use the initial sizes as a base.\n    // This has the benefit of causing force-collapsed panels to spring back open if drag is reversed.\n    const baseSizes = initialSizes || prevSizes;\n    if (isKeyDown(event)) {\n        const isHorizontal = direction === \"horizontal\";\n        const groupElement = getPanelGroup(groupId);\n        const rect = groupElement.getBoundingClientRect();\n        const groupSizeInPixels = isHorizontal ? rect.width : rect.height;\n        const denominator = event.shiftKey ? 10 : 100;\n        const delta = groupSizeInPixels / denominator;\n        let movement = 0;\n        switch(event.key){\n            case \"ArrowDown\":\n                movement = isHorizontal ? 0 : delta;\n                break;\n            case \"ArrowLeft\":\n                movement = isHorizontal ? -delta : 0;\n                break;\n            case \"ArrowRight\":\n                movement = isHorizontal ? delta : 0;\n                break;\n            case \"ArrowUp\":\n                movement = isHorizontal ? 0 : -delta;\n                break;\n            case \"End\":\n                movement = groupSizeInPixels;\n                break;\n            case \"Home\":\n                movement = -groupSizeInPixels;\n                break;\n        }\n        // If the Panel being resized is collapsible,\n        // we need to special case resizing around the minSize boundary.\n        // If contracting, Panels should shrink to their minSize and then snap to fully collapsed.\n        // If expanding from collapsed, they should snap back to their minSize.\n        const [idBefore, idAfter] = getResizeHandlePanelIds(groupId, handleId, panelsArray);\n        const targetPanelId = movement < 0 ? idBefore : idAfter;\n        const targetPanelIndex = panelsArray.findIndex((panel)=>panel.current.id === targetPanelId);\n        const targetPanel = panelsArray[targetPanelIndex];\n        if (targetPanel.current.collapsible) {\n            const baseSize = baseSizes[targetPanelIndex];\n            if (baseSize === 0 || baseSize.toPrecision(PRECISION) === targetPanel.current.minSize.toPrecision(PRECISION)) {\n                movement = movement < 0 ? -targetPanel.current.minSize * groupSizeInPixels : targetPanel.current.minSize * groupSizeInPixels;\n            }\n        }\n        return movement;\n    } else {\n        return getDragOffset(event, handleId, direction, dragOffset, dragHandleRect);\n    }\n}\nfunction isKeyDown(event) {\n    return event.type === \"keydown\";\n}\nfunction isMouseEvent(event) {\n    return event.type.startsWith(\"mouse\");\n}\nfunction isTouchEvent(event) {\n    return event.type.startsWith(\"touch\");\n}\nlet currentState = null;\nlet element = null;\nfunction getCursorStyle(state) {\n    switch(state){\n        case \"horizontal\":\n            return \"ew-resize\";\n        case \"horizontal-max\":\n            return \"w-resize\";\n        case \"horizontal-min\":\n            return \"e-resize\";\n        case \"vertical\":\n            return \"ns-resize\";\n        case \"vertical-max\":\n            return \"n-resize\";\n        case \"vertical-min\":\n            return \"s-resize\";\n    }\n}\nfunction resetGlobalCursorStyle() {\n    if (element !== null) {\n        document.head.removeChild(element);\n        currentState = null;\n        element = null;\n    }\n}\nfunction setGlobalCursorStyle(state) {\n    if (currentState === state) {\n        return;\n    }\n    currentState = state;\n    const style = getCursorStyle(state);\n    if (element === null) {\n        element = document.createElement(\"style\");\n        document.head.appendChild(element);\n    }\n    element.innerHTML = `*{cursor: ${style}!important;}`;\n}\nfunction debounce(callback, durationMs = 10) {\n    let timeoutId = null;\n    let callable = (...args)=>{\n        if (timeoutId !== null) {\n            clearTimeout(timeoutId);\n        }\n        timeoutId = setTimeout(()=>{\n            callback(...args);\n        }, durationMs);\n    };\n    return callable;\n}\n// Note that Panel ids might be user-provided (stable) or useId generated (non-deterministic)\n// so they should not be used as part of the serialization key.\n// Using an attribute like minSize instead should work well enough.\n// Pre-sorting by minSize allows remembering layouts even if panels are re-ordered/dragged.\nfunction getSerializationKey(panels) {\n    return panels.map((panel)=>{\n        const { minSize, order } = panel.current;\n        return order ? `${order}:${minSize}` : `${minSize}`;\n    }).sort((a, b)=>a.localeCompare(b)).join(\",\");\n}\nfunction loadSerializedPanelGroupState(autoSaveId, storage) {\n    try {\n        const serialized = storage.getItem(`PanelGroup:sizes:${autoSaveId}`);\n        if (serialized) {\n            const parsed = JSON.parse(serialized);\n            if (typeof parsed === \"object\" && parsed != null) {\n                return parsed;\n            }\n        }\n    } catch (error) {}\n    return null;\n}\nfunction savePanelGroupLayout(autoSaveId, panels, sizes, storage) {\n    const key = getSerializationKey(panels);\n    const state = loadSerializedPanelGroupState(autoSaveId, storage) || {};\n    state[key] = sizes;\n    try {\n        storage.setItem(`PanelGroup:sizes:${autoSaveId}`, JSON.stringify(state));\n    } catch (error) {\n        console.error(error);\n    }\n}\nconst debounceMap = {};\n// PanelGroup might be rendering in a server-side environment where localStorage is not available\n// or on a browser with cookies/storage disabled.\n// In either case, this function avoids accessing localStorage until needed,\n// and avoids throwing user-visible errors.\nfunction initializeDefaultStorage(storageObject) {\n    try {\n        if (typeof localStorage !== \"undefined\") {\n            // Bypass this check for future calls\n            storageObject.getItem = (name)=>{\n                return localStorage.getItem(name);\n            };\n            storageObject.setItem = (name, value)=>{\n                localStorage.setItem(name, value);\n            };\n        } else {\n            throw new Error(\"localStorage not supported in this environment\");\n        }\n    } catch (error) {\n        console.error(error);\n        storageObject.getItem = ()=>null;\n        storageObject.setItem = ()=>{};\n    }\n}\nconst defaultStorage = {\n    getItem: (name)=>{\n        initializeDefaultStorage(defaultStorage);\n        return defaultStorage.getItem(name);\n    },\n    setItem: (name, value)=>{\n        initializeDefaultStorage(defaultStorage);\n        defaultStorage.setItem(name, value);\n    }\n};\n// Initial drag state serves a few purposes:\n// * dragOffset:\n//   Resize is calculated by the distance between the current pointer event and the resize handle being \"dragged\"\n//   This value accounts for the initial offset when the touch/click starts, so the handle doesn't appear to \"jump\"\n// * dragHandleRect, sizes:\n//   When resizing is done via mouse/touch event– some initial state is stored\n//   so that any panels that contract will also expand if drag direction is reversed.\nfunction PanelGroupWithForwardedRef({ autoSaveId, children = null, className: classNameFromProps = \"\", direction, disablePointerEventsDuringResize = false, forwardedRef, id: idFromProps = null, onLayout, storage = defaultStorage, style: styleFromProps = {}, tagName: Type = \"div\", units = \"percentages\" }) {\n    const groupId = useUniqueId(idFromProps);\n    const [activeHandleId, setActiveHandleId] = useState(null);\n    const [panels, setPanels] = useState(new Map());\n    // When resizing is done via mouse/touch event–\n    // We store the initial Panel sizes in this ref, and apply move deltas to them instead of to the current sizes.\n    // This has the benefit of causing force-collapsed panels to spring back open if drag is reversed.\n    const initialDragStateRef = useRef(null);\n    const devWarningsRef = useRef({\n        didLogDefaultSizeWarning: false,\n        didLogIdAndOrderWarning: false,\n        didLogInvalidLayoutWarning: false,\n        prevPanelIds: []\n    });\n    // Use a ref to guard against users passing inline props\n    const callbacksRef = useRef({\n        onLayout\n    });\n    useEffect(()=>{\n        callbacksRef.current.onLayout = onLayout;\n    });\n    const panelIdToLastNotifiedSizeMapRef = useRef({});\n    // 0-1 values representing the relative size of each panel.\n    const [sizes, setSizes] = useState([]);\n    // Used to support imperative collapse/expand API.\n    const panelSizeBeforeCollapse = useRef(new Map());\n    const prevDeltaRef = useRef(0);\n    // Store committed values to avoid unnecessarily re-running memoization/effects functions.\n    const committedValuesRef = useRef({\n        direction,\n        id: groupId,\n        panels,\n        sizes,\n        units\n    });\n    useImperativeHandle(forwardedRef, ()=>({\n            getId: ()=>groupId,\n            getLayout: (unitsFromParams)=>{\n                const { sizes, units: unitsFromProps } = committedValuesRef.current;\n                const units = unitsFromParams ?? unitsFromProps;\n                if (units === \"pixels\") {\n                    const groupSizePixels = getAvailableGroupSizePixels(groupId);\n                    return sizes.map((size)=>size / 100 * groupSizePixels);\n                } else {\n                    return sizes;\n                }\n            },\n            setLayout: (sizes, unitsFromParams)=>{\n                const { id: groupId, panels, sizes: prevSizes, units } = committedValuesRef.current;\n                if ((unitsFromParams || units) === \"pixels\") {\n                    const groupSizePixels = getAvailableGroupSizePixels(groupId);\n                    sizes = sizes.map((size)=>size / groupSizePixels * 100);\n                }\n                const panelIdToLastNotifiedSizeMap = panelIdToLastNotifiedSizeMapRef.current;\n                const panelsArray = panelsMapToSortedArray(panels);\n                const nextSizes = validatePanelGroupLayout({\n                    groupId,\n                    panels,\n                    nextSizes: sizes,\n                    prevSizes,\n                    units\n                });\n                if (!areEqual(prevSizes, nextSizes)) {\n                    setSizes(nextSizes);\n                    callPanelCallbacks(panelsArray, nextSizes, panelIdToLastNotifiedSizeMap);\n                }\n            }\n        }), [\n        groupId\n    ]);\n    useWindowSplitterPanelGroupBehavior({\n        committedValuesRef,\n        groupId,\n        panels,\n        setSizes,\n        sizes,\n        panelSizeBeforeCollapse\n    });\n    // Notify external code when sizes have changed.\n    useEffect(()=>{\n        const { onLayout } = callbacksRef.current;\n        const { panels, sizes } = committedValuesRef.current;\n        // Don't commit layout until all panels have registered and re-rendered with their actual sizes.\n        if (sizes.length > 0) {\n            if (onLayout) {\n                onLayout(sizes);\n            }\n            const panelIdToLastNotifiedSizeMap = panelIdToLastNotifiedSizeMapRef.current;\n            // When possible, we notify before the next render so that rendering work can be batched together.\n            // Some cases are difficult to detect though,\n            // for example– panels that are conditionally rendered can affect the size of neighboring panels.\n            // In this case, the best we can do is notify on commit.\n            // The callPanelCallbacks() uses its own memoization to avoid notifying panels twice in these cases.\n            const panelsArray = panelsMapToSortedArray(panels);\n            callPanelCallbacks(panelsArray, sizes, panelIdToLastNotifiedSizeMap);\n        }\n    }, [\n        sizes\n    ]);\n    useEffect(()=>{\n        // If this panel has been configured to persist sizing information, save sizes to local storage.\n        if (autoSaveId) {\n            if (sizes.length === 0 || sizes.length !== panels.size) {\n                return;\n            }\n            const panelsArray = panelsMapToSortedArray(panels);\n            // Limit the frequency of localStorage updates.\n            if (!debounceMap[autoSaveId]) {\n                debounceMap[autoSaveId] = debounce(savePanelGroupLayout, 100);\n            }\n            debounceMap[autoSaveId](autoSaveId, panelsArray, sizes, storage);\n        }\n        {\n            const { didLogIdAndOrderWarning, prevPanelIds } = devWarningsRef.current;\n            if (!didLogIdAndOrderWarning) {\n                const { panels } = committedValuesRef.current;\n                const panelIds = Array.from(panels.keys());\n                devWarningsRef.current.prevPanelIds = panelIds;\n                const panelsHaveChanged = prevPanelIds.length > 0 && !areEqual(prevPanelIds, panelIds);\n                if (panelsHaveChanged) {\n                    if (Array.from(panels.values()).find((panel)=>panel.current.idWasAutoGenerated || panel.current.order == null)) {\n                        devWarningsRef.current.didLogIdAndOrderWarning = true;\n                        console.warn(`WARNING: Panel id and order props recommended when panels are dynamically rendered`);\n                    }\n                }\n            }\n        }\n    }, [\n        autoSaveId,\n        panels,\n        sizes,\n        storage\n    ]);\n    const getPanelSize = useCallback((id, unitsFromParams)=>{\n        const { panels, units: unitsFromProps } = committedValuesRef.current;\n        const panelsArray = panelsMapToSortedArray(panels);\n        const index = panelsArray.findIndex((panel)=>panel.current.id === id);\n        const size = sizes[index];\n        const units = unitsFromParams ?? unitsFromProps;\n        if (units === \"pixels\") {\n            const groupSizePixels = getAvailableGroupSizePixels(groupId);\n            return size / 100 * groupSizePixels;\n        } else {\n            return size;\n        }\n    }, [\n        groupId,\n        sizes\n    ]);\n    const getPanelStyle = useCallback((id, defaultSize)=>{\n        const { panels } = committedValuesRef.current;\n        // Before mounting, Panels will not yet have registered themselves.\n        // This includes server rendering.\n        // At this point the best we can do is render everything with the same size.\n        if (panels.size === 0) {\n            {\n                if (!devWarningsRef.current.didLogDefaultSizeWarning) {\n                    if (defaultSize == null) {\n                        devWarningsRef.current.didLogDefaultSizeWarning = true;\n                        console.warn(`WARNING: Panel defaultSize prop recommended to avoid layout shift after server rendering`);\n                    }\n                }\n            }\n            return {\n                flexBasis: 0,\n                flexGrow: defaultSize != null ? defaultSize : undefined,\n                flexShrink: 1,\n                // Without this, Panel sizes may be unintentionally overridden by their content.\n                overflow: \"hidden\"\n            };\n        }\n        const flexGrow = getFlexGrow(panels, id, sizes);\n        return {\n            flexBasis: 0,\n            flexGrow,\n            flexShrink: 1,\n            // Without this, Panel sizes may be unintentionally overridden by their content.\n            overflow: \"hidden\",\n            // Disable pointer events inside of a panel during resize.\n            // This avoid edge cases like nested iframes.\n            pointerEvents: disablePointerEventsDuringResize && activeHandleId !== null ? \"none\" : undefined\n        };\n    }, [\n        activeHandleId,\n        disablePointerEventsDuringResize,\n        sizes\n    ]);\n    const registerPanel = useCallback((id, panelRef)=>{\n        const { units } = committedValuesRef.current;\n        validatePanelProps(units, panelRef);\n        setPanels((prevPanels)=>{\n            if (prevPanels.has(id)) {\n                return prevPanels;\n            }\n            const nextPanels = new Map(prevPanels);\n            nextPanels.set(id, panelRef);\n            return nextPanels;\n        });\n    }, []);\n    const registerResizeHandle = useCallback((handleId)=>{\n        const resizeHandler = (event)=>{\n            event.preventDefault();\n            const { direction, panels, sizes: prevSizes } = committedValuesRef.current;\n            const panelsArray = panelsMapToSortedArray(panels);\n            const [idBefore, idAfter] = getResizeHandlePanelIds(groupId, handleId, panelsArray);\n            if (idBefore == null || idAfter == null) {\n                return;\n            }\n            let movement = getMovement(event, groupId, handleId, panelsArray, direction, prevSizes, initialDragStateRef.current);\n            if (movement === 0) {\n                return;\n            }\n            const groupElement = getPanelGroup(groupId);\n            const rect = groupElement.getBoundingClientRect();\n            const isHorizontal = direction === \"horizontal\";\n            // Support RTL layouts\n            if (document.dir === \"rtl\" && isHorizontal) {\n                movement = -movement;\n            }\n            const size = isHorizontal ? rect.width : rect.height;\n            const delta = movement / size * 100;\n            // If a validateLayout method has been provided\n            // it's important to use it before updating the mouse cursor\n            const nextSizes = adjustByDelta(event, committedValuesRef.current, idBefore, idAfter, delta, prevSizes, panelSizeBeforeCollapse.current, initialDragStateRef.current);\n            const sizesChanged = !areEqual(prevSizes, nextSizes);\n            // Don't update cursor for resizes triggered by keyboard interactions.\n            if (isMouseEvent(event) || isTouchEvent(event)) {\n                // Watch for multiple subsequent deltas; this might occur for tiny cursor movements.\n                // In this case, Panel sizes might not change–\n                // but updating cursor in this scenario would cause a flicker.\n                if (prevDeltaRef.current != delta) {\n                    if (!sizesChanged) {\n                        // If the pointer has moved too far to resize the panel any further,\n                        // update the cursor style for a visual clue.\n                        // This mimics VS Code behavior.\n                        if (isHorizontal) {\n                            setGlobalCursorStyle(movement < 0 ? \"horizontal-min\" : \"horizontal-max\");\n                        } else {\n                            setGlobalCursorStyle(movement < 0 ? \"vertical-min\" : \"vertical-max\");\n                        }\n                    } else {\n                        // Reset the cursor style to the the normal resize cursor.\n                        setGlobalCursorStyle(isHorizontal ? \"horizontal\" : \"vertical\");\n                    }\n                }\n            }\n            if (sizesChanged) {\n                const panelIdToLastNotifiedSizeMap = panelIdToLastNotifiedSizeMapRef.current;\n                // It's okay to bypass in this case because we already validated above\n                setSizes(nextSizes);\n                // If resize change handlers have been declared, this is the time to call them.\n                // Trigger user callbacks after updating state, so that user code can override the sizes.\n                callPanelCallbacks(panelsArray, nextSizes, panelIdToLastNotifiedSizeMap);\n            }\n            prevDeltaRef.current = delta;\n        };\n        return resizeHandler;\n    }, [\n        groupId\n    ]);\n    const unregisterPanel = useCallback((id)=>{\n        setPanels((prevPanels)=>{\n            if (!prevPanels.has(id)) {\n                return prevPanels;\n            }\n            const nextPanels = new Map(prevPanels);\n            nextPanels.delete(id);\n            return nextPanels;\n        });\n    }, []);\n    const collapsePanel = useCallback((id)=>{\n        const { panels, sizes: prevSizes } = committedValuesRef.current;\n        const panel = panels.get(id);\n        if (panel == null) {\n            return;\n        }\n        const { collapsedSize, collapsible } = panel.current;\n        if (!collapsible) {\n            return;\n        }\n        const panelsArray = panelsMapToSortedArray(panels);\n        const index = panelsArray.indexOf(panel);\n        if (index < 0) {\n            return;\n        }\n        const currentSize = prevSizes[index];\n        if (currentSize === collapsedSize) {\n            // Panel is already collapsed.\n            return;\n        }\n        panelSizeBeforeCollapse.current.set(id, currentSize);\n        const [idBefore, idAfter] = getBeforeAndAfterIds(id, panelsArray);\n        if (idBefore == null || idAfter == null) {\n            return;\n        }\n        const isLastPanel = index === panelsArray.length - 1;\n        const delta = isLastPanel ? currentSize : collapsedSize - currentSize;\n        const nextSizes = adjustByDelta(null, committedValuesRef.current, idBefore, idAfter, delta, prevSizes, panelSizeBeforeCollapse.current, null);\n        if (prevSizes !== nextSizes) {\n            const panelIdToLastNotifiedSizeMap = panelIdToLastNotifiedSizeMapRef.current;\n            setSizes(nextSizes);\n            // If resize change handlers have been declared, this is the time to call them.\n            // Trigger user callbacks after updating state, so that user code can override the sizes.\n            callPanelCallbacks(panelsArray, nextSizes, panelIdToLastNotifiedSizeMap);\n        }\n    }, []);\n    const expandPanel = useCallback((id)=>{\n        const { panels, sizes: prevSizes } = committedValuesRef.current;\n        const panel = panels.get(id);\n        if (panel == null) {\n            return;\n        }\n        const { collapsedSize, minSize } = panel.current;\n        const sizeBeforeCollapse = panelSizeBeforeCollapse.current.get(id) || minSize;\n        if (!sizeBeforeCollapse) {\n            return;\n        }\n        const panelsArray = panelsMapToSortedArray(panels);\n        const index = panelsArray.indexOf(panel);\n        if (index < 0) {\n            return;\n        }\n        const currentSize = prevSizes[index];\n        if (currentSize !== collapsedSize) {\n            // Panel is already expanded.\n            return;\n        }\n        const [idBefore, idAfter] = getBeforeAndAfterIds(id, panelsArray);\n        if (idBefore == null || idAfter == null) {\n            return;\n        }\n        const isLastPanel = index === panelsArray.length - 1;\n        const delta = isLastPanel ? collapsedSize - sizeBeforeCollapse : sizeBeforeCollapse;\n        const nextSizes = adjustByDelta(null, committedValuesRef.current, idBefore, idAfter, delta, prevSizes, panelSizeBeforeCollapse.current, null);\n        if (prevSizes !== nextSizes) {\n            const panelIdToLastNotifiedSizeMap = panelIdToLastNotifiedSizeMapRef.current;\n            setSizes(nextSizes);\n            // If resize change handlers have been declared, this is the time to call them.\n            // Trigger user callbacks after updating state, so that user code can override the sizes.\n            callPanelCallbacks(panelsArray, nextSizes, panelIdToLastNotifiedSizeMap);\n        }\n    }, []);\n    const resizePanel = useCallback((id, nextSize, unitsFromParams)=>{\n        const { id: groupId, panels, sizes: prevSizes, units } = committedValuesRef.current;\n        if ((unitsFromParams || units) === \"pixels\") {\n            const groupSizePixels = getAvailableGroupSizePixels(groupId);\n            nextSize = nextSize / groupSizePixels * 100;\n        }\n        const panel = panels.get(id);\n        if (panel == null) {\n            return;\n        }\n        let { collapsedSize, collapsible, maxSize, minSize } = panel.current;\n        if (units === \"pixels\") {\n            const groupSizePixels = getAvailableGroupSizePixels(groupId);\n            minSize = minSize / groupSizePixels * 100;\n            if (maxSize != null) {\n                maxSize = maxSize / groupSizePixels * 100;\n            }\n        }\n        const panelsArray = panelsMapToSortedArray(panels);\n        const index = panelsArray.indexOf(panel);\n        if (index < 0) {\n            return;\n        }\n        const currentSize = prevSizes[index];\n        if (currentSize === nextSize) {\n            return;\n        }\n        if (collapsible && nextSize === collapsedSize) ;\n        else {\n            const unsafeNextSize = nextSize;\n            nextSize = Math.min(maxSize != null ? maxSize : 100, Math.max(minSize, nextSize));\n            {\n                if (unsafeNextSize !== nextSize) {\n                    console.error(`Invalid size (${unsafeNextSize}) specified for Panel \"${panel.current.id}\" given the panel's min/max size constraints`);\n                }\n            }\n        }\n        const [idBefore, idAfter] = getBeforeAndAfterIds(id, panelsArray);\n        if (idBefore == null || idAfter == null) {\n            return;\n        }\n        const isLastPanel = index === panelsArray.length - 1;\n        const delta = isLastPanel ? currentSize - nextSize : nextSize - currentSize;\n        const nextSizes = adjustByDelta(null, committedValuesRef.current, idBefore, idAfter, delta, prevSizes, panelSizeBeforeCollapse.current, null);\n        if (prevSizes !== nextSizes) {\n            const panelIdToLastNotifiedSizeMap = panelIdToLastNotifiedSizeMapRef.current;\n            setSizes(nextSizes);\n            // If resize change handlers have been declared, this is the time to call them.\n            // Trigger user callbacks after updating state, so that user code can override the sizes.\n            callPanelCallbacks(panelsArray, nextSizes, panelIdToLastNotifiedSizeMap);\n        }\n    }, []);\n    const context = useMemo(()=>({\n            activeHandleId,\n            collapsePanel,\n            direction,\n            expandPanel,\n            getPanelSize,\n            getPanelStyle,\n            groupId,\n            registerPanel,\n            registerResizeHandle,\n            resizePanel,\n            startDragging: (id, event)=>{\n                setActiveHandleId(id);\n                if (isMouseEvent(event) || isTouchEvent(event)) {\n                    const handleElement = getResizeHandle(id);\n                    initialDragStateRef.current = {\n                        dragHandleRect: handleElement.getBoundingClientRect(),\n                        dragOffset: getDragOffset(event, id, direction),\n                        sizes: committedValuesRef.current.sizes\n                    };\n                }\n            },\n            stopDragging: ()=>{\n                resetGlobalCursorStyle();\n                setActiveHandleId(null);\n                initialDragStateRef.current = null;\n            },\n            units,\n            unregisterPanel\n        }), [\n        activeHandleId,\n        collapsePanel,\n        direction,\n        expandPanel,\n        getPanelSize,\n        getPanelStyle,\n        groupId,\n        registerPanel,\n        registerResizeHandle,\n        resizePanel,\n        units,\n        unregisterPanel\n    ]);\n    const style = {\n        display: \"flex\",\n        flexDirection: direction === \"horizontal\" ? \"row\" : \"column\",\n        height: \"100%\",\n        overflow: \"hidden\",\n        width: \"100%\"\n    };\n    return createElement(PanelGroupContext.Provider, {\n        children: createElement(Type, {\n            children,\n            className: classNameFromProps,\n            \"data-panel-group\": \"\",\n            \"data-panel-group-direction\": direction,\n            \"data-panel-group-id\": groupId,\n            \"data-panel-group-units\": units,\n            style: {\n                ...style,\n                ...styleFromProps\n            }\n        }),\n        value: context\n    });\n}\nconst PanelGroup = forwardRef((props, ref)=>createElement(PanelGroupWithForwardedRef, {\n        ...props,\n        forwardedRef: ref\n    }));\nPanelGroupWithForwardedRef.displayName = \"PanelGroup\";\nPanelGroup.displayName = \"forwardRef(PanelGroup)\";\nfunction PanelResizeHandle({ children = null, className: classNameFromProps = \"\", disabled = false, id: idFromProps = null, onDragging, style: styleFromProps = {}, tagName: Type = \"div\" }) {\n    const divElementRef = useRef(null);\n    // Use a ref to guard against users passing inline props\n    const callbacksRef = useRef({\n        onDragging\n    });\n    useEffect(()=>{\n        callbacksRef.current.onDragging = onDragging;\n    });\n    const panelGroupContext = useContext(PanelGroupContext);\n    if (panelGroupContext === null) {\n        throw Error(`PanelResizeHandle components must be rendered within a PanelGroup container`);\n    }\n    const { activeHandleId, direction, groupId, registerResizeHandle, startDragging, stopDragging } = panelGroupContext;\n    const resizeHandleId = useUniqueId(idFromProps);\n    const isDragging = activeHandleId === resizeHandleId;\n    const [isFocused, setIsFocused] = useState(false);\n    const [resizeHandler, setResizeHandler] = useState(null);\n    const stopDraggingAndBlur = useCallback(()=>{\n        // Clicking on the drag handle shouldn't leave it focused;\n        // That would cause the PanelGroup to think it was still active.\n        const div = divElementRef.current;\n        div.blur();\n        stopDragging();\n        const { onDragging } = callbacksRef.current;\n        if (onDragging) {\n            onDragging(false);\n        }\n    }, [\n        stopDragging\n    ]);\n    useEffect(()=>{\n        if (disabled) {\n            setResizeHandler(null);\n        } else {\n            const resizeHandler = registerResizeHandle(resizeHandleId);\n            setResizeHandler(()=>resizeHandler);\n        }\n    }, [\n        disabled,\n        resizeHandleId,\n        registerResizeHandle\n    ]);\n    useEffect(()=>{\n        if (disabled || resizeHandler == null || !isDragging) {\n            return;\n        }\n        const onMove = (event)=>{\n            resizeHandler(event);\n        };\n        const onMouseLeave = (event)=>{\n            resizeHandler(event);\n        };\n        const divElement = divElementRef.current;\n        const targetDocument = divElement.ownerDocument;\n        targetDocument.body.addEventListener(\"contextmenu\", stopDraggingAndBlur);\n        targetDocument.body.addEventListener(\"mousemove\", onMove);\n        targetDocument.body.addEventListener(\"touchmove\", onMove);\n        targetDocument.body.addEventListener(\"mouseleave\", onMouseLeave);\n        window.addEventListener(\"mouseup\", stopDraggingAndBlur);\n        window.addEventListener(\"touchend\", stopDraggingAndBlur);\n        return ()=>{\n            targetDocument.body.removeEventListener(\"contextmenu\", stopDraggingAndBlur);\n            targetDocument.body.removeEventListener(\"mousemove\", onMove);\n            targetDocument.body.removeEventListener(\"touchmove\", onMove);\n            targetDocument.body.removeEventListener(\"mouseleave\", onMouseLeave);\n            window.removeEventListener(\"mouseup\", stopDraggingAndBlur);\n            window.removeEventListener(\"touchend\", stopDraggingAndBlur);\n        };\n    }, [\n        direction,\n        disabled,\n        isDragging,\n        resizeHandler,\n        stopDraggingAndBlur\n    ]);\n    useWindowSplitterResizeHandlerBehavior({\n        disabled,\n        handleId: resizeHandleId,\n        resizeHandler\n    });\n    const style = {\n        cursor: getCursorStyle(direction),\n        touchAction: \"none\",\n        userSelect: \"none\"\n    };\n    return createElement(Type, {\n        children,\n        className: classNameFromProps,\n        \"data-resize-handle-active\": isDragging ? \"pointer\" : isFocused ? \"keyboard\" : undefined,\n        \"data-panel-group-direction\": direction,\n        \"data-panel-group-id\": groupId,\n        \"data-panel-resize-handle-enabled\": !disabled,\n        \"data-panel-resize-handle-id\": resizeHandleId,\n        onBlur: ()=>setIsFocused(false),\n        onFocus: ()=>setIsFocused(true),\n        onMouseDown: (event)=>{\n            startDragging(resizeHandleId, event.nativeEvent);\n            const { onDragging } = callbacksRef.current;\n            if (onDragging) {\n                onDragging(true);\n            }\n        },\n        onMouseUp: stopDraggingAndBlur,\n        onTouchCancel: stopDraggingAndBlur,\n        onTouchEnd: stopDraggingAndBlur,\n        onTouchStart: (event)=>{\n            startDragging(resizeHandleId, event.nativeEvent);\n            const { onDragging } = callbacksRef.current;\n            if (onDragging) {\n                onDragging(true);\n            }\n        },\n        ref: divElementRef,\n        role: \"separator\",\n        style: {\n            ...style,\n            ...styleFromProps\n        },\n        tabIndex: 0\n    });\n}\nPanelResizeHandle.displayName = \"PanelResizeHandle\";\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlYWN0LXJlc2l6YWJsZS1wYW5lbHNAMC4wLjU1X3JlYWN0LWRvbUAxOC4yLjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9yZWFjdC1yZXNpemFibGUtcGFuZWxzL2Rpc3QvcmVhY3QtcmVzaXphYmxlLXBhbmVscy5kZXZlbG9wbWVudC5ub2RlLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBK0I7QUFFL0Isa0dBQWtHO0FBRWxHLGlEQUFpRDtBQUVqRCxNQUFNLEVBQ0pDLGFBQWEsRUFDYkMsYUFBYSxFQUNiQyxVQUFVLEVBQ1ZDLFdBQVcsRUFDWEMsVUFBVSxFQUNWQyxTQUFTLEVBQ1RDLG1CQUFtQixFQUNuQkMsZUFBZSxFQUNmQyxPQUFPLEVBQ1BDLE1BQU0sRUFDTkMsUUFBUSxFQUNULEdBQUdYLGtDQUFLQTtBQUVULGdGQUFnRjtBQUNoRixNQUFNWSxRQUFRWixrQ0FBSyxDQUFDLFFBQVFhLFFBQVEsR0FBRztBQUV2QyxNQUFNQyxlQUFlLE9BQU9GLFVBQVUsYUFBYUEsUUFBUSxJQUFNO0FBQ2pFLElBQUlHLFVBQVU7QUFDZCxTQUFTQyxZQUFZQyxlQUFlLElBQUk7SUFDdEMsTUFBTUMsY0FBY0o7SUFDcEIsTUFBTUssUUFBUVQsT0FBT08sZ0JBQWdCQyxlQUFlO0lBQ3BELElBQUlDLE1BQU1DLE9BQU8sS0FBSyxNQUFNO1FBQzFCRCxNQUFNQyxPQUFPLEdBQUcsS0FBS0w7SUFDdkI7SUFDQSxPQUFPSSxNQUFNQyxPQUFPO0FBQ3RCO0FBRUEsTUFBTUMsb0JBQW9CbkIsY0FBYztBQUN4Q21CLGtCQUFrQkMsV0FBVyxHQUFHO0FBRWhDLFNBQVNDLHNCQUFzQixFQUM3QkMsV0FBVyxJQUFJLEVBQ2ZDLFdBQVdDLHFCQUFxQixFQUFFLEVBQ2xDQyxnQkFBZ0IsQ0FBQyxFQUNqQkMsY0FBYyxLQUFLLEVBQ25CQyxjQUFjLElBQUksRUFDbEJDLFlBQVksRUFDWkMsSUFBSUMsY0FBYyxJQUFJLEVBQ3RCQyxVQUFVLElBQUksRUFDZEMsT0FBTyxFQUNQQyxhQUFhLElBQUksRUFDakJDLFdBQVcsSUFBSSxFQUNmQyxRQUFRLElBQUksRUFDWkMsT0FBT0MsaUJBQWlCLENBQUMsQ0FBQyxFQUMxQkMsU0FBU0MsT0FBTyxLQUFLLEVBQ3RCO0lBQ0MsTUFBTUMsVUFBVXJDLFdBQVdnQjtJQUMzQixJQUFJcUIsWUFBWSxNQUFNO1FBQ3BCLE1BQU1DLE1BQU0sQ0FBQywrREFBK0QsQ0FBQztJQUMvRTtJQUNBLE1BQU1DLFVBQVU1QixZQUFZZ0I7SUFDNUIsTUFBTSxFQUNKYSxhQUFhLEVBQ2JDLFdBQVcsRUFDWEMsWUFBWSxFQUNaQyxhQUFhLEVBQ2JDLGFBQWEsRUFDYkMsV0FBVyxFQUNYQyxLQUFLLEVBQ0xDLGVBQWUsRUFDaEIsR0FBR1Y7SUFDSixJQUFJUixXQUFXLE1BQU07UUFDbkIsSUFBSWlCLFVBQVUsZUFBZTtZQUMzQixnRUFBZ0U7WUFDaEVqQixVQUFVO1FBQ1osT0FBTztZQUNMLDhEQUE4RDtZQUM5REEsVUFBVTtRQUNaO0lBQ0Y7SUFFQSx3REFBd0Q7SUFDeEQsTUFBTW1CLGVBQWUzQyxPQUFPO1FBQzFCeUI7UUFDQUM7SUFDRjtJQUNBOUIsVUFBVTtRQUNSK0MsYUFBYWpDLE9BQU8sQ0FBQ2UsVUFBVSxHQUFHQTtRQUNsQ2tCLGFBQWFqQyxPQUFPLENBQUNnQixRQUFRLEdBQUdBO0lBQ2xDO0lBQ0EsTUFBTUUsUUFBUVUsY0FBY0osU0FBU2Y7SUFDckMsTUFBTXlCLHFCQUFxQjVDLE9BQU87UUFDaEM2QyxNQUFNQyxtQkFBbUJsQjtJQUMzQjtJQUNBNUIsT0FBTztRQUNMMkM7UUFDQTFCO1FBQ0FDO1FBQ0FDO1FBQ0FFLElBQUlhO1FBQ0phLG9CQUFvQnpCLGVBQWU7UUFDbkNDO1FBQ0FDO1FBQ0FHO0lBQ0Y7SUFDQTlCLG9CQUFvQnVCLGNBQWMsSUFBTztZQUN2QzRCLFVBQVUsSUFBTWIsY0FBY0Q7WUFDOUJlLFFBQVEsSUFBTWIsWUFBWUY7WUFDMUJnQjtnQkFDRSxPQUFPTixtQkFBbUJsQyxPQUFPLENBQUNtQyxJQUFJLEtBQUs7WUFDN0M7WUFDQU07Z0JBQ0UsT0FBT2pCO1lBQ1Q7WUFDQWtCLFNBQVFYLEtBQUs7Z0JBQ1gsT0FBT0osYUFBYUgsU0FBU087WUFDL0I7WUFDQVksUUFBUSxDQUFDQyxZQUFZYixRQUFVRCxZQUFZTixTQUFTb0IsWUFBWWI7UUFDbEUsSUFBSTtRQUFDTjtRQUFlQztRQUFhQztRQUFjSDtRQUFTTTtLQUFZO0lBQ3BFLE9BQU9qRCxjQUFjd0MsTUFBTTtRQUN6QmpCO1FBQ0FDLFdBQVdDO1FBQ1gsY0FBYztRQUNkLDBCQUEwQkUsZUFBZXFDO1FBQ3pDLGlCQUFpQnJCO1FBQ2pCLG1CQUFtQnNCLFdBQVcsS0FBSzVCLE1BQU02QixRQUFRLEVBQUVDLE9BQU8sQ0FBQztRQUMzRHJDLElBQUksQ0FBQyxjQUFjLEVBQUVhLFFBQVEsQ0FBQztRQUM5Qk4sT0FBTztZQUNMLEdBQUdBLEtBQUs7WUFDUixHQUFHQyxjQUFjO1FBQ25CO0lBQ0Y7QUFDRjtBQUNBLE1BQU04QixRQUFRbEUsV0FBVyxDQUFDbUUsT0FBT0MsTUFBUXRFLGNBQWNzQix1QkFBdUI7UUFDNUUsR0FBRytDLEtBQUs7UUFDUnhDLGNBQWN5QztJQUNoQjtBQUNBaEQsc0JBQXNCRCxXQUFXLEdBQUc7QUFDcEMrQyxNQUFNL0MsV0FBVyxHQUFHO0FBRXBCLE9BQU87QUFDUCxTQUFTa0MsbUJBQW1CbEIsS0FBSztJQUMvQixNQUFNLEVBQ0o2QixRQUFRLEVBQ1QsR0FBRzdCO0lBQ0osSUFBSSxPQUFPNkIsYUFBYSxVQUFVO1FBQ2hDLE9BQU9ELFdBQVdDO0lBQ3BCLE9BQU87UUFDTCxPQUFPQTtJQUNUO0FBQ0Y7QUFFQSxNQUFNSyxZQUFZO0FBRWxCLFNBQVNDLGNBQWNDLEtBQUssRUFBRUMsZUFBZSxFQUFFQyxRQUFRLEVBQUVDLE9BQU8sRUFBRUMsV0FBVyxFQUFFQyxTQUFTLEVBQUVDLHVCQUF1QixFQUFFQyxnQkFBZ0I7SUFDakksTUFBTSxFQUNKbEQsSUFBSW1ELE9BQU8sRUFDWEMsTUFBTSxFQUNOaEMsS0FBSyxFQUNOLEdBQUd3QjtJQUNKLE1BQU1TLGtCQUFrQmpDLFVBQVUsV0FBV2tDLDRCQUE0QkgsV0FBV0k7SUFDcEYsTUFBTSxFQUNKQyxPQUFPQyxZQUFZLEVBQ3BCLEdBQUdQLG9CQUFvQixDQUFDO0lBRXpCLHdFQUF3RTtJQUN4RSxrR0FBa0c7SUFDbEcsTUFBTVEsWUFBWUQsZ0JBQWdCVDtJQUNsQyxNQUFNVyxjQUFjQyx1QkFBdUJSO0lBQzNDLE1BQU1TLFlBQVlILFVBQVVJLE1BQU07SUFDbEMsSUFBSUMsZUFBZTtJQUVuQiwwREFBMEQ7SUFDMUQsRUFBRTtJQUNGLDhHQUE4RztJQUM5Ryx3R0FBd0c7SUFDeEcsRUFBRTtJQUNGLG1GQUFtRjtJQUNuRiw0R0FBNEc7SUFFNUcsbURBQW1EO0lBQ25EO1FBQ0UsTUFBTUMsVUFBVWpCLGNBQWMsSUFBSUQsVUFBVUQ7UUFDNUMsTUFBTW9CLFFBQVFOLFlBQVlPLFNBQVMsQ0FBQ0MsQ0FBQUEsUUFBU0EsTUFBTTlFLE9BQU8sQ0FBQ1csRUFBRSxLQUFLZ0U7UUFDbEUsTUFBTUcsUUFBUVIsV0FBVyxDQUFDTSxNQUFNO1FBQ2hDLE1BQU1HLFdBQVdWLFNBQVMsQ0FBQ08sTUFBTTtRQUNqQyxNQUFNSSxXQUFXQyxnQkFBZ0JsRCxPQUFPaUMsaUJBQWlCYyxPQUFPQyxVQUFVQSxXQUFXRyxLQUFLQyxHQUFHLENBQUN6QixjQUFjSjtRQUM1RyxJQUFJeUIsYUFBYUMsVUFBVTtZQUN6QixrRkFBa0Y7WUFDbEYsT0FBT1g7UUFDVCxPQUFPO1lBQ0wsSUFBSVcsYUFBYSxLQUFLRCxXQUFXLEdBQUc7Z0JBQ2xDbkIsd0JBQXdCd0IsR0FBRyxDQUFDVCxTQUFTSTtZQUN2QztZQUNBckIsY0FBY0EsY0FBYyxJQUFJcUIsV0FBV0MsV0FBV0EsV0FBV0Q7UUFDbkU7SUFDRjtJQUNBLElBQUlKLFVBQVVqQixjQUFjLElBQUlGLFdBQVdDO0lBQzNDLElBQUltQixRQUFRTixZQUFZTyxTQUFTLENBQUNDLENBQUFBLFFBQVNBLE1BQU05RSxPQUFPLENBQUNXLEVBQUUsS0FBS2dFO0lBQ2hFLE1BQU8sS0FBTTtRQUNYLE1BQU1HLFFBQVFSLFdBQVcsQ0FBQ00sTUFBTTtRQUNoQyxNQUFNRyxXQUFXVixTQUFTLENBQUNPLE1BQU07UUFDakMsTUFBTVMsaUJBQWlCSCxLQUFLQyxHQUFHLENBQUN6QixlQUFld0IsS0FBS0MsR0FBRyxDQUFDVDtRQUN4RCxNQUFNTSxXQUFXQyxnQkFBZ0JsRCxPQUFPaUMsaUJBQWlCYyxPQUFPQyxVQUFVQSxXQUFXTSxnQkFBZ0IvQjtRQUNyRyxJQUFJeUIsYUFBYUMsVUFBVTtZQUN6QixJQUFJQSxhQUFhLEtBQUtELFdBQVcsR0FBRztnQkFDbENuQix3QkFBd0J3QixHQUFHLENBQUNOLE1BQU05RSxPQUFPLENBQUNXLEVBQUUsRUFBRW9FO1lBQ2hEO1lBQ0FMLGdCQUFnQkssV0FBV0M7WUFDM0JSLFNBQVMsQ0FBQ0ksTUFBTSxHQUFHSTtZQUNuQixJQUFJTixhQUFhWSxXQUFXLENBQUNsQyxXQUFXbUMsYUFBYSxDQUFDTCxLQUFLQyxHQUFHLENBQUN6QixhQUFhNEIsV0FBVyxDQUFDbEMsWUFBWVAsV0FBVztnQkFDN0cyQyxTQUFTO1lBQ1gsTUFBTSxHQUFHO2dCQUNQO1lBQ0Y7UUFDRjtRQUNBLElBQUk5QixjQUFjLEdBQUc7WUFDbkIsSUFBSSxFQUFFa0IsUUFBUSxHQUFHO2dCQUNmO1lBQ0Y7UUFDRixPQUFPO1lBQ0wsSUFBSSxFQUFFQSxTQUFTTixZQUFZbUIsTUFBTSxFQUFFO2dCQUNqQztZQUNGO1FBQ0Y7SUFDRjtJQUVBLG1GQUFtRjtJQUNuRixrRUFBa0U7SUFDbEUsSUFBSWYsaUJBQWlCLEdBQUc7UUFDdEIsT0FBT0w7SUFDVDtJQUVBLDhHQUE4RztJQUM5R00sVUFBVWpCLGNBQWMsSUFBSUQsVUFBVUQ7SUFDdENvQixRQUFRTixZQUFZTyxTQUFTLENBQUNDLENBQUFBLFFBQVNBLE1BQU05RSxPQUFPLENBQUNXLEVBQUUsS0FBS2dFO0lBQzVESCxTQUFTLENBQUNJLE1BQU0sR0FBR1AsU0FBUyxDQUFDTyxNQUFNLEdBQUdGO0lBQ3RDLE9BQU9GO0FBQ1Q7QUFDQSxTQUFTa0IsbUJBQW1CcEIsV0FBVyxFQUFFSCxLQUFLLEVBQUV3Qiw0QkFBNEI7SUFDMUV4QixNQUFNeUIsT0FBTyxDQUFDLENBQUN6RCxNQUFNeUM7UUFDbkIsTUFBTWlCLFdBQVd2QixXQUFXLENBQUNNLE1BQU07UUFDbkMsSUFBSSxDQUFDaUIsVUFBVTtZQUNiLHVGQUF1RjtZQUN2RixvRUFBb0U7WUFDcEU7UUFDRjtRQUNBLE1BQU0sRUFDSjVELFlBQVksRUFDWjFCLGFBQWEsRUFDYkMsV0FBVyxFQUNYRyxFQUFFLEVBQ0gsR0FBR2tGLFNBQVM3RixPQUFPO1FBQ3BCLE1BQU04RixtQkFBbUJILDRCQUE0QixDQUFDaEYsR0FBRztRQUN6RCxJQUFJbUYscUJBQXFCM0QsTUFBTTtZQUM3QndELDRCQUE0QixDQUFDaEYsR0FBRyxHQUFHd0I7WUFDbkMsTUFBTSxFQUNKcEIsVUFBVSxFQUNWQyxRQUFRLEVBQ1QsR0FBR2lCLGFBQWFqQyxPQUFPO1lBQ3hCLElBQUlnQixVQUFVO2dCQUNaQSxTQUFTbUIsTUFBTTJEO1lBQ2pCO1lBQ0EsSUFBSXRGLGVBQWVPLFlBQVk7Z0JBQzdCLElBQUksQ0FBQytFLG9CQUFvQixRQUFRQSxxQkFBcUJ2RixhQUFZLEtBQU00QixTQUFTNUIsZUFBZTtvQkFDOUZRLFdBQVc7Z0JBQ2IsT0FBTyxJQUFJK0UscUJBQXFCdkYsaUJBQWlCNEIsU0FBUzVCLGVBQWU7b0JBQ3ZFUSxXQUFXO2dCQUNiO1lBQ0Y7UUFDRjtJQUNGO0FBQ0Y7QUFDQSxTQUFTZ0YscUJBQXFCcEYsRUFBRSxFQUFFMkQsV0FBVztJQUMzQyxJQUFJQSxZQUFZbUIsTUFBTSxHQUFHLEdBQUc7UUFDMUIsT0FBTztZQUFDO1lBQU07U0FBSztJQUNyQjtJQUNBLE1BQU1iLFFBQVFOLFlBQVlPLFNBQVMsQ0FBQ0MsQ0FBQUEsUUFBU0EsTUFBTTlFLE9BQU8sQ0FBQ1csRUFBRSxLQUFLQTtJQUNsRSxJQUFJaUUsUUFBUSxHQUFHO1FBQ2IsT0FBTztZQUFDO1lBQU07U0FBSztJQUNyQjtJQUNBLE1BQU1vQixjQUFjcEIsVUFBVU4sWUFBWW1CLE1BQU0sR0FBRztJQUNuRCxNQUFNakMsV0FBV3dDLGNBQWMxQixXQUFXLENBQUNNLFFBQVEsRUFBRSxDQUFDNUUsT0FBTyxDQUFDVyxFQUFFLEdBQUdBO0lBQ25FLE1BQU04QyxVQUFVdUMsY0FBY3JGLEtBQUsyRCxXQUFXLENBQUNNLFFBQVEsRUFBRSxDQUFDNUUsT0FBTyxDQUFDVyxFQUFFO0lBQ3BFLE9BQU87UUFBQzZDO1FBQVVDO0tBQVE7QUFDNUI7QUFDQSxTQUFTUSw0QkFBNEJILE9BQU87SUFDMUMsTUFBTW1DLG9CQUFvQkMsY0FBY3BDO0lBQ3hDLElBQUltQyxxQkFBcUIsTUFBTTtRQUM3QixPQUFPL0I7SUFDVDtJQUNBLE1BQU1pQyxZQUFZRixrQkFBa0JHLFlBQVksQ0FBQztJQUNqRCxNQUFNQyxnQkFBZ0JDLHlCQUF5QnhDO0lBQy9DLElBQUlxQyxjQUFjLGNBQWM7UUFDOUIsT0FBT0Ysa0JBQWtCTSxXQUFXLEdBQUdGLGNBQWNHLE1BQU0sQ0FBQyxDQUFDQyxhQUFhQztZQUN4RSxPQUFPRCxjQUFjQyxPQUFPSCxXQUFXO1FBQ3pDLEdBQUc7SUFDTCxPQUFPO1FBQ0wsT0FBT04sa0JBQWtCVSxZQUFZLEdBQUdOLGNBQWNHLE1BQU0sQ0FBQyxDQUFDQyxhQUFhQztZQUN6RSxPQUFPRCxjQUFjQyxPQUFPQyxZQUFZO1FBQzFDLEdBQUc7SUFDTDtBQUNGO0FBRUEsOERBQThEO0FBQzlELCtEQUErRDtBQUMvRCxTQUFTQyxZQUFZN0MsTUFBTSxFQUFFcEQsRUFBRSxFQUFFd0QsS0FBSztJQUNwQyxJQUFJSixPQUFPNUIsSUFBSSxLQUFLLEdBQUc7UUFDckIsT0FBTztJQUNUO0lBQ0EsTUFBTW1DLGNBQWNDLHVCQUF1QlI7SUFDM0MsTUFBTWEsUUFBUU4sWUFBWU8sU0FBUyxDQUFDQyxDQUFBQSxRQUFTQSxNQUFNOUUsT0FBTyxDQUFDVyxFQUFFLEtBQUtBO0lBQ2xFLE1BQU13QixPQUFPZ0MsS0FBSyxDQUFDUyxNQUFNO0lBQ3pCLElBQUl6QyxRQUFRLE1BQU07UUFDaEIsT0FBTztJQUNUO0lBQ0EsT0FBT0EsS0FBS21ELFdBQVcsQ0FBQ2xDO0FBQzFCO0FBQ0EsU0FBU3lELFNBQVNsRyxFQUFFO0lBQ2xCLE1BQU1tRyxVQUFVQyxTQUFTQyxhQUFhLENBQUMsQ0FBQyxnQkFBZ0IsRUFBRXJHLEdBQUcsRUFBRSxDQUFDO0lBQ2hFLElBQUltRyxTQUFTO1FBQ1gsT0FBT0E7SUFDVDtJQUNBLE9BQU87QUFDVDtBQUNBLFNBQVNaLGNBQWN2RixFQUFFO0lBQ3ZCLE1BQU1tRyxVQUFVQyxTQUFTQyxhQUFhLENBQUMsQ0FBQyxzQkFBc0IsRUFBRXJHLEdBQUcsRUFBRSxDQUFDO0lBQ3RFLElBQUltRyxTQUFTO1FBQ1gsT0FBT0E7SUFDVDtJQUNBLE9BQU87QUFDVDtBQUNBLFNBQVNHLGdCQUFnQnRHLEVBQUU7SUFDekIsTUFBTW1HLFVBQVVDLFNBQVNDLGFBQWEsQ0FBQyxDQUFDLDhCQUE4QixFQUFFckcsR0FBRyxFQUFFLENBQUM7SUFDOUUsSUFBSW1HLFNBQVM7UUFDWCxPQUFPQTtJQUNUO0lBQ0EsT0FBTztBQUNUO0FBQ0EsU0FBU0kscUJBQXFCdkcsRUFBRTtJQUM5QixNQUFNd0csVUFBVUM7SUFDaEIsTUFBTXhDLFFBQVF1QyxRQUFRdEMsU0FBUyxDQUFDNkIsQ0FBQUEsU0FBVUEsT0FBT04sWUFBWSxDQUFDLG1DQUFtQ3pGO0lBQ2pHLE9BQU9pRSxTQUFTO0FBQ2xCO0FBQ0EsU0FBU3dDO0lBQ1AsT0FBT0MsTUFBTUMsSUFBSSxDQUFDUCxTQUFTUSxnQkFBZ0IsQ0FBQyxDQUFDLDZCQUE2QixDQUFDO0FBQzdFO0FBQ0EsU0FBU2pCLHlCQUF5QnhDLE9BQU87SUFDdkMsT0FBT3VELE1BQU1DLElBQUksQ0FBQ1AsU0FBU1EsZ0JBQWdCLENBQUMsQ0FBQyxtREFBbUQsRUFBRXpELFFBQVEsRUFBRSxDQUFDO0FBQy9HO0FBQ0EsU0FBUzBELHdCQUF3QjFELE9BQU8sRUFBRTJELFFBQVEsRUFBRW5ELFdBQVc7SUFDN0QsTUFBTW9DLFNBQVNPLGdCQUFnQlE7SUFDL0IsTUFBTU4sVUFBVWIseUJBQXlCeEM7SUFDekMsTUFBTWMsUUFBUThCLFNBQVNTLFFBQVFPLE9BQU8sQ0FBQ2hCLFVBQVUsQ0FBQztJQUNsRCxNQUFNbEQsV0FBV2MsV0FBVyxDQUFDTSxNQUFNLEVBQUU1RSxTQUFTVyxNQUFNO0lBQ3BELE1BQU04QyxVQUFVYSxXQUFXLENBQUNNLFFBQVEsRUFBRSxFQUFFNUUsU0FBU1csTUFBTTtJQUN2RCxPQUFPO1FBQUM2QztRQUFVQztLQUFRO0FBQzVCO0FBQ0EsU0FBU2MsdUJBQXVCUixNQUFNO0lBQ3BDLE9BQU9zRCxNQUFNQyxJQUFJLENBQUN2RCxPQUFPNEQsTUFBTSxJQUFJQyxJQUFJLENBQUMsQ0FBQ0MsUUFBUUM7UUFDL0MsTUFBTUMsU0FBU0YsT0FBTzdILE9BQU8sQ0FBQ2lCLEtBQUs7UUFDbkMsTUFBTStHLFNBQVNGLE9BQU85SCxPQUFPLENBQUNpQixLQUFLO1FBQ25DLElBQUk4RyxVQUFVLFFBQVFDLFVBQVUsTUFBTTtZQUNwQyxPQUFPO1FBQ1QsT0FBTyxJQUFJRCxVQUFVLE1BQU07WUFDekIsT0FBTyxDQUFDO1FBQ1YsT0FBTyxJQUFJQyxVQUFVLE1BQU07WUFDekIsT0FBTztRQUNULE9BQU87WUFDTCxPQUFPRCxTQUFTQztRQUNsQjtJQUNGO0FBQ0Y7QUFDQSxTQUFTL0MsZ0JBQWdCbEQsS0FBSyxFQUFFaUMsZUFBZSxFQUFFYyxLQUFLLEVBQUVtRCxRQUFRLEVBQUVqRCxRQUFRLEVBQUUxQixRQUFRLElBQUk7SUFDdEYsSUFBSSxFQUNGL0MsYUFBYSxFQUNiQyxXQUFXLEVBQ1hLLE9BQU8sRUFDUEMsT0FBTyxFQUNSLEdBQUdnRSxNQUFNOUUsT0FBTztJQUNqQixJQUFJK0IsVUFBVSxVQUFVO1FBQ3RCeEIsZ0JBQWdCQSxnQkFBZ0J5RCxrQkFBa0I7UUFDbEQsSUFBSW5ELFdBQVcsTUFBTTtZQUNuQkEsVUFBVUEsVUFBVW1ELGtCQUFrQjtRQUN4QztRQUNBbEQsVUFBVUEsVUFBVWtELGtCQUFrQjtJQUN4QztJQUNBLElBQUl4RCxhQUFhO1FBQ2YsSUFBSXlILFdBQVcxSCxlQUFlO1lBQzVCLHFGQUFxRjtZQUNyRixJQUFJeUUsWUFBWWxFLFVBQVUsSUFBSVAsZUFBZTtnQkFDM0MsT0FBT0E7WUFDVDtRQUNGLE9BQU87WUFDTCxNQUFNMkgsa0JBQWtCNUUsT0FBTzZFLE1BQU1DLFdBQVc7WUFDaEQsSUFBSSxDQUFDRixpQkFBaUI7Z0JBQ3BCLG1FQUFtRTtnQkFDbkUsd0VBQXdFO2dCQUN4RSw2RUFBNkU7Z0JBQzdFLElBQUlsRCxXQUFXbEUsU0FBUztvQkFDdEIsT0FBT1A7Z0JBQ1Q7WUFDRjtRQUNGO0lBQ0Y7SUFDQSxPQUFPMkUsS0FBS21ELEdBQUcsQ0FBQ3hILFdBQVcsT0FBT0EsVUFBVSxLQUFLcUUsS0FBS29ELEdBQUcsQ0FBQ3hILFNBQVNrRTtBQUNyRTtBQUNBLFNBQVN1RCxtQkFBbUJ4RyxLQUFLLEVBQUV5RyxTQUFTO0lBQzFDLE1BQU0sRUFDSmhJLFdBQVcsRUFDWEMsV0FBVyxFQUNYSSxPQUFPLEVBQ1BDLE9BQU8sRUFDUixHQUFHMEgsVUFBVXhJLE9BQU87SUFFckIseUJBQXlCO0lBQ3pCLElBQUljLFVBQVUsS0FBS2lCLFVBQVUsaUJBQWlCakIsVUFBVSxLQUFLO1FBQzNEO1lBQ0UySCxRQUFRQyxLQUFLLENBQUMsQ0FBQyxnQ0FBZ0MsRUFBRTVILFFBQVEsQ0FBQztRQUM1RDtRQUNBMEgsVUFBVXhJLE9BQU8sQ0FBQ2MsT0FBTyxHQUFHO0lBQzlCO0lBQ0EsSUFBSUQsV0FBVyxNQUFNO1FBQ25CLElBQUlBLFVBQVUsS0FBS2tCLFVBQVUsaUJBQWlCbEIsVUFBVSxLQUFLO1lBQzNEO2dCQUNFNEgsUUFBUUMsS0FBSyxDQUFDLENBQUMsZ0NBQWdDLEVBQUU3SCxRQUFRLENBQUM7WUFDNUQ7WUFDQTJILFVBQVV4SSxPQUFPLENBQUNhLE9BQU8sR0FBRztRQUM5QjtJQUNGO0lBQ0EsSUFBSUosZ0JBQWdCLE1BQU07UUFDeEIsSUFBSUEsY0FBYyxLQUFLc0IsVUFBVSxpQkFBaUJ0QixjQUFjLEtBQUs7WUFDbkU7Z0JBQ0VnSSxRQUFRQyxLQUFLLENBQUMsQ0FBQyxvQ0FBb0MsRUFBRWpJLFlBQVksQ0FBQztZQUNwRTtZQUNBK0gsVUFBVXhJLE9BQU8sQ0FBQ1MsV0FBVyxHQUFHO1FBQ2xDLE9BQU8sSUFBSUEsY0FBY0ssV0FBVyxDQUFDTixhQUFhO1lBQ2hEO2dCQUNFaUksUUFBUUMsS0FBSyxDQUFDLENBQUMsZUFBZSxFQUFFNUgsUUFBUSxzQ0FBc0MsRUFBRUwsWUFBWSxDQUFDLENBQUM7WUFDaEc7WUFDQStILFVBQVV4SSxPQUFPLENBQUNTLFdBQVcsR0FBR0s7UUFDbEMsT0FBTyxJQUFJRCxXQUFXLFFBQVFKLGNBQWNJLFNBQVM7WUFDbkQ7Z0JBQ0U0SCxRQUFRQyxLQUFLLENBQUMsQ0FBQyxlQUFlLEVBQUU3SCxRQUFRLG1DQUFtQyxFQUFFSixZQUFZLENBQUMsQ0FBQztZQUM3RjtZQUNBK0gsVUFBVXhJLE9BQU8sQ0FBQ1MsV0FBVyxHQUFHSTtRQUNsQztJQUNGO0FBQ0Y7QUFDQSxTQUFTOEgseUJBQXlCLEVBQ2hDN0UsT0FBTyxFQUNQQyxNQUFNLEVBQ05TLFNBQVMsRUFDVGIsU0FBUyxFQUNUNUIsS0FBSyxFQUNOO0lBQ0MscUNBQXFDO0lBQ3JDeUMsWUFBWTtXQUFJQTtLQUFVO0lBQzFCLE1BQU1GLGNBQWNDLHVCQUF1QlI7SUFDM0MsTUFBTUMsa0JBQWtCakMsVUFBVSxXQUFXa0MsNEJBQTRCSCxXQUFXSTtJQUNwRixJQUFJMEUsZ0JBQWdCO0lBRXBCLHlFQUF5RTtJQUN6RSxJQUFLLElBQUloRSxRQUFRLEdBQUdBLFFBQVFOLFlBQVltQixNQUFNLEVBQUViLFFBQVM7UUFDdkQsTUFBTUUsUUFBUVIsV0FBVyxDQUFDTSxNQUFNO1FBQ2hDLE1BQU1xRCxXQUFXdEUsU0FBUyxDQUFDaUIsTUFBTTtRQUNqQyxNQUFNSSxXQUFXUixTQUFTLENBQUNJLE1BQU07UUFDakMsTUFBTWlFLGVBQWU1RCxnQkFBZ0JsRCxPQUFPaUMsaUJBQWlCYyxPQUFPbUQsVUFBVWpEO1FBQzlFLElBQUlBLFlBQVk2RCxjQUFjO1lBQzVCRCxpQkFBaUI1RCxXQUFXNkQ7WUFDNUJyRSxTQUFTLENBQUNJLE1BQU0sR0FBR2lFO1lBQ25CO2dCQUNFSixRQUFRQyxLQUFLLENBQUMsQ0FBQyxjQUFjLEVBQUUxRCxTQUFTLHVCQUF1QixFQUFFRixNQUFNOUUsT0FBTyxDQUFDVyxFQUFFLENBQUMsNENBQTRDLENBQUM7WUFDakk7UUFDRjtJQUNGO0lBRUEscUZBQXFGO0lBQ3JGLDBFQUEwRTtJQUMxRSxJQUFJaUksY0FBYzVGLE9BQU8sQ0FBQyxPQUFPLFNBQVM7UUFDeEMsSUFBSyxJQUFJNEIsUUFBUSxHQUFHQSxRQUFRTixZQUFZbUIsTUFBTSxFQUFFYixRQUFTO1lBQ3ZELE1BQU1FLFFBQVFSLFdBQVcsQ0FBQ00sTUFBTTtZQUNoQyxJQUFJLEVBQ0YvRCxPQUFPLEVBQ1BDLE9BQU8sRUFDUixHQUFHZ0UsTUFBTTlFLE9BQU87WUFDakIsSUFBSStCLFVBQVUsVUFBVTtnQkFDdEJqQixVQUFVQSxVQUFVa0Qsa0JBQWtCO2dCQUN0QyxJQUFJbkQsV0FBVyxNQUFNO29CQUNuQkEsVUFBVUEsVUFBVW1ELGtCQUFrQjtnQkFDeEM7WUFDRjtZQUNBLE1BQU03QixPQUFPK0MsS0FBS21ELEdBQUcsQ0FBQ3hILFdBQVcsT0FBT0EsVUFBVSxLQUFLcUUsS0FBS29ELEdBQUcsQ0FBQ3hILFNBQVMwRCxTQUFTLENBQUNJLE1BQU0sR0FBR2dFO1lBQzVGLElBQUl6RyxTQUFTcUMsU0FBUyxDQUFDSSxNQUFNLEVBQUU7Z0JBQzdCZ0UsaUJBQWlCekcsT0FBT3FDLFNBQVMsQ0FBQ0ksTUFBTTtnQkFDeENKLFNBQVMsQ0FBQ0ksTUFBTSxHQUFHekM7Z0JBRW5CLGdFQUFnRTtnQkFDaEUsSUFBSStDLEtBQUtDLEdBQUcsQ0FBQ3lELGVBQWU1RixPQUFPLENBQUMsT0FBTyxTQUFTO29CQUNsRDtnQkFDRjtZQUNGO1FBQ0Y7SUFDRjtJQUVBLDRGQUE0RjtJQUM1RixJQUFJNEYsY0FBYzVGLE9BQU8sQ0FBQyxPQUFPLFNBQVM7UUFDeEM7WUFDRXlGLFFBQVFDLEtBQUssQ0FBQyxDQUFDLGtGQUFrRixFQUFFLE1BQU1FLGNBQWMsQ0FBQyxDQUFDO1FBQzNIO0lBQ0Y7SUFDQSxPQUFPcEU7QUFDVDtBQUVBLFNBQVNzRSxPQUFPQyxpQkFBaUIsRUFBRUMsVUFBVSxtQkFBbUI7SUFDOUQsSUFBSSxDQUFDRCxtQkFBbUI7UUFDdEJOLFFBQVFDLEtBQUssQ0FBQ007UUFDZCxNQUFNekgsTUFBTXlIO0lBQ2Q7QUFDRjtBQUVBLDJEQUEyRDtBQUUzRCxTQUFTQyxvQ0FBb0MsRUFDM0MvRyxrQkFBa0IsRUFDbEI0QixPQUFPLEVBQ1BDLE1BQU0sRUFDTm1GLFFBQVEsRUFDUi9FLEtBQUssRUFDTFAsdUJBQXVCLEVBQ3hCO0lBQ0MxRSxVQUFVO1FBQ1IsTUFBTSxFQUNKaUgsU0FBUyxFQUNUcEMsTUFBTSxFQUNQLEdBQUc3QixtQkFBbUJsQyxPQUFPO1FBQzlCLE1BQU1tSixlQUFlakQsY0FBY3BDO1FBQ25DZ0YsT0FBT0ssZ0JBQWdCLE1BQU0sQ0FBQyx1QkFBdUIsRUFBRXJGLFFBQVEsQ0FBQyxDQUFDO1FBQ2pFLE1BQU0sRUFDSnNGLE1BQU0sRUFDTkMsS0FBSyxFQUNOLEdBQUdGLGFBQWFHLHFCQUFxQjtRQUN0QyxNQUFNbkMsVUFBVWIseUJBQXlCeEM7UUFDekMsTUFBTXlGLG1CQUFtQnBDLFFBQVFxQyxHQUFHLENBQUM5QyxDQUFBQTtZQUNuQyxNQUFNZSxXQUFXZixPQUFPTixZQUFZLENBQUM7WUFDckMsTUFBTTlCLGNBQWNDLHVCQUF1QlI7WUFDM0MsTUFBTSxDQUFDUCxVQUFVQyxRQUFRLEdBQUcrRCx3QkFBd0IxRCxTQUFTMkQsVUFBVW5EO1lBQ3ZFLElBQUlkLFlBQVksUUFBUUMsV0FBVyxNQUFNO2dCQUN2QyxPQUFPLEtBQU87WUFDaEI7WUFDQSxJQUFJZ0csaUJBQWlCO1lBQ3JCLElBQUlDLGlCQUFpQjtZQUNyQixJQUFJQyxlQUFlO1lBQ25CLElBQUlDLGVBQWU7WUFFbkIsa0ZBQWtGO1lBQ2xGdEYsWUFBWXNCLE9BQU8sQ0FBQzRDLENBQUFBO2dCQUNsQixNQUFNLEVBQ0o3SCxFQUFFLEVBQ0ZFLE9BQU8sRUFDUEMsT0FBTyxFQUNSLEdBQUcwSCxVQUFVeEksT0FBTztnQkFDckIsSUFBSVcsT0FBTzZDLFVBQVU7b0JBQ25CaUcsaUJBQWlCM0k7b0JBQ2pCNEksaUJBQWlCN0ksV0FBVyxPQUFPQSxVQUFVO2dCQUMvQyxPQUFPO29CQUNMOEksZ0JBQWdCN0k7b0JBQ2hCOEksZ0JBQWdCL0ksV0FBVyxPQUFPQSxVQUFVO2dCQUM5QztZQUNGO1lBQ0EsTUFBTWdKLGVBQWUzRSxLQUFLbUQsR0FBRyxDQUFDcUIsZ0JBQWdCLE1BQU1DO1lBQ3BELE1BQU1HLGVBQWU1RSxLQUFLb0QsR0FBRyxDQUFDbUIsZ0JBQWdCLENBQUNuRixZQUFZbUIsTUFBTSxHQUFHLEtBQUssTUFBTW1FO1lBQy9FLE1BQU03RyxXQUFXNkQsWUFBWTdDLFFBQVFQLFVBQVVXO1lBQy9DdUMsT0FBT3FELFlBQVksQ0FBQyxpQkFBaUIsS0FBSzdFLEtBQUs4RSxLQUFLLENBQUNIO1lBQ3JEbkQsT0FBT3FELFlBQVksQ0FBQyxpQkFBaUIsS0FBSzdFLEtBQUs4RSxLQUFLLENBQUNGO1lBQ3JEcEQsT0FBT3FELFlBQVksQ0FBQyxpQkFBaUIsS0FBSzdFLEtBQUs4RSxLQUFLLENBQUNDLFNBQVNsSDtZQUM5RCxNQUFNbUgsWUFBWTVHLENBQUFBO2dCQUNoQixJQUFJQSxNQUFNNkcsZ0JBQWdCLEVBQUU7b0JBQzFCO2dCQUNGO2dCQUNBLE9BQVE3RyxNQUFNOEcsR0FBRztvQkFDZixLQUFLO3dCQUNIOzRCQUNFOUcsTUFBTStHLGNBQWM7NEJBQ3BCLE1BQU16RixRQUFRTixZQUFZTyxTQUFTLENBQUNDLENBQUFBLFFBQVNBLE1BQU05RSxPQUFPLENBQUNXLEVBQUUsS0FBSzZDOzRCQUNsRSxJQUFJb0IsU0FBUyxHQUFHO2dDQUNkLE1BQU00RCxZQUFZbEUsV0FBVyxDQUFDTSxNQUFNO2dDQUNwQyxNQUFNekMsT0FBT2dDLEtBQUssQ0FBQ1MsTUFBTTtnQ0FDekIsSUFBSXpDLFFBQVEsTUFBTTtvQ0FDaEIsSUFBSW1JLFFBQVE7b0NBQ1osSUFBSW5JLEtBQUttRCxXQUFXLENBQUNsQyxjQUFjb0YsVUFBVXhJLE9BQU8sQ0FBQ2MsT0FBTyxDQUFDd0UsV0FBVyxDQUFDbEMsWUFBWTt3Q0FDbkZrSCxRQUFRbkUsY0FBYyxlQUFla0QsUUFBUUQ7b0NBQy9DLE9BQU87d0NBQ0xrQixRQUFRLENBQUVuRSxDQUFBQSxjQUFjLGVBQWVrRCxRQUFRRCxNQUFLO29DQUN0RDtvQ0FDQSxNQUFNNUUsWUFBWW5CLGNBQWNDLE9BQU9wQixtQkFBbUJsQyxPQUFPLEVBQUV3RCxVQUFVQyxTQUFTNkcsT0FBT25HLE9BQU9QLHdCQUF3QjVELE9BQU8sRUFBRTtvQ0FDckksSUFBSW1FLFVBQVVLLFdBQVc7d0NBQ3ZCMEUsU0FBUzFFO29DQUNYO2dDQUNGOzRCQUNGOzRCQUNBO3dCQUNGO2dCQUNKO1lBQ0Y7WUFDQWtDLE9BQU82RCxnQkFBZ0IsQ0FBQyxXQUFXTDtZQUNuQyxNQUFNTSxjQUFjM0QsU0FBU3JEO1lBQzdCLElBQUlnSCxlQUFlLE1BQU07Z0JBQ3ZCOUQsT0FBT3FELFlBQVksQ0FBQyxpQkFBaUJTLFlBQVk3SixFQUFFO1lBQ3JEO1lBQ0EsT0FBTztnQkFDTCtGLE9BQU8rRCxlQUFlLENBQUM7Z0JBQ3ZCL0QsT0FBTytELGVBQWUsQ0FBQztnQkFDdkIvRCxPQUFPK0QsZUFBZSxDQUFDO2dCQUN2Qi9ELE9BQU9nRSxtQkFBbUIsQ0FBQyxXQUFXUjtnQkFDdEMsSUFBSU0sZUFBZSxNQUFNO29CQUN2QjlELE9BQU8rRCxlQUFlLENBQUM7Z0JBQ3pCO1lBQ0Y7UUFDRjtRQUNBLE9BQU87WUFDTGxCLGlCQUFpQjNELE9BQU8sQ0FBQytFLENBQUFBLGtCQUFtQkE7UUFDOUM7SUFDRixHQUFHO1FBQUN6STtRQUFvQjRCO1FBQVNDO1FBQVFIO1FBQXlCc0Y7UUFBVS9FO0tBQU07QUFDcEY7QUFDQSxTQUFTeUcsdUNBQXVDLEVBQzlDQyxRQUFRLEVBQ1JwRCxRQUFRLEVBQ1JxRCxhQUFhLEVBQ2Q7SUFDQzVMLFVBQVU7UUFDUixJQUFJMkwsWUFBWUMsaUJBQWlCLE1BQU07WUFDckM7UUFDRjtRQUNBLE1BQU1DLGdCQUFnQjlELGdCQUFnQlE7UUFDdEMsSUFBSXNELGlCQUFpQixNQUFNO1lBQ3pCO1FBQ0Y7UUFDQSxNQUFNYixZQUFZNUcsQ0FBQUE7WUFDaEIsSUFBSUEsTUFBTTZHLGdCQUFnQixFQUFFO2dCQUMxQjtZQUNGO1lBQ0EsT0FBUTdHLE1BQU04RyxHQUFHO2dCQUNmLEtBQUs7Z0JBQ0wsS0FBSztnQkFDTCxLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztnQkFDTCxLQUFLO29CQUNIO3dCQUNFOUcsTUFBTStHLGNBQWM7d0JBQ3BCUyxjQUFjeEg7d0JBQ2Q7b0JBQ0Y7Z0JBQ0YsS0FBSztvQkFDSDt3QkFDRUEsTUFBTStHLGNBQWM7d0JBQ3BCLE1BQU1sRCxVQUFVQzt3QkFDaEIsTUFBTXhDLFFBQVFzQyxxQkFBcUJPO3dCQUNuQ3FCLE9BQU9sRSxVQUFVO3dCQUNqQixNQUFNb0csWUFBWTFILE1BQU0ySCxRQUFRLEdBQUdyRyxRQUFRLElBQUlBLFFBQVEsSUFBSXVDLFFBQVExQixNQUFNLEdBQUcsSUFBSWIsUUFBUSxJQUFJdUMsUUFBUTFCLE1BQU0sR0FBR2IsUUFBUSxJQUFJO3dCQUN6SCxNQUFNc0csYUFBYS9ELE9BQU8sQ0FBQzZELFVBQVU7d0JBQ3JDRSxXQUFXQyxLQUFLO3dCQUNoQjtvQkFDRjtZQUNKO1FBQ0Y7UUFDQUosY0FBY1IsZ0JBQWdCLENBQUMsV0FBV0w7UUFDMUMsT0FBTztZQUNMYSxjQUFjTCxtQkFBbUIsQ0FBQyxXQUFXUjtRQUMvQztJQUNGLEdBQUc7UUFBQ1c7UUFBVXBEO1FBQVVxRDtLQUFjO0FBQ3hDO0FBRUEsU0FBU00sU0FBU0MsTUFBTSxFQUFFQyxNQUFNO0lBQzlCLElBQUlELE9BQU81RixNQUFNLEtBQUs2RixPQUFPN0YsTUFBTSxFQUFFO1FBQ25DLE9BQU87SUFDVDtJQUNBLElBQUssSUFBSWIsUUFBUSxHQUFHQSxRQUFReUcsT0FBTzVGLE1BQU0sRUFBRWIsUUFBUztRQUNsRCxJQUFJeUcsTUFBTSxDQUFDekcsTUFBTSxLQUFLMEcsTUFBTSxDQUFDMUcsTUFBTSxFQUFFO1lBQ25DLE9BQU87UUFDVDtJQUNGO0lBQ0EsT0FBTztBQUNUO0FBRUEsU0FBUzJHLGNBQWNqSSxLQUFLLEVBQUVtRSxRQUFRLEVBQUV0QixTQUFTLEVBQUVxRixnQkFBZ0IsQ0FBQyxFQUFFQywyQkFBMkIsSUFBSTtJQUNuRyxNQUFNQyxlQUFldkYsY0FBYztJQUNuQyxJQUFJd0YsZ0JBQWdCO0lBQ3BCLElBQUlDLGFBQWF0SSxRQUFRO1FBQ3ZCcUksZ0JBQWdCRCxlQUFlcEksTUFBTXVJLE9BQU8sR0FBR3ZJLE1BQU13SSxPQUFPO0lBQzlELE9BQU8sSUFBSUMsYUFBYXpJLFFBQVE7UUFDOUIsTUFBTTBJLGFBQWExSSxNQUFNMkksT0FBTyxDQUFDLEVBQUU7UUFDbkNOLGdCQUFnQkQsZUFBZU0sV0FBV0UsT0FBTyxHQUFHRixXQUFXRyxPQUFPO0lBQ3hFLE9BQU87UUFDTCxPQUFPO0lBQ1Q7SUFDQSxNQUFNcEIsZ0JBQWdCOUQsZ0JBQWdCUTtJQUN0QyxNQUFNMkUsT0FBT1gsNEJBQTRCVixjQUFjekIscUJBQXFCO0lBQzVFLE1BQU0rQyxnQkFBZ0JYLGVBQWVVLEtBQUtFLElBQUksR0FBR0YsS0FBS0csR0FBRztJQUN6RCxPQUFPWixnQkFBZ0JVLGdCQUFnQmI7QUFDekM7QUFFQSx3RUFBd0U7QUFDeEUsU0FBU2dCLFlBQVlsSixLQUFLLEVBQUVRLE9BQU8sRUFBRTJELFFBQVEsRUFBRW5ELFdBQVcsRUFBRTZCLFNBQVMsRUFBRXhDLFNBQVMsRUFBRUUsZ0JBQWdCO0lBQ2hHLE1BQU0sRUFDSjRJLGFBQWEsQ0FBQyxFQUNkQyxjQUFjLEVBQ2R2SSxPQUFPQyxZQUFZLEVBQ3BCLEdBQUdQLG9CQUFvQixDQUFDO0lBRXpCLHdFQUF3RTtJQUN4RSxrR0FBa0c7SUFDbEcsTUFBTVEsWUFBWUQsZ0JBQWdCVDtJQUNsQyxJQUFJZ0osVUFBVXJKLFFBQVE7UUFDcEIsTUFBTW9JLGVBQWV2RixjQUFjO1FBQ25DLE1BQU1nRCxlQUFlakQsY0FBY3BDO1FBQ25DLE1BQU1zSSxPQUFPakQsYUFBYUcscUJBQXFCO1FBQy9DLE1BQU1zRCxvQkFBb0JsQixlQUFlVSxLQUFLL0MsS0FBSyxHQUFHK0MsS0FBS2hELE1BQU07UUFDakUsTUFBTXlELGNBQWN2SixNQUFNMkgsUUFBUSxHQUFHLEtBQUs7UUFDMUMsTUFBTVgsUUFBUXNDLG9CQUFvQkM7UUFDbEMsSUFBSUMsV0FBVztRQUNmLE9BQVF4SixNQUFNOEcsR0FBRztZQUNmLEtBQUs7Z0JBQ0gwQyxXQUFXcEIsZUFBZSxJQUFJcEI7Z0JBQzlCO1lBQ0YsS0FBSztnQkFDSHdDLFdBQVdwQixlQUFlLENBQUNwQixRQUFRO2dCQUNuQztZQUNGLEtBQUs7Z0JBQ0h3QyxXQUFXcEIsZUFBZXBCLFFBQVE7Z0JBQ2xDO1lBQ0YsS0FBSztnQkFDSHdDLFdBQVdwQixlQUFlLElBQUksQ0FBQ3BCO2dCQUMvQjtZQUNGLEtBQUs7Z0JBQ0h3QyxXQUFXRjtnQkFDWDtZQUNGLEtBQUs7Z0JBQ0hFLFdBQVcsQ0FBQ0Y7Z0JBQ1o7UUFDSjtRQUVBLDZDQUE2QztRQUM3QyxnRUFBZ0U7UUFDaEUsMEZBQTBGO1FBQzFGLHVFQUF1RTtRQUN2RSxNQUFNLENBQUNwSixVQUFVQyxRQUFRLEdBQUcrRCx3QkFBd0IxRCxTQUFTMkQsVUFBVW5EO1FBQ3ZFLE1BQU15SSxnQkFBZ0JELFdBQVcsSUFBSXRKLFdBQVdDO1FBQ2hELE1BQU11SixtQkFBbUIxSSxZQUFZTyxTQUFTLENBQUNDLENBQUFBLFFBQVNBLE1BQU05RSxPQUFPLENBQUNXLEVBQUUsS0FBS29NO1FBQzdFLE1BQU1FLGNBQWMzSSxXQUFXLENBQUMwSSxpQkFBaUI7UUFDakQsSUFBSUMsWUFBWWpOLE9BQU8sQ0FBQ1EsV0FBVyxFQUFFO1lBQ25DLE1BQU11RSxXQUFXVixTQUFTLENBQUMySSxpQkFBaUI7WUFDNUMsSUFBSWpJLGFBQWEsS0FBS0EsU0FBU08sV0FBVyxDQUFDbEMsZUFBZTZKLFlBQVlqTixPQUFPLENBQUNjLE9BQU8sQ0FBQ3dFLFdBQVcsQ0FBQ2xDLFlBQVk7Z0JBQzVHMEosV0FBV0EsV0FBVyxJQUFJLENBQUNHLFlBQVlqTixPQUFPLENBQUNjLE9BQU8sR0FBRzhMLG9CQUFvQkssWUFBWWpOLE9BQU8sQ0FBQ2MsT0FBTyxHQUFHOEw7WUFDN0c7UUFDRjtRQUNBLE9BQU9FO0lBQ1QsT0FBTztRQUNMLE9BQU92QixjQUFjakksT0FBT21FLFVBQVV0QixXQUFXc0csWUFBWUM7SUFDL0Q7QUFDRjtBQUNBLFNBQVNDLFVBQVVySixLQUFLO0lBQ3RCLE9BQU9BLE1BQU02RSxJQUFJLEtBQUs7QUFDeEI7QUFDQSxTQUFTeUQsYUFBYXRJLEtBQUs7SUFDekIsT0FBT0EsTUFBTTZFLElBQUksQ0FBQ0MsVUFBVSxDQUFDO0FBQy9CO0FBQ0EsU0FBUzJELGFBQWF6SSxLQUFLO0lBQ3pCLE9BQU9BLE1BQU02RSxJQUFJLENBQUNDLFVBQVUsQ0FBQztBQUMvQjtBQUVBLElBQUk4RSxlQUFlO0FBQ25CLElBQUlwRyxVQUFVO0FBQ2QsU0FBU3FHLGVBQWVDLEtBQUs7SUFDM0IsT0FBUUE7UUFDTixLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87SUFDWDtBQUNGO0FBQ0EsU0FBU0M7SUFDUCxJQUFJdkcsWUFBWSxNQUFNO1FBQ3BCQyxTQUFTdUcsSUFBSSxDQUFDQyxXQUFXLENBQUN6RztRQUMxQm9HLGVBQWU7UUFDZnBHLFVBQVU7SUFDWjtBQUNGO0FBQ0EsU0FBUzBHLHFCQUFxQkosS0FBSztJQUNqQyxJQUFJRixpQkFBaUJFLE9BQU87UUFDMUI7SUFDRjtJQUNBRixlQUFlRTtJQUNmLE1BQU1sTSxRQUFRaU0sZUFBZUM7SUFDN0IsSUFBSXRHLFlBQVksTUFBTTtRQUNwQkEsVUFBVUMsU0FBU2xJLGFBQWEsQ0FBQztRQUNqQ2tJLFNBQVN1RyxJQUFJLENBQUNHLFdBQVcsQ0FBQzNHO0lBQzVCO0lBQ0FBLFFBQVE0RyxTQUFTLEdBQUcsQ0FBQyxVQUFVLEVBQUV4TSxNQUFNLFlBQVksQ0FBQztBQUN0RDtBQUVBLFNBQVN5TSxTQUFTQyxRQUFRLEVBQUVDLGFBQWEsRUFBRTtJQUN6QyxJQUFJQyxZQUFZO0lBQ2hCLElBQUlDLFdBQVcsQ0FBQyxHQUFHQztRQUNqQixJQUFJRixjQUFjLE1BQU07WUFDdEJHLGFBQWFIO1FBQ2Y7UUFDQUEsWUFBWUksV0FBVztZQUNyQk4sWUFBWUk7UUFDZCxHQUFHSDtJQUNMO0lBQ0EsT0FBT0U7QUFDVDtBQUVBLDZGQUE2RjtBQUM3RiwrREFBK0Q7QUFDL0QsbUVBQW1FO0FBQ25FLDJGQUEyRjtBQUMzRixTQUFTSSxvQkFBb0JwSyxNQUFNO0lBQ2pDLE9BQU9BLE9BQU95RixHQUFHLENBQUMxRSxDQUFBQTtRQUNoQixNQUFNLEVBQ0poRSxPQUFPLEVBQ1BHLEtBQUssRUFDTixHQUFHNkQsTUFBTTlFLE9BQU87UUFDakIsT0FBT2lCLFFBQVEsQ0FBQyxFQUFFQSxNQUFNLENBQUMsRUFBRUgsUUFBUSxDQUFDLEdBQUcsQ0FBQyxFQUFFQSxRQUFRLENBQUM7SUFDckQsR0FBRzhHLElBQUksQ0FBQyxDQUFDd0csR0FBR0MsSUFBTUQsRUFBRTdJLGFBQWEsQ0FBQzhJLElBQUlDLElBQUksQ0FBQztBQUM3QztBQUNBLFNBQVNDLDhCQUE4QkMsVUFBVSxFQUFFQyxPQUFPO0lBQ3hELElBQUk7UUFDRixNQUFNQyxhQUFhRCxRQUFRRSxPQUFPLENBQUMsQ0FBQyxpQkFBaUIsRUFBRUgsV0FBVyxDQUFDO1FBQ25FLElBQUlFLFlBQVk7WUFDZCxNQUFNRSxTQUFTQyxLQUFLQyxLQUFLLENBQUNKO1lBQzFCLElBQUksT0FBT0UsV0FBVyxZQUFZQSxVQUFVLE1BQU07Z0JBQ2hELE9BQU9BO1lBQ1Q7UUFDRjtJQUNGLEVBQUUsT0FBT2xHLE9BQU8sQ0FBQztJQUNqQixPQUFPO0FBQ1Q7QUFDQSxTQUFTcUcscUJBQXFCUCxVQUFVLEVBQUV6SyxNQUFNLEVBQUVJLEtBQUssRUFBRXNLLE9BQU87SUFDOUQsTUFBTXJFLE1BQU0rRCxvQkFBb0JwSztJQUNoQyxNQUFNcUosUUFBUW1CLDhCQUE4QkMsWUFBWUMsWUFBWSxDQUFDO0lBQ3JFckIsS0FBSyxDQUFDaEQsSUFBSSxHQUFHakc7SUFDYixJQUFJO1FBQ0ZzSyxRQUFRTyxPQUFPLENBQUMsQ0FBQyxpQkFBaUIsRUFBRVIsV0FBVyxDQUFDLEVBQUVLLEtBQUtJLFNBQVMsQ0FBQzdCO0lBQ25FLEVBQUUsT0FBTzFFLE9BQU87UUFDZEQsUUFBUUMsS0FBSyxDQUFDQTtJQUNoQjtBQUNGO0FBRUEsTUFBTXdHLGNBQWMsQ0FBQztBQUVyQixpR0FBaUc7QUFDakcsaURBQWlEO0FBQ2pELDRFQUE0RTtBQUM1RSwyQ0FBMkM7QUFDM0MsU0FBU0MseUJBQXlCQyxhQUFhO0lBQzdDLElBQUk7UUFDRixJQUFJLE9BQU9DLGlCQUFpQixhQUFhO1lBQ3ZDLHFDQUFxQztZQUNyQ0QsY0FBY1QsT0FBTyxHQUFHVyxDQUFBQTtnQkFDdEIsT0FBT0QsYUFBYVYsT0FBTyxDQUFDVztZQUM5QjtZQUNBRixjQUFjSixPQUFPLEdBQUcsQ0FBQ00sTUFBTUM7Z0JBQzdCRixhQUFhTCxPQUFPLENBQUNNLE1BQU1DO1lBQzdCO1FBQ0YsT0FBTztZQUNMLE1BQU0sSUFBSWhPLE1BQU07UUFDbEI7SUFDRixFQUFFLE9BQU9tSCxPQUFPO1FBQ2RELFFBQVFDLEtBQUssQ0FBQ0E7UUFDZDBHLGNBQWNULE9BQU8sR0FBRyxJQUFNO1FBQzlCUyxjQUFjSixPQUFPLEdBQUcsS0FBTztJQUNqQztBQUNGO0FBQ0EsTUFBTVEsaUJBQWlCO0lBQ3JCYixTQUFTVyxDQUFBQTtRQUNQSCx5QkFBeUJLO1FBQ3pCLE9BQU9BLGVBQWViLE9BQU8sQ0FBQ1c7SUFDaEM7SUFDQU4sU0FBUyxDQUFDTSxNQUFNQztRQUNkSix5QkFBeUJLO1FBQ3pCQSxlQUFlUixPQUFPLENBQUNNLE1BQU1DO0lBQy9CO0FBQ0Y7QUFFQSw0Q0FBNEM7QUFDNUMsZ0JBQWdCO0FBQ2hCLGlIQUFpSDtBQUNqSCxtSEFBbUg7QUFDbkgsMkJBQTJCO0FBQzNCLDhFQUE4RTtBQUM5RSxxRkFBcUY7QUFDckYsU0FBU0UsMkJBQTJCLEVBQ2xDakIsVUFBVSxFQUNWcE8sV0FBVyxJQUFJLEVBQ2ZDLFdBQVdDLHFCQUFxQixFQUFFLEVBQ2xDNkYsU0FBUyxFQUNUdUosbUNBQW1DLEtBQUssRUFDeENoUCxZQUFZLEVBQ1pDLElBQUlDLGNBQWMsSUFBSSxFQUN0QitPLFFBQVEsRUFDUmxCLFVBQVVlLGNBQWMsRUFDeEJ0TyxPQUFPQyxpQkFBaUIsQ0FBQyxDQUFDLEVBQzFCQyxTQUFTQyxPQUFPLEtBQUssRUFDckJVLFFBQVEsYUFBYSxFQUN0QjtJQUNDLE1BQU0rQixVQUFVbEUsWUFBWWdCO0lBQzVCLE1BQU0sQ0FBQ2dQLGdCQUFnQkMsa0JBQWtCLEdBQUd0USxTQUFTO0lBQ3JELE1BQU0sQ0FBQ3dFLFFBQVErTCxVQUFVLEdBQUd2USxTQUFTLElBQUl3UTtJQUV6QywrQ0FBK0M7SUFDL0MsK0dBQStHO0lBQy9HLGtHQUFrRztJQUNsRyxNQUFNQyxzQkFBc0IxUSxPQUFPO0lBQ25DLE1BQU0yUSxpQkFBaUIzUSxPQUFPO1FBQzVCNFEsMEJBQTBCO1FBQzFCQyx5QkFBeUI7UUFDekJDLDRCQUE0QjtRQUM1QkMsY0FBYyxFQUFFO0lBQ2xCO0lBRUEsd0RBQXdEO0lBQ3hELE1BQU1wTyxlQUFlM0MsT0FBTztRQUMxQnFRO0lBQ0Y7SUFDQXpRLFVBQVU7UUFDUitDLGFBQWFqQyxPQUFPLENBQUMyUCxRQUFRLEdBQUdBO0lBQ2xDO0lBQ0EsTUFBTVcsa0NBQWtDaFIsT0FBTyxDQUFDO0lBRWhELDJEQUEyRDtJQUMzRCxNQUFNLENBQUM2RSxPQUFPK0UsU0FBUyxHQUFHM0osU0FBUyxFQUFFO0lBRXJDLGtEQUFrRDtJQUNsRCxNQUFNcUUsMEJBQTBCdEUsT0FBTyxJQUFJeVE7SUFDM0MsTUFBTVEsZUFBZWpSLE9BQU87SUFFNUIsMEZBQTBGO0lBQzFGLE1BQU00QyxxQkFBcUI1QyxPQUFPO1FBQ2hDNkc7UUFDQXhGLElBQUltRDtRQUNKQztRQUNBSTtRQUNBcEM7SUFDRjtJQUNBNUMsb0JBQW9CdUIsY0FBYyxJQUFPO1lBQ3ZDK0IsT0FBTyxJQUFNcUI7WUFDYjBNLFdBQVdDLENBQUFBO2dCQUNULE1BQU0sRUFDSnRNLEtBQUssRUFDTHBDLE9BQU8yTyxjQUFjLEVBQ3RCLEdBQUd4TyxtQkFBbUJsQyxPQUFPO2dCQUM5QixNQUFNK0IsUUFBUTBPLG1CQUFtQkM7Z0JBQ2pDLElBQUkzTyxVQUFVLFVBQVU7b0JBQ3RCLE1BQU1pQyxrQkFBa0JDLDRCQUE0Qkg7b0JBQ3BELE9BQU9LLE1BQU1xRixHQUFHLENBQUNySCxDQUFBQSxPQUFRQSxPQUFPLE1BQU02QjtnQkFDeEMsT0FBTztvQkFDTCxPQUFPRztnQkFDVDtZQUNGO1lBQ0F3TSxXQUFXLENBQUN4TSxPQUFPc007Z0JBQ2pCLE1BQU0sRUFDSjlQLElBQUltRCxPQUFPLEVBQ1hDLE1BQU0sRUFDTkksT0FBT1IsU0FBUyxFQUNoQjVCLEtBQUssRUFDTixHQUFHRyxtQkFBbUJsQyxPQUFPO2dCQUM5QixJQUFJLENBQUN5USxtQkFBbUIxTyxLQUFJLE1BQU8sVUFBVTtvQkFDM0MsTUFBTWlDLGtCQUFrQkMsNEJBQTRCSDtvQkFDcERLLFFBQVFBLE1BQU1xRixHQUFHLENBQUNySCxDQUFBQSxPQUFRQSxPQUFPNkIsa0JBQWtCO2dCQUNyRDtnQkFDQSxNQUFNMkIsK0JBQStCMkssZ0NBQWdDdFEsT0FBTztnQkFDNUUsTUFBTXNFLGNBQWNDLHVCQUF1QlI7Z0JBQzNDLE1BQU1TLFlBQVltRSx5QkFBeUI7b0JBQ3pDN0U7b0JBQ0FDO29CQUNBUyxXQUFXTDtvQkFDWFI7b0JBQ0E1QjtnQkFDRjtnQkFDQSxJQUFJLENBQUNxSixTQUFTekgsV0FBV2EsWUFBWTtvQkFDbkMwRSxTQUFTMUU7b0JBQ1RrQixtQkFBbUJwQixhQUFhRSxXQUFXbUI7Z0JBQzdDO1lBQ0Y7UUFDRixJQUFJO1FBQUM3QjtLQUFRO0lBQ2JtRixvQ0FBb0M7UUFDbEMvRztRQUNBNEI7UUFDQUM7UUFDQW1GO1FBQ0EvRTtRQUNBUDtJQUNGO0lBRUEsZ0RBQWdEO0lBQ2hEMUUsVUFBVTtRQUNSLE1BQU0sRUFDSnlRLFFBQVEsRUFDVCxHQUFHMU4sYUFBYWpDLE9BQU87UUFDeEIsTUFBTSxFQUNKK0QsTUFBTSxFQUNOSSxLQUFLLEVBQ04sR0FBR2pDLG1CQUFtQmxDLE9BQU87UUFFOUIsZ0dBQWdHO1FBQ2hHLElBQUltRSxNQUFNc0IsTUFBTSxHQUFHLEdBQUc7WUFDcEIsSUFBSWtLLFVBQVU7Z0JBQ1pBLFNBQVN4TDtZQUNYO1lBQ0EsTUFBTXdCLCtCQUErQjJLLGdDQUFnQ3RRLE9BQU87WUFFNUUsa0dBQWtHO1lBQ2xHLDZDQUE2QztZQUM3QyxpR0FBaUc7WUFDakcsd0RBQXdEO1lBQ3hELG9HQUFvRztZQUNwRyxNQUFNc0UsY0FBY0MsdUJBQXVCUjtZQUMzQzJCLG1CQUFtQnBCLGFBQWFILE9BQU93QjtRQUN6QztJQUNGLEdBQUc7UUFBQ3hCO0tBQU07SUFDVmpGLFVBQVU7UUFDUixnR0FBZ0c7UUFDaEcsSUFBSXNQLFlBQVk7WUFDZCxJQUFJckssTUFBTXNCLE1BQU0sS0FBSyxLQUFLdEIsTUFBTXNCLE1BQU0sS0FBSzFCLE9BQU81QixJQUFJLEVBQUU7Z0JBQ3REO1lBQ0Y7WUFDQSxNQUFNbUMsY0FBY0MsdUJBQXVCUjtZQUUzQywrQ0FBK0M7WUFDL0MsSUFBSSxDQUFDbUwsV0FBVyxDQUFDVixXQUFXLEVBQUU7Z0JBQzVCVSxXQUFXLENBQUNWLFdBQVcsR0FBR2IsU0FBU29CLHNCQUFzQjtZQUMzRDtZQUNBRyxXQUFXLENBQUNWLFdBQVcsQ0FBQ0EsWUFBWWxLLGFBQWFILE9BQU9zSztRQUMxRDtRQUNBO1lBQ0UsTUFBTSxFQUNKMEIsdUJBQXVCLEVBQ3ZCRSxZQUFZLEVBQ2IsR0FBR0osZUFBZWpRLE9BQU87WUFDMUIsSUFBSSxDQUFDbVEseUJBQXlCO2dCQUM1QixNQUFNLEVBQ0pwTSxNQUFNLEVBQ1AsR0FBRzdCLG1CQUFtQmxDLE9BQU87Z0JBQzlCLE1BQU00USxXQUFXdkosTUFBTUMsSUFBSSxDQUFDdkQsT0FBTzhNLElBQUk7Z0JBQ3ZDWixlQUFlalEsT0FBTyxDQUFDcVEsWUFBWSxHQUFHTztnQkFDdEMsTUFBTUUsb0JBQW9CVCxhQUFhNUssTUFBTSxHQUFHLEtBQUssQ0FBQzJGLFNBQVNpRixjQUFjTztnQkFDN0UsSUFBSUUsbUJBQW1CO29CQUNyQixJQUFJekosTUFBTUMsSUFBSSxDQUFDdkQsT0FBTzRELE1BQU0sSUFBSW9KLElBQUksQ0FBQ2pNLENBQUFBLFFBQVNBLE1BQU05RSxPQUFPLENBQUNxQyxrQkFBa0IsSUFBSXlDLE1BQU05RSxPQUFPLENBQUNpQixLQUFLLElBQUksT0FBTzt3QkFDOUdnUCxlQUFlalEsT0FBTyxDQUFDbVEsdUJBQXVCLEdBQUc7d0JBQ2pEMUgsUUFBUXVJLElBQUksQ0FBQyxDQUFDLGtGQUFrRixDQUFDO29CQUNuRztnQkFDRjtZQUNGO1FBQ0Y7SUFDRixHQUFHO1FBQUN4QztRQUFZeks7UUFBUUk7UUFBT3NLO0tBQVE7SUFDdkMsTUFBTTlNLGVBQWUzQyxZQUFZLENBQUMyQixJQUFJOFA7UUFDcEMsTUFBTSxFQUNKMU0sTUFBTSxFQUNOaEMsT0FBTzJPLGNBQWMsRUFDdEIsR0FBR3hPLG1CQUFtQmxDLE9BQU87UUFDOUIsTUFBTXNFLGNBQWNDLHVCQUF1QlI7UUFDM0MsTUFBTWEsUUFBUU4sWUFBWU8sU0FBUyxDQUFDQyxDQUFBQSxRQUFTQSxNQUFNOUUsT0FBTyxDQUFDVyxFQUFFLEtBQUtBO1FBQ2xFLE1BQU13QixPQUFPZ0MsS0FBSyxDQUFDUyxNQUFNO1FBQ3pCLE1BQU03QyxRQUFRME8sbUJBQW1CQztRQUNqQyxJQUFJM08sVUFBVSxVQUFVO1lBQ3RCLE1BQU1pQyxrQkFBa0JDLDRCQUE0Qkg7WUFDcEQsT0FBTzNCLE9BQU8sTUFBTTZCO1FBQ3RCLE9BQU87WUFDTCxPQUFPN0I7UUFDVDtJQUNGLEdBQUc7UUFBQzJCO1FBQVNLO0tBQU07SUFDbkIsTUFBTXZDLGdCQUFnQjVDLFlBQVksQ0FBQzJCLElBQUlGO1FBQ3JDLE1BQU0sRUFDSnNELE1BQU0sRUFDUCxHQUFHN0IsbUJBQW1CbEMsT0FBTztRQUU5QixtRUFBbUU7UUFDbkUsa0NBQWtDO1FBQ2xDLDRFQUE0RTtRQUM1RSxJQUFJK0QsT0FBTzVCLElBQUksS0FBSyxHQUFHO1lBQ3JCO2dCQUNFLElBQUksQ0FBQzhOLGVBQWVqUSxPQUFPLENBQUNrUSx3QkFBd0IsRUFBRTtvQkFDcEQsSUFBSXpQLGVBQWUsTUFBTTt3QkFDdkJ3UCxlQUFlalEsT0FBTyxDQUFDa1Esd0JBQXdCLEdBQUc7d0JBQ2xEekgsUUFBUXVJLElBQUksQ0FBQyxDQUFDLHdGQUF3RixDQUFDO29CQUN6RztnQkFDRjtZQUNGO1lBQ0EsT0FBTztnQkFDTEMsV0FBVztnQkFDWGxPLFVBQVV0QyxlQUFlLE9BQU9BLGNBQWNvQztnQkFDOUNxTyxZQUFZO2dCQUNaLGdGQUFnRjtnQkFDaEZDLFVBQVU7WUFDWjtRQUNGO1FBQ0EsTUFBTXBPLFdBQVc2RCxZQUFZN0MsUUFBUXBELElBQUl3RDtRQUN6QyxPQUFPO1lBQ0w4TSxXQUFXO1lBQ1hsTztZQUNBbU8sWUFBWTtZQUNaLGdGQUFnRjtZQUNoRkMsVUFBVTtZQUNWLDBEQUEwRDtZQUMxRCw2Q0FBNkM7WUFDN0NDLGVBQWUxQixvQ0FBb0NFLG1CQUFtQixPQUFPLFNBQVMvTTtRQUN4RjtJQUNGLEdBQUc7UUFBQytNO1FBQWdCRjtRQUFrQ3ZMO0tBQU07SUFDNUQsTUFBTXRDLGdCQUFnQjdDLFlBQVksQ0FBQzJCLElBQUlrRjtRQUNyQyxNQUFNLEVBQ0o5RCxLQUFLLEVBQ04sR0FBR0csbUJBQW1CbEMsT0FBTztRQUM5QnVJLG1CQUFtQnhHLE9BQU84RDtRQUMxQmlLLFVBQVV1QixDQUFBQTtZQUNSLElBQUlBLFdBQVdDLEdBQUcsQ0FBQzNRLEtBQUs7Z0JBQ3RCLE9BQU8wUTtZQUNUO1lBQ0EsTUFBTUUsYUFBYSxJQUFJeEIsSUFBSXNCO1lBQzNCRSxXQUFXbk0sR0FBRyxDQUFDekUsSUFBSWtGO1lBQ25CLE9BQU8wTDtRQUNUO0lBQ0YsR0FBRyxFQUFFO0lBQ0wsTUFBTUMsdUJBQXVCeFMsWUFBWXlJLENBQUFBO1FBQ3ZDLE1BQU1xRCxnQkFBZ0J4SCxDQUFBQTtZQUNwQkEsTUFBTStHLGNBQWM7WUFDcEIsTUFBTSxFQUNKbEUsU0FBUyxFQUNUcEMsTUFBTSxFQUNOSSxPQUFPUixTQUFTLEVBQ2pCLEdBQUd6QixtQkFBbUJsQyxPQUFPO1lBQzlCLE1BQU1zRSxjQUFjQyx1QkFBdUJSO1lBQzNDLE1BQU0sQ0FBQ1AsVUFBVUMsUUFBUSxHQUFHK0Qsd0JBQXdCMUQsU0FBUzJELFVBQVVuRDtZQUN2RSxJQUFJZCxZQUFZLFFBQVFDLFdBQVcsTUFBTTtnQkFDdkM7WUFDRjtZQUNBLElBQUlxSixXQUFXTixZQUFZbEosT0FBT1EsU0FBUzJELFVBQVVuRCxhQUFhNkIsV0FBV3hDLFdBQVdxTSxvQkFBb0JoUSxPQUFPO1lBQ25ILElBQUk4TSxhQUFhLEdBQUc7Z0JBQ2xCO1lBQ0Y7WUFDQSxNQUFNM0QsZUFBZWpELGNBQWNwQztZQUNuQyxNQUFNc0ksT0FBT2pELGFBQWFHLHFCQUFxQjtZQUMvQyxNQUFNb0MsZUFBZXZGLGNBQWM7WUFFbkMsc0JBQXNCO1lBQ3RCLElBQUlZLFNBQVMwSyxHQUFHLEtBQUssU0FBUy9GLGNBQWM7Z0JBQzFDb0IsV0FBVyxDQUFDQTtZQUNkO1lBQ0EsTUFBTTNLLE9BQU91SixlQUFlVSxLQUFLL0MsS0FBSyxHQUFHK0MsS0FBS2hELE1BQU07WUFDcEQsTUFBTWtCLFFBQVF3QyxXQUFXM0ssT0FBTztZQUVoQywrQ0FBK0M7WUFDL0MsNERBQTREO1lBQzVELE1BQU1xQyxZQUFZbkIsY0FBY0MsT0FBT3BCLG1CQUFtQmxDLE9BQU8sRUFBRXdELFVBQVVDLFNBQVM2RyxPQUFPM0csV0FBV0Msd0JBQXdCNUQsT0FBTyxFQUFFZ1Esb0JBQW9CaFEsT0FBTztZQUNwSyxNQUFNMFIsZUFBZSxDQUFDdEcsU0FBU3pILFdBQVdhO1lBRTFDLHNFQUFzRTtZQUN0RSxJQUFJb0gsYUFBYXRJLFVBQVV5SSxhQUFhekksUUFBUTtnQkFDOUMsb0ZBQW9GO2dCQUNwRiw4Q0FBOEM7Z0JBQzlDLDhEQUE4RDtnQkFDOUQsSUFBSWlOLGFBQWF2USxPQUFPLElBQUlzSyxPQUFPO29CQUNqQyxJQUFJLENBQUNvSCxjQUFjO3dCQUNqQixvRUFBb0U7d0JBQ3BFLDZDQUE2Qzt3QkFDN0MsZ0NBQWdDO3dCQUVoQyxJQUFJaEcsY0FBYzs0QkFDaEI4QixxQkFBcUJWLFdBQVcsSUFBSSxtQkFBbUI7d0JBQ3pELE9BQU87NEJBQ0xVLHFCQUFxQlYsV0FBVyxJQUFJLGlCQUFpQjt3QkFDdkQ7b0JBQ0YsT0FBTzt3QkFDTCwwREFBMEQ7d0JBQzFEVSxxQkFBcUI5QixlQUFlLGVBQWU7b0JBQ3JEO2dCQUNGO1lBQ0Y7WUFDQSxJQUFJZ0csY0FBYztnQkFDaEIsTUFBTS9MLCtCQUErQjJLLGdDQUFnQ3RRLE9BQU87Z0JBRTVFLHNFQUFzRTtnQkFDdEVrSixTQUFTMUU7Z0JBRVQsK0VBQStFO2dCQUMvRSx5RkFBeUY7Z0JBQ3pGa0IsbUJBQW1CcEIsYUFBYUUsV0FBV21CO1lBQzdDO1lBQ0E0SyxhQUFhdlEsT0FBTyxHQUFHc0s7UUFDekI7UUFDQSxPQUFPUTtJQUNULEdBQUc7UUFBQ2hIO0tBQVE7SUFDWixNQUFNOUIsa0JBQWtCaEQsWUFBWTJCLENBQUFBO1FBQ2xDbVAsVUFBVXVCLENBQUFBO1lBQ1IsSUFBSSxDQUFDQSxXQUFXQyxHQUFHLENBQUMzUSxLQUFLO2dCQUN2QixPQUFPMFE7WUFDVDtZQUNBLE1BQU1FLGFBQWEsSUFBSXhCLElBQUlzQjtZQUMzQkUsV0FBV0ksTUFBTSxDQUFDaFI7WUFDbEIsT0FBTzRRO1FBQ1Q7SUFDRixHQUFHLEVBQUU7SUFDTCxNQUFNOVAsZ0JBQWdCekMsWUFBWTJCLENBQUFBO1FBQ2hDLE1BQU0sRUFDSm9ELE1BQU0sRUFDTkksT0FBT1IsU0FBUyxFQUNqQixHQUFHekIsbUJBQW1CbEMsT0FBTztRQUM5QixNQUFNOEUsUUFBUWYsT0FBTzZOLEdBQUcsQ0FBQ2pSO1FBQ3pCLElBQUltRSxTQUFTLE1BQU07WUFDakI7UUFDRjtRQUNBLE1BQU0sRUFDSnZFLGFBQWEsRUFDYkMsV0FBVyxFQUNaLEdBQUdzRSxNQUFNOUUsT0FBTztRQUNqQixJQUFJLENBQUNRLGFBQWE7WUFDaEI7UUFDRjtRQUNBLE1BQU04RCxjQUFjQyx1QkFBdUJSO1FBQzNDLE1BQU1hLFFBQVFOLFlBQVlvRCxPQUFPLENBQUM1QztRQUNsQyxJQUFJRixRQUFRLEdBQUc7WUFDYjtRQUNGO1FBQ0EsTUFBTWlOLGNBQWNsTyxTQUFTLENBQUNpQixNQUFNO1FBQ3BDLElBQUlpTixnQkFBZ0J0UixlQUFlO1lBQ2pDLDhCQUE4QjtZQUM5QjtRQUNGO1FBQ0FxRCx3QkFBd0I1RCxPQUFPLENBQUNvRixHQUFHLENBQUN6RSxJQUFJa1I7UUFDeEMsTUFBTSxDQUFDck8sVUFBVUMsUUFBUSxHQUFHc0MscUJBQXFCcEYsSUFBSTJEO1FBQ3JELElBQUlkLFlBQVksUUFBUUMsV0FBVyxNQUFNO1lBQ3ZDO1FBQ0Y7UUFDQSxNQUFNdUMsY0FBY3BCLFVBQVVOLFlBQVltQixNQUFNLEdBQUc7UUFDbkQsTUFBTTZFLFFBQVF0RSxjQUFjNkwsY0FBY3RSLGdCQUFnQnNSO1FBQzFELE1BQU1yTixZQUFZbkIsY0FBYyxNQUFNbkIsbUJBQW1CbEMsT0FBTyxFQUFFd0QsVUFBVUMsU0FBUzZHLE9BQU8zRyxXQUFXQyx3QkFBd0I1RCxPQUFPLEVBQUU7UUFDeEksSUFBSTJELGNBQWNhLFdBQVc7WUFDM0IsTUFBTW1CLCtCQUErQjJLLGdDQUFnQ3RRLE9BQU87WUFDNUVrSixTQUFTMUU7WUFFVCwrRUFBK0U7WUFDL0UseUZBQXlGO1lBQ3pGa0IsbUJBQW1CcEIsYUFBYUUsV0FBV21CO1FBQzdDO0lBQ0YsR0FBRyxFQUFFO0lBQ0wsTUFBTWpFLGNBQWMxQyxZQUFZMkIsQ0FBQUE7UUFDOUIsTUFBTSxFQUNKb0QsTUFBTSxFQUNOSSxPQUFPUixTQUFTLEVBQ2pCLEdBQUd6QixtQkFBbUJsQyxPQUFPO1FBQzlCLE1BQU04RSxRQUFRZixPQUFPNk4sR0FBRyxDQUFDalI7UUFDekIsSUFBSW1FLFNBQVMsTUFBTTtZQUNqQjtRQUNGO1FBQ0EsTUFBTSxFQUNKdkUsYUFBYSxFQUNiTyxPQUFPLEVBQ1IsR0FBR2dFLE1BQU05RSxPQUFPO1FBQ2pCLE1BQU04UixxQkFBcUJsTyx3QkFBd0I1RCxPQUFPLENBQUM0UixHQUFHLENBQUNqUixPQUFPRztRQUN0RSxJQUFJLENBQUNnUixvQkFBb0I7WUFDdkI7UUFDRjtRQUNBLE1BQU14TixjQUFjQyx1QkFBdUJSO1FBQzNDLE1BQU1hLFFBQVFOLFlBQVlvRCxPQUFPLENBQUM1QztRQUNsQyxJQUFJRixRQUFRLEdBQUc7WUFDYjtRQUNGO1FBQ0EsTUFBTWlOLGNBQWNsTyxTQUFTLENBQUNpQixNQUFNO1FBQ3BDLElBQUlpTixnQkFBZ0J0UixlQUFlO1lBQ2pDLDZCQUE2QjtZQUM3QjtRQUNGO1FBQ0EsTUFBTSxDQUFDaUQsVUFBVUMsUUFBUSxHQUFHc0MscUJBQXFCcEYsSUFBSTJEO1FBQ3JELElBQUlkLFlBQVksUUFBUUMsV0FBVyxNQUFNO1lBQ3ZDO1FBQ0Y7UUFDQSxNQUFNdUMsY0FBY3BCLFVBQVVOLFlBQVltQixNQUFNLEdBQUc7UUFDbkQsTUFBTTZFLFFBQVF0RSxjQUFjekYsZ0JBQWdCdVIscUJBQXFCQTtRQUNqRSxNQUFNdE4sWUFBWW5CLGNBQWMsTUFBTW5CLG1CQUFtQmxDLE9BQU8sRUFBRXdELFVBQVVDLFNBQVM2RyxPQUFPM0csV0FBV0Msd0JBQXdCNUQsT0FBTyxFQUFFO1FBQ3hJLElBQUkyRCxjQUFjYSxXQUFXO1lBQzNCLE1BQU1tQiwrQkFBK0IySyxnQ0FBZ0N0USxPQUFPO1lBQzVFa0osU0FBUzFFO1lBRVQsK0VBQStFO1lBQy9FLHlGQUF5RjtZQUN6RmtCLG1CQUFtQnBCLGFBQWFFLFdBQVdtQjtRQUM3QztJQUNGLEdBQUcsRUFBRTtJQUNMLE1BQU03RCxjQUFjOUMsWUFBWSxDQUFDMkIsSUFBSXFFLFVBQVV5TDtRQUM3QyxNQUFNLEVBQ0o5UCxJQUFJbUQsT0FBTyxFQUNYQyxNQUFNLEVBQ05JLE9BQU9SLFNBQVMsRUFDaEI1QixLQUFLLEVBQ04sR0FBR0csbUJBQW1CbEMsT0FBTztRQUM5QixJQUFJLENBQUN5USxtQkFBbUIxTyxLQUFJLE1BQU8sVUFBVTtZQUMzQyxNQUFNaUMsa0JBQWtCQyw0QkFBNEJIO1lBQ3BEa0IsV0FBV0EsV0FBV2hCLGtCQUFrQjtRQUMxQztRQUNBLE1BQU1jLFFBQVFmLE9BQU82TixHQUFHLENBQUNqUjtRQUN6QixJQUFJbUUsU0FBUyxNQUFNO1lBQ2pCO1FBQ0Y7UUFDQSxJQUFJLEVBQ0Z2RSxhQUFhLEVBQ2JDLFdBQVcsRUFDWEssT0FBTyxFQUNQQyxPQUFPLEVBQ1IsR0FBR2dFLE1BQU05RSxPQUFPO1FBQ2pCLElBQUkrQixVQUFVLFVBQVU7WUFDdEIsTUFBTWlDLGtCQUFrQkMsNEJBQTRCSDtZQUNwRGhELFVBQVVBLFVBQVVrRCxrQkFBa0I7WUFDdEMsSUFBSW5ELFdBQVcsTUFBTTtnQkFDbkJBLFVBQVVBLFVBQVVtRCxrQkFBa0I7WUFDeEM7UUFDRjtRQUNBLE1BQU1NLGNBQWNDLHVCQUF1QlI7UUFDM0MsTUFBTWEsUUFBUU4sWUFBWW9ELE9BQU8sQ0FBQzVDO1FBQ2xDLElBQUlGLFFBQVEsR0FBRztZQUNiO1FBQ0Y7UUFDQSxNQUFNaU4sY0FBY2xPLFNBQVMsQ0FBQ2lCLE1BQU07UUFDcEMsSUFBSWlOLGdCQUFnQjdNLFVBQVU7WUFDNUI7UUFDRjtRQUNBLElBQUl4RSxlQUFld0UsYUFBYXpFO2FBQXNCO1lBQ3BELE1BQU13UixpQkFBaUIvTTtZQUN2QkEsV0FBV0UsS0FBS21ELEdBQUcsQ0FBQ3hILFdBQVcsT0FBT0EsVUFBVSxLQUFLcUUsS0FBS29ELEdBQUcsQ0FBQ3hILFNBQVNrRTtZQUN2RTtnQkFDRSxJQUFJK00sbUJBQW1CL00sVUFBVTtvQkFDL0J5RCxRQUFRQyxLQUFLLENBQUMsQ0FBQyxjQUFjLEVBQUVxSixlQUFlLHVCQUF1QixFQUFFak4sTUFBTTlFLE9BQU8sQ0FBQ1csRUFBRSxDQUFDLDRDQUE0QyxDQUFDO2dCQUN2STtZQUNGO1FBQ0Y7UUFDQSxNQUFNLENBQUM2QyxVQUFVQyxRQUFRLEdBQUdzQyxxQkFBcUJwRixJQUFJMkQ7UUFDckQsSUFBSWQsWUFBWSxRQUFRQyxXQUFXLE1BQU07WUFDdkM7UUFDRjtRQUNBLE1BQU11QyxjQUFjcEIsVUFBVU4sWUFBWW1CLE1BQU0sR0FBRztRQUNuRCxNQUFNNkUsUUFBUXRFLGNBQWM2TCxjQUFjN00sV0FBV0EsV0FBVzZNO1FBQ2hFLE1BQU1yTixZQUFZbkIsY0FBYyxNQUFNbkIsbUJBQW1CbEMsT0FBTyxFQUFFd0QsVUFBVUMsU0FBUzZHLE9BQU8zRyxXQUFXQyx3QkFBd0I1RCxPQUFPLEVBQUU7UUFDeEksSUFBSTJELGNBQWNhLFdBQVc7WUFDM0IsTUFBTW1CLCtCQUErQjJLLGdDQUFnQ3RRLE9BQU87WUFDNUVrSixTQUFTMUU7WUFFVCwrRUFBK0U7WUFDL0UseUZBQXlGO1lBQ3pGa0IsbUJBQW1CcEIsYUFBYUUsV0FBV21CO1FBQzdDO0lBQ0YsR0FBRyxFQUFFO0lBQ0wsTUFBTXJFLFVBQVVqQyxRQUFRLElBQU87WUFDN0J1UTtZQUNBbk87WUFDQTBFO1lBQ0F6RTtZQUNBQztZQUNBQztZQUNBa0M7WUFDQWpDO1lBQ0EyUDtZQUNBMVA7WUFDQWtRLGVBQWUsQ0FBQ3JSLElBQUkyQztnQkFDbEJ1TSxrQkFBa0JsUDtnQkFDbEIsSUFBSWlMLGFBQWF0SSxVQUFVeUksYUFBYXpJLFFBQVE7b0JBQzlDLE1BQU15SCxnQkFBZ0I5RCxnQkFBZ0J0RztvQkFDdENxUCxvQkFBb0JoUSxPQUFPLEdBQUc7d0JBQzVCME0sZ0JBQWdCM0IsY0FBY3pCLHFCQUFxQjt3QkFDbkRtRCxZQUFZbEIsY0FBY2pJLE9BQU8zQyxJQUFJd0Y7d0JBQ3JDaEMsT0FBT2pDLG1CQUFtQmxDLE9BQU8sQ0FBQ21FLEtBQUs7b0JBQ3pDO2dCQUNGO1lBQ0Y7WUFDQThOLGNBQWM7Z0JBQ1o1RTtnQkFDQXdDLGtCQUFrQjtnQkFDbEJHLG9CQUFvQmhRLE9BQU8sR0FBRztZQUNoQztZQUNBK0I7WUFDQUM7UUFDRixJQUFJO1FBQUM0TjtRQUFnQm5PO1FBQWUwRTtRQUFXekU7UUFBYUM7UUFBY0M7UUFBZWtDO1FBQVNqQztRQUFlMlA7UUFBc0IxUDtRQUFhQztRQUFPQztLQUFnQjtJQUMzSyxNQUFNZCxRQUFRO1FBQ1pnUixTQUFTO1FBQ1RDLGVBQWVoTSxjQUFjLGVBQWUsUUFBUTtRQUNwRGlELFFBQVE7UUFDUitILFVBQVU7UUFDVjlILE9BQU87SUFDVDtJQUNBLE9BQU94SyxjQUFjb0Isa0JBQWtCbVMsUUFBUSxFQUFFO1FBQy9DaFMsVUFBVXZCLGNBQWN3QyxNQUFNO1lBQzVCakI7WUFDQUMsV0FBV0M7WUFDWCxvQkFBb0I7WUFDcEIsOEJBQThCNkY7WUFDOUIsdUJBQXVCckM7WUFDdkIsMEJBQTBCL0I7WUFDMUJiLE9BQU87Z0JBQ0wsR0FBR0EsS0FBSztnQkFDUixHQUFHQyxjQUFjO1lBQ25CO1FBQ0Y7UUFDQW9PLE9BQU9qTztJQUNUO0FBQ0Y7QUFDQSxNQUFNK1EsYUFBYXRULFdBQVcsQ0FBQ21FLE9BQU9DLE1BQVF0RSxjQUFjNFEsNEJBQTRCO1FBQ3RGLEdBQUd2TSxLQUFLO1FBQ1J4QyxjQUFjeUM7SUFDaEI7QUFDQXNNLDJCQUEyQnZQLFdBQVcsR0FBRztBQUN6Q21TLFdBQVduUyxXQUFXLEdBQUc7QUFFekIsU0FBU29TLGtCQUFrQixFQUN6QmxTLFdBQVcsSUFBSSxFQUNmQyxXQUFXQyxxQkFBcUIsRUFBRSxFQUNsQ3VLLFdBQVcsS0FBSyxFQUNoQmxLLElBQUlDLGNBQWMsSUFBSSxFQUN0QjJSLFVBQVUsRUFDVnJSLE9BQU9DLGlCQUFpQixDQUFDLENBQUMsRUFDMUJDLFNBQVNDLE9BQU8sS0FBSyxFQUN0QjtJQUNDLE1BQU1tUixnQkFBZ0JsVCxPQUFPO0lBRTdCLHdEQUF3RDtJQUN4RCxNQUFNMkMsZUFBZTNDLE9BQU87UUFDMUJpVDtJQUNGO0lBQ0FyVCxVQUFVO1FBQ1IrQyxhQUFhakMsT0FBTyxDQUFDdVMsVUFBVSxHQUFHQTtJQUNwQztJQUNBLE1BQU1FLG9CQUFvQnhULFdBQVdnQjtJQUNyQyxJQUFJd1Msc0JBQXNCLE1BQU07UUFDOUIsTUFBTWxSLE1BQU0sQ0FBQywyRUFBMkUsQ0FBQztJQUMzRjtJQUNBLE1BQU0sRUFDSnFPLGNBQWMsRUFDZHpKLFNBQVMsRUFDVHJDLE9BQU8sRUFDUDBOLG9CQUFvQixFQUNwQlEsYUFBYSxFQUNiQyxZQUFZLEVBQ2IsR0FBR1E7SUFDSixNQUFNQyxpQkFBaUI5UyxZQUFZZ0I7SUFDbkMsTUFBTStSLGFBQWEvQyxtQkFBbUI4QztJQUN0QyxNQUFNLENBQUNFLFdBQVdDLGFBQWEsR0FBR3RULFNBQVM7SUFDM0MsTUFBTSxDQUFDdUwsZUFBZWdJLGlCQUFpQixHQUFHdlQsU0FBUztJQUNuRCxNQUFNd1Qsc0JBQXNCL1QsWUFBWTtRQUN0QywwREFBMEQ7UUFDMUQsZ0VBQWdFO1FBQ2hFLE1BQU1nVSxNQUFNUixjQUFjeFMsT0FBTztRQUNqQ2dULElBQUlDLElBQUk7UUFDUmhCO1FBQ0EsTUFBTSxFQUNKTSxVQUFVLEVBQ1gsR0FBR3RRLGFBQWFqQyxPQUFPO1FBQ3hCLElBQUl1UyxZQUFZO1lBQ2RBLFdBQVc7UUFDYjtJQUNGLEdBQUc7UUFBQ047S0FBYTtJQUNqQi9TLFVBQVU7UUFDUixJQUFJMkwsVUFBVTtZQUNaaUksaUJBQWlCO1FBQ25CLE9BQU87WUFDTCxNQUFNaEksZ0JBQWdCMEcscUJBQXFCa0I7WUFDM0NJLGlCQUFpQixJQUFNaEk7UUFDekI7SUFDRixHQUFHO1FBQUNEO1FBQVU2SDtRQUFnQmxCO0tBQXFCO0lBQ25EdFMsVUFBVTtRQUNSLElBQUkyTCxZQUFZQyxpQkFBaUIsUUFBUSxDQUFDNkgsWUFBWTtZQUNwRDtRQUNGO1FBQ0EsTUFBTU8sU0FBUzVQLENBQUFBO1lBQ2J3SCxjQUFjeEg7UUFDaEI7UUFDQSxNQUFNNlAsZUFBZTdQLENBQUFBO1lBQ25Cd0gsY0FBY3hIO1FBQ2hCO1FBQ0EsTUFBTThQLGFBQWFaLGNBQWN4UyxPQUFPO1FBQ3hDLE1BQU1xVCxpQkFBaUJELFdBQVdFLGFBQWE7UUFDL0NELGVBQWVFLElBQUksQ0FBQ2hKLGdCQUFnQixDQUFDLGVBQWV3STtRQUNwRE0sZUFBZUUsSUFBSSxDQUFDaEosZ0JBQWdCLENBQUMsYUFBYTJJO1FBQ2xERyxlQUFlRSxJQUFJLENBQUNoSixnQkFBZ0IsQ0FBQyxhQUFhMkk7UUFDbERHLGVBQWVFLElBQUksQ0FBQ2hKLGdCQUFnQixDQUFDLGNBQWM0STtRQUNuREssT0FBT2pKLGdCQUFnQixDQUFDLFdBQVd3STtRQUNuQ1MsT0FBT2pKLGdCQUFnQixDQUFDLFlBQVl3STtRQUNwQyxPQUFPO1lBQ0xNLGVBQWVFLElBQUksQ0FBQzdJLG1CQUFtQixDQUFDLGVBQWVxSTtZQUN2RE0sZUFBZUUsSUFBSSxDQUFDN0ksbUJBQW1CLENBQUMsYUFBYXdJO1lBQ3JERyxlQUFlRSxJQUFJLENBQUM3SSxtQkFBbUIsQ0FBQyxhQUFhd0k7WUFDckRHLGVBQWVFLElBQUksQ0FBQzdJLG1CQUFtQixDQUFDLGNBQWN5STtZQUN0REssT0FBTzlJLG1CQUFtQixDQUFDLFdBQVdxSTtZQUN0Q1MsT0FBTzlJLG1CQUFtQixDQUFDLFlBQVlxSTtRQUN6QztJQUNGLEdBQUc7UUFBQzVNO1FBQVcwRTtRQUFVOEg7UUFBWTdIO1FBQWVpSTtLQUFvQjtJQUN4RW5JLHVDQUF1QztRQUNyQ0M7UUFDQXBELFVBQVVpTDtRQUNWNUg7SUFDRjtJQUNBLE1BQU01SixRQUFRO1FBQ1p1UyxRQUFRdEcsZUFBZWhIO1FBQ3ZCdU4sYUFBYTtRQUNiQyxZQUFZO0lBQ2Q7SUFDQSxPQUFPOVUsY0FBY3dDLE1BQU07UUFDekJqQjtRQUNBQyxXQUFXQztRQUNYLDZCQUE2QnFTLGFBQWEsWUFBWUMsWUFBWSxhQUFhL1A7UUFDL0UsOEJBQThCc0Q7UUFDOUIsdUJBQXVCckM7UUFDdkIsb0NBQW9DLENBQUMrRztRQUNyQywrQkFBK0I2SDtRQUMvQmtCLFFBQVEsSUFBTWYsYUFBYTtRQUMzQmdCLFNBQVMsSUFBTWhCLGFBQWE7UUFDNUJpQixhQUFheFEsQ0FBQUE7WUFDWDBPLGNBQWNVLGdCQUFnQnBQLE1BQU15USxXQUFXO1lBQy9DLE1BQU0sRUFDSnhCLFVBQVUsRUFDWCxHQUFHdFEsYUFBYWpDLE9BQU87WUFDeEIsSUFBSXVTLFlBQVk7Z0JBQ2RBLFdBQVc7WUFDYjtRQUNGO1FBQ0F5QixXQUFXakI7UUFDWGtCLGVBQWVsQjtRQUNmbUIsWUFBWW5CO1FBQ1pvQixjQUFjN1EsQ0FBQUE7WUFDWjBPLGNBQWNVLGdCQUFnQnBQLE1BQU15USxXQUFXO1lBQy9DLE1BQU0sRUFDSnhCLFVBQVUsRUFDWCxHQUFHdFEsYUFBYWpDLE9BQU87WUFDeEIsSUFBSXVTLFlBQVk7Z0JBQ2RBLFdBQVc7WUFDYjtRQUNGO1FBQ0FwUCxLQUFLcVA7UUFDTDRCLE1BQU07UUFDTmxULE9BQU87WUFDTCxHQUFHQSxLQUFLO1lBQ1IsR0FBR0MsY0FBYztRQUNuQjtRQUNBa1QsVUFBVTtJQUNaO0FBQ0Y7QUFDQS9CLGtCQUFrQnBTLFdBQVcsR0FBRztBQUU2QyIsInNvdXJjZXMiOlsid2VicGFjazovL2hhd2EtZG9jcy8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtcmVzaXphYmxlLXBhbmVsc0AwLjAuNTVfcmVhY3QtZG9tQDE4LjIuMF9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL3JlYWN0LXJlc2l6YWJsZS1wYW5lbHMvZGlzdC9yZWFjdC1yZXNpemFibGUtcGFuZWxzLmRldmVsb3BtZW50Lm5vZGUuZXNtLmpzP2RhZjQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vLyBUaGlzIG1vZHVsZSBleGlzdHMgdG8gd29yayBhcm91bmQgV2VicGFjayBpc3N1ZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay93ZWJwYWNrL2lzc3Vlcy8xNDgxNFxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1pbXBvcnRzXG5cbmNvbnN0IHtcbiAgY3JlYXRlRWxlbWVudCxcbiAgY3JlYXRlQ29udGV4dCxcbiAgZm9yd2FyZFJlZixcbiAgdXNlQ2FsbGJhY2ssXG4gIHVzZUNvbnRleHQsXG4gIHVzZUVmZmVjdCxcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZSxcbiAgdXNlTGF5b3V0RWZmZWN0LFxuICB1c2VNZW1vLFxuICB1c2VSZWYsXG4gIHVzZVN0YXRlXG59ID0gUmVhY3Q7XG5cbi8vIGB0b1N0cmluZygpYCBwcmV2ZW50cyBidW5kbGVycyBmcm9tIHRyeWluZyB0byBgaW1wb3J0IHsgdXNlSWQgfSBmcm9tICdyZWFjdCdgXG5jb25zdCB1c2VJZCA9IFJlYWN0W1widXNlSWRcIi50b1N0cmluZygpXTtcblxuY29uc3Qgd3JhcHBlZFVzZUlkID0gdHlwZW9mIHVzZUlkID09PSBcImZ1bmN0aW9uXCIgPyB1c2VJZCA6ICgpID0+IG51bGw7XG5sZXQgY291bnRlciA9IDA7XG5mdW5jdGlvbiB1c2VVbmlxdWVJZChpZEZyb21QYXJhbXMgPSBudWxsKSB7XG4gIGNvbnN0IGlkRnJvbVVzZUlkID0gd3JhcHBlZFVzZUlkKCk7XG4gIGNvbnN0IGlkUmVmID0gdXNlUmVmKGlkRnJvbVBhcmFtcyB8fCBpZEZyb21Vc2VJZCB8fCBudWxsKTtcbiAgaWYgKGlkUmVmLmN1cnJlbnQgPT09IG51bGwpIHtcbiAgICBpZFJlZi5jdXJyZW50ID0gXCJcIiArIGNvdW50ZXIrKztcbiAgfVxuICByZXR1cm4gaWRSZWYuY3VycmVudDtcbn1cblxuY29uc3QgUGFuZWxHcm91cENvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwpO1xuUGFuZWxHcm91cENvbnRleHQuZGlzcGxheU5hbWUgPSBcIlBhbmVsR3JvdXBDb250ZXh0XCI7XG5cbmZ1bmN0aW9uIFBhbmVsV2l0aEZvcndhcmRlZFJlZih7XG4gIGNoaWxkcmVuID0gbnVsbCxcbiAgY2xhc3NOYW1lOiBjbGFzc05hbWVGcm9tUHJvcHMgPSBcIlwiLFxuICBjb2xsYXBzZWRTaXplID0gMCxcbiAgY29sbGFwc2libGUgPSBmYWxzZSxcbiAgZGVmYXVsdFNpemUgPSBudWxsLFxuICBmb3J3YXJkZWRSZWYsXG4gIGlkOiBpZEZyb21Qcm9wcyA9IG51bGwsXG4gIG1heFNpemUgPSBudWxsLFxuICBtaW5TaXplLFxuICBvbkNvbGxhcHNlID0gbnVsbCxcbiAgb25SZXNpemUgPSBudWxsLFxuICBvcmRlciA9IG51bGwsXG4gIHN0eWxlOiBzdHlsZUZyb21Qcm9wcyA9IHt9LFxuICB0YWdOYW1lOiBUeXBlID0gXCJkaXZcIlxufSkge1xuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChQYW5lbEdyb3VwQ29udGV4dCk7XG4gIGlmIChjb250ZXh0ID09PSBudWxsKSB7XG4gICAgdGhyb3cgRXJyb3IoYFBhbmVsIGNvbXBvbmVudHMgbXVzdCBiZSByZW5kZXJlZCB3aXRoaW4gYSBQYW5lbEdyb3VwIGNvbnRhaW5lcmApO1xuICB9XG4gIGNvbnN0IHBhbmVsSWQgPSB1c2VVbmlxdWVJZChpZEZyb21Qcm9wcyk7XG4gIGNvbnN0IHtcbiAgICBjb2xsYXBzZVBhbmVsLFxuICAgIGV4cGFuZFBhbmVsLFxuICAgIGdldFBhbmVsU2l6ZSxcbiAgICBnZXRQYW5lbFN0eWxlLFxuICAgIHJlZ2lzdGVyUGFuZWwsXG4gICAgcmVzaXplUGFuZWwsXG4gICAgdW5pdHMsXG4gICAgdW5yZWdpc3RlclBhbmVsXG4gIH0gPSBjb250ZXh0O1xuICBpZiAobWluU2l6ZSA9PSBudWxsKSB7XG4gICAgaWYgKHVuaXRzID09PSBcInBlcmNlbnRhZ2VzXCIpIHtcbiAgICAgIC8vIE1pbWljcyBsZWdhY3kgZGVmYXVsdCB2YWx1ZSBmb3IgcGVyY2VudGFnZSBiYXNlZCBwYW5lbCBncm91cHNcbiAgICAgIG1pblNpemUgPSAxMDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlcmUgaXMgbm8gbWVhbmluZ2Z1bCBtaW5pbXVtIHBpeGVsIGRlZmF1bHQgd2UgY2FuIHByb3ZpZGVcbiAgICAgIG1pblNpemUgPSAwO1xuICAgIH1cbiAgfVxuXG4gIC8vIFVzZSBhIHJlZiB0byBndWFyZCBhZ2FpbnN0IHVzZXJzIHBhc3NpbmcgaW5saW5lIHByb3BzXG4gIGNvbnN0IGNhbGxiYWNrc1JlZiA9IHVzZVJlZih7XG4gICAgb25Db2xsYXBzZSxcbiAgICBvblJlc2l6ZVxuICB9KTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjYWxsYmFja3NSZWYuY3VycmVudC5vbkNvbGxhcHNlID0gb25Db2xsYXBzZTtcbiAgICBjYWxsYmFja3NSZWYuY3VycmVudC5vblJlc2l6ZSA9IG9uUmVzaXplO1xuICB9KTtcbiAgY29uc3Qgc3R5bGUgPSBnZXRQYW5lbFN0eWxlKHBhbmVsSWQsIGRlZmF1bHRTaXplKTtcbiAgY29uc3QgY29tbWl0dGVkVmFsdWVzUmVmID0gdXNlUmVmKHtcbiAgICBzaXplOiBwYXJzZVNpemVGcm9tU3R5bGUoc3R5bGUpXG4gIH0pO1xuICB1c2VSZWYoe1xuICAgIGNhbGxiYWNrc1JlZixcbiAgICBjb2xsYXBzZWRTaXplLFxuICAgIGNvbGxhcHNpYmxlLFxuICAgIGRlZmF1bHRTaXplLFxuICAgIGlkOiBwYW5lbElkLFxuICAgIGlkV2FzQXV0b0dlbmVyYXRlZDogaWRGcm9tUHJvcHMgPT0gbnVsbCxcbiAgICBtYXhTaXplLFxuICAgIG1pblNpemUsXG4gICAgb3JkZXJcbiAgfSk7XG4gIHVzZUltcGVyYXRpdmVIYW5kbGUoZm9yd2FyZGVkUmVmLCAoKSA9PiAoe1xuICAgIGNvbGxhcHNlOiAoKSA9PiBjb2xsYXBzZVBhbmVsKHBhbmVsSWQpLFxuICAgIGV4cGFuZDogKCkgPT4gZXhwYW5kUGFuZWwocGFuZWxJZCksXG4gICAgZ2V0Q29sbGFwc2VkKCkge1xuICAgICAgcmV0dXJuIGNvbW1pdHRlZFZhbHVlc1JlZi5jdXJyZW50LnNpemUgPT09IDA7XG4gICAgfSxcbiAgICBnZXRJZCgpIHtcbiAgICAgIHJldHVybiBwYW5lbElkO1xuICAgIH0sXG4gICAgZ2V0U2l6ZSh1bml0cykge1xuICAgICAgcmV0dXJuIGdldFBhbmVsU2l6ZShwYW5lbElkLCB1bml0cyk7XG4gICAgfSxcbiAgICByZXNpemU6IChwZXJjZW50YWdlLCB1bml0cykgPT4gcmVzaXplUGFuZWwocGFuZWxJZCwgcGVyY2VudGFnZSwgdW5pdHMpXG4gIH0pLCBbY29sbGFwc2VQYW5lbCwgZXhwYW5kUGFuZWwsIGdldFBhbmVsU2l6ZSwgcGFuZWxJZCwgcmVzaXplUGFuZWxdKTtcbiAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoVHlwZSwge1xuICAgIGNoaWxkcmVuLFxuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lRnJvbVByb3BzLFxuICAgIFwiZGF0YS1wYW5lbFwiOiBcIlwiLFxuICAgIFwiZGF0YS1wYW5lbC1jb2xsYXBzaWJsZVwiOiBjb2xsYXBzaWJsZSB8fCB1bmRlZmluZWQsXG4gICAgXCJkYXRhLXBhbmVsLWlkXCI6IHBhbmVsSWQsXG4gICAgXCJkYXRhLXBhbmVsLXNpemVcIjogcGFyc2VGbG9hdChcIlwiICsgc3R5bGUuZmxleEdyb3cpLnRvRml4ZWQoMSksXG4gICAgaWQ6IGBkYXRhLXBhbmVsLWlkLSR7cGFuZWxJZH1gLFxuICAgIHN0eWxlOiB7XG4gICAgICAuLi5zdHlsZSxcbiAgICAgIC4uLnN0eWxlRnJvbVByb3BzXG4gICAgfVxuICB9KTtcbn1cbmNvbnN0IFBhbmVsID0gZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4gY3JlYXRlRWxlbWVudChQYW5lbFdpdGhGb3J3YXJkZWRSZWYsIHtcbiAgLi4ucHJvcHMsXG4gIGZvcndhcmRlZFJlZjogcmVmXG59KSk7XG5QYW5lbFdpdGhGb3J3YXJkZWRSZWYuZGlzcGxheU5hbWUgPSBcIlBhbmVsXCI7XG5QYW5lbC5kaXNwbGF5TmFtZSA9IFwiZm9yd2FyZFJlZihQYW5lbClcIjtcblxuLy8gSEFDS1xuZnVuY3Rpb24gcGFyc2VTaXplRnJvbVN0eWxlKHN0eWxlKSB7XG4gIGNvbnN0IHtcbiAgICBmbGV4R3Jvd1xuICB9ID0gc3R5bGU7XG4gIGlmICh0eXBlb2YgZmxleEdyb3cgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdChmbGV4R3Jvdyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZsZXhHcm93O1xuICB9XG59XG5cbmNvbnN0IFBSRUNJU0lPTiA9IDEwO1xuXG5mdW5jdGlvbiBhZGp1c3RCeURlbHRhKGV2ZW50LCBjb21taXR0ZWRWYWx1ZXMsIGlkQmVmb3JlLCBpZEFmdGVyLCBkZWx0YVBpeGVscywgcHJldlNpemVzLCBwYW5lbFNpemVCZWZvcmVDb2xsYXBzZSwgaW5pdGlhbERyYWdTdGF0ZSkge1xuICBjb25zdCB7XG4gICAgaWQ6IGdyb3VwSWQsXG4gICAgcGFuZWxzLFxuICAgIHVuaXRzXG4gIH0gPSBjb21taXR0ZWRWYWx1ZXM7XG4gIGNvbnN0IGdyb3VwU2l6ZVBpeGVscyA9IHVuaXRzID09PSBcInBpeGVsc1wiID8gZ2V0QXZhaWxhYmxlR3JvdXBTaXplUGl4ZWxzKGdyb3VwSWQpIDogTmFOO1xuICBjb25zdCB7XG4gICAgc2l6ZXM6IGluaXRpYWxTaXplc1xuICB9ID0gaW5pdGlhbERyYWdTdGF0ZSB8fCB7fTtcblxuICAvLyBJZiB3ZSdyZSByZXNpemluZyBieSBtb3VzZSBvciB0b3VjaCwgdXNlIHRoZSBpbml0aWFsIHNpemVzIGFzIGEgYmFzZS5cbiAgLy8gVGhpcyBoYXMgdGhlIGJlbmVmaXQgb2YgY2F1c2luZyBmb3JjZS1jb2xsYXBzZWQgcGFuZWxzIHRvIHNwcmluZyBiYWNrIG9wZW4gaWYgZHJhZyBpcyByZXZlcnNlZC5cbiAgY29uc3QgYmFzZVNpemVzID0gaW5pdGlhbFNpemVzIHx8IHByZXZTaXplcztcbiAgY29uc3QgcGFuZWxzQXJyYXkgPSBwYW5lbHNNYXBUb1NvcnRlZEFycmF5KHBhbmVscyk7XG4gIGNvbnN0IG5leHRTaXplcyA9IGJhc2VTaXplcy5jb25jYXQoKTtcbiAgbGV0IGRlbHRhQXBwbGllZCA9IDA7XG5cbiAgLy8gQSByZXNpemluZyBwYW5lbCBhZmZlY3RzIHRoZSBwYW5lbHMgYmVmb3JlIG9yIGFmdGVyIGl0LlxuICAvL1xuICAvLyBBIG5lZ2F0aXZlIGRlbHRhIG1lYW5zIHRoZSBwYW5lbCBpbW1lZGlhdGVseSBhZnRlciB0aGUgcmVzaXplciBzaG91bGQgZ3Jvdy9leHBhbmQgYnkgZGVjcmVhc2luZyBpdHMgb2Zmc2V0LlxuICAvLyBPdGhlciBwYW5lbHMgbWF5IGFsc28gbmVlZCB0byBzaHJpbmsvY29udHJhY3QgKGFuZCBzaGlmdCkgdG8gbWFrZSByb29tLCBkZXBlbmRpbmcgb24gdGhlIG1pbiB3ZWlnaHRzLlxuICAvL1xuICAvLyBBIHBvc2l0aXZlIGRlbHRhIG1lYW5zIHRoZSBwYW5lbCBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIHJlc2l6ZXIgc2hvdWxkIFwiZXhwYW5kXCIuXG4gIC8vIFRoaXMgaXMgYWNjb21wbGlzaGVkIGJ5IHNocmlua2luZy9jb250cmFjdGluZyAoYW5kIHNoaWZ0aW5nKSBvbmUgb3IgbW9yZSBvZiB0aGUgcGFuZWxzIGFmdGVyIHRoZSByZXNpemVyLlxuXG4gIC8vIE1heC1ib3VuZHMgY2hlY2sgdGhlIHBhbmVsIGJlaW5nIGV4cGFuZGVkIGZpcnN0LlxuICB7XG4gICAgY29uc3QgcGl2b3RJZCA9IGRlbHRhUGl4ZWxzIDwgMCA/IGlkQWZ0ZXIgOiBpZEJlZm9yZTtcbiAgICBjb25zdCBpbmRleCA9IHBhbmVsc0FycmF5LmZpbmRJbmRleChwYW5lbCA9PiBwYW5lbC5jdXJyZW50LmlkID09PSBwaXZvdElkKTtcbiAgICBjb25zdCBwYW5lbCA9IHBhbmVsc0FycmF5W2luZGV4XTtcbiAgICBjb25zdCBiYXNlU2l6ZSA9IGJhc2VTaXplc1tpbmRleF07XG4gICAgY29uc3QgbmV4dFNpemUgPSBzYWZlUmVzaXplUGFuZWwodW5pdHMsIGdyb3VwU2l6ZVBpeGVscywgcGFuZWwsIGJhc2VTaXplLCBiYXNlU2l6ZSArIE1hdGguYWJzKGRlbHRhUGl4ZWxzKSwgZXZlbnQpO1xuICAgIGlmIChiYXNlU2l6ZSA9PT0gbmV4dFNpemUpIHtcbiAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gcm9vbSBmb3IgdGhlIHBpdm90IHBhbmVsIHRvIGdyb3csIHdlIGNhbiBpZ25vcmUgdGhpcyBkcmFnIHVwZGF0ZS5cbiAgICAgIHJldHVybiBiYXNlU2l6ZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChuZXh0U2l6ZSA9PT0gMCAmJiBiYXNlU2l6ZSA+IDApIHtcbiAgICAgICAgcGFuZWxTaXplQmVmb3JlQ29sbGFwc2Uuc2V0KHBpdm90SWQsIGJhc2VTaXplKTtcbiAgICAgIH1cbiAgICAgIGRlbHRhUGl4ZWxzID0gZGVsdGFQaXhlbHMgPCAwID8gYmFzZVNpemUgLSBuZXh0U2l6ZSA6IG5leHRTaXplIC0gYmFzZVNpemU7XG4gICAgfVxuICB9XG4gIGxldCBwaXZvdElkID0gZGVsdGFQaXhlbHMgPCAwID8gaWRCZWZvcmUgOiBpZEFmdGVyO1xuICBsZXQgaW5kZXggPSBwYW5lbHNBcnJheS5maW5kSW5kZXgocGFuZWwgPT4gcGFuZWwuY3VycmVudC5pZCA9PT0gcGl2b3RJZCk7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgcGFuZWwgPSBwYW5lbHNBcnJheVtpbmRleF07XG4gICAgY29uc3QgYmFzZVNpemUgPSBiYXNlU2l6ZXNbaW5kZXhdO1xuICAgIGNvbnN0IGRlbHRhUmVtYWluaW5nID0gTWF0aC5hYnMoZGVsdGFQaXhlbHMpIC0gTWF0aC5hYnMoZGVsdGFBcHBsaWVkKTtcbiAgICBjb25zdCBuZXh0U2l6ZSA9IHNhZmVSZXNpemVQYW5lbCh1bml0cywgZ3JvdXBTaXplUGl4ZWxzLCBwYW5lbCwgYmFzZVNpemUsIGJhc2VTaXplIC0gZGVsdGFSZW1haW5pbmcsIGV2ZW50KTtcbiAgICBpZiAoYmFzZVNpemUgIT09IG5leHRTaXplKSB7XG4gICAgICBpZiAobmV4dFNpemUgPT09IDAgJiYgYmFzZVNpemUgPiAwKSB7XG4gICAgICAgIHBhbmVsU2l6ZUJlZm9yZUNvbGxhcHNlLnNldChwYW5lbC5jdXJyZW50LmlkLCBiYXNlU2l6ZSk7XG4gICAgICB9XG4gICAgICBkZWx0YUFwcGxpZWQgKz0gYmFzZVNpemUgLSBuZXh0U2l6ZTtcbiAgICAgIG5leHRTaXplc1tpbmRleF0gPSBuZXh0U2l6ZTtcbiAgICAgIGlmIChkZWx0YUFwcGxpZWQudG9QcmVjaXNpb24oUFJFQ0lTSU9OKS5sb2NhbGVDb21wYXJlKE1hdGguYWJzKGRlbHRhUGl4ZWxzKS50b1ByZWNpc2lvbihQUkVDSVNJT04pLCB1bmRlZmluZWQsIHtcbiAgICAgICAgbnVtZXJpYzogdHJ1ZVxuICAgICAgfSkgPj0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRlbHRhUGl4ZWxzIDwgMCkge1xuICAgICAgaWYgKC0taW5kZXggPCAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoKytpbmRleCA+PSBwYW5lbHNBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgd2Ugd2VyZSB1bmFibGUgdG8gcmVzaXplIGFueSBvZiB0aGUgcGFuZWxzIHBhbmVscywgcmV0dXJuIHRoZSBwcmV2aW91cyBzdGF0ZS5cbiAgLy8gVGhpcyB3aWxsIGVzc2VudGlhbGx5IGJhaWxvdXQgYW5kIGlnbm9yZSB0aGUgXCJtb3VzZW1vdmVcIiBldmVudC5cbiAgaWYgKGRlbHRhQXBwbGllZCA9PT0gMCkge1xuICAgIHJldHVybiBiYXNlU2l6ZXM7XG4gIH1cblxuICAvLyBBZGp1c3QgdGhlIHBpdm90IHBhbmVsIGJlZm9yZSwgYnV0IG9ubHkgYnkgdGhlIGFtb3VudCB0aGF0IHN1cnJvdW5kaW5nIHBhbmVscyB3ZXJlIGFibGUgdG8gc2hyaW5rL2NvbnRyYWN0LlxuICBwaXZvdElkID0gZGVsdGFQaXhlbHMgPCAwID8gaWRBZnRlciA6IGlkQmVmb3JlO1xuICBpbmRleCA9IHBhbmVsc0FycmF5LmZpbmRJbmRleChwYW5lbCA9PiBwYW5lbC5jdXJyZW50LmlkID09PSBwaXZvdElkKTtcbiAgbmV4dFNpemVzW2luZGV4XSA9IGJhc2VTaXplc1tpbmRleF0gKyBkZWx0YUFwcGxpZWQ7XG4gIHJldHVybiBuZXh0U2l6ZXM7XG59XG5mdW5jdGlvbiBjYWxsUGFuZWxDYWxsYmFja3MocGFuZWxzQXJyYXksIHNpemVzLCBwYW5lbElkVG9MYXN0Tm90aWZpZWRTaXplTWFwKSB7XG4gIHNpemVzLmZvckVhY2goKHNpemUsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgcGFuZWxSZWYgPSBwYW5lbHNBcnJheVtpbmRleF07XG4gICAgaWYgKCFwYW5lbFJlZikge1xuICAgICAgLy8gSGFuZGxlIGluaXRpYWwgbW91bnQgKHdoZW4gcGFuZWxzIGFyZSByZWdpc3RlcmVkIHRvbyBsYXRlIHRvIGJlIGluIHRoZSBwYW5lbHMgYXJyYXkpXG4gICAgICAvLyBUaGUgc3Vic2VxdWVudCByZW5kZXIrZWZmZWN0cyB3aWxsIGhhbmRsZSB0aGUgcmVzaXplIG5vdGlmaWNhdGlvblxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBjYWxsYmFja3NSZWYsXG4gICAgICBjb2xsYXBzZWRTaXplLFxuICAgICAgY29sbGFwc2libGUsXG4gICAgICBpZFxuICAgIH0gPSBwYW5lbFJlZi5jdXJyZW50O1xuICAgIGNvbnN0IGxhc3ROb3RpZmllZFNpemUgPSBwYW5lbElkVG9MYXN0Tm90aWZpZWRTaXplTWFwW2lkXTtcbiAgICBpZiAobGFzdE5vdGlmaWVkU2l6ZSAhPT0gc2l6ZSkge1xuICAgICAgcGFuZWxJZFRvTGFzdE5vdGlmaWVkU2l6ZU1hcFtpZF0gPSBzaXplO1xuICAgICAgY29uc3Qge1xuICAgICAgICBvbkNvbGxhcHNlLFxuICAgICAgICBvblJlc2l6ZVxuICAgICAgfSA9IGNhbGxiYWNrc1JlZi5jdXJyZW50O1xuICAgICAgaWYgKG9uUmVzaXplKSB7XG4gICAgICAgIG9uUmVzaXplKHNpemUsIGxhc3ROb3RpZmllZFNpemUpO1xuICAgICAgfVxuICAgICAgaWYgKGNvbGxhcHNpYmxlICYmIG9uQ29sbGFwc2UpIHtcbiAgICAgICAgaWYgKChsYXN0Tm90aWZpZWRTaXplID09IG51bGwgfHwgbGFzdE5vdGlmaWVkU2l6ZSA9PT0gY29sbGFwc2VkU2l6ZSkgJiYgc2l6ZSAhPT0gY29sbGFwc2VkU2l6ZSkge1xuICAgICAgICAgIG9uQ29sbGFwc2UoZmFsc2UpO1xuICAgICAgICB9IGVsc2UgaWYgKGxhc3ROb3RpZmllZFNpemUgIT09IGNvbGxhcHNlZFNpemUgJiYgc2l6ZSA9PT0gY29sbGFwc2VkU2l6ZSkge1xuICAgICAgICAgIG9uQ29sbGFwc2UodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0QmVmb3JlQW5kQWZ0ZXJJZHMoaWQsIHBhbmVsc0FycmF5KSB7XG4gIGlmIChwYW5lbHNBcnJheS5sZW5ndGggPCAyKSB7XG4gICAgcmV0dXJuIFtudWxsLCBudWxsXTtcbiAgfVxuICBjb25zdCBpbmRleCA9IHBhbmVsc0FycmF5LmZpbmRJbmRleChwYW5lbCA9PiBwYW5lbC5jdXJyZW50LmlkID09PSBpZCk7XG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICB9XG4gIGNvbnN0IGlzTGFzdFBhbmVsID0gaW5kZXggPT09IHBhbmVsc0FycmF5Lmxlbmd0aCAtIDE7XG4gIGNvbnN0IGlkQmVmb3JlID0gaXNMYXN0UGFuZWwgPyBwYW5lbHNBcnJheVtpbmRleCAtIDFdLmN1cnJlbnQuaWQgOiBpZDtcbiAgY29uc3QgaWRBZnRlciA9IGlzTGFzdFBhbmVsID8gaWQgOiBwYW5lbHNBcnJheVtpbmRleCArIDFdLmN1cnJlbnQuaWQ7XG4gIHJldHVybiBbaWRCZWZvcmUsIGlkQWZ0ZXJdO1xufVxuZnVuY3Rpb24gZ2V0QXZhaWxhYmxlR3JvdXBTaXplUGl4ZWxzKGdyb3VwSWQpIHtcbiAgY29uc3QgcGFuZWxHcm91cEVsZW1lbnQgPSBnZXRQYW5lbEdyb3VwKGdyb3VwSWQpO1xuICBpZiAocGFuZWxHcm91cEVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBOYU47XG4gIH1cbiAgY29uc3QgZGlyZWN0aW9uID0gcGFuZWxHcm91cEVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1wYW5lbC1ncm91cC1kaXJlY3Rpb25cIik7XG4gIGNvbnN0IHJlc2l6ZUhhbmRsZXMgPSBnZXRSZXNpemVIYW5kbGVzRm9yR3JvdXAoZ3JvdXBJZCk7XG4gIGlmIChkaXJlY3Rpb24gPT09IFwiaG9yaXpvbnRhbFwiKSB7XG4gICAgcmV0dXJuIHBhbmVsR3JvdXBFbGVtZW50Lm9mZnNldFdpZHRoIC0gcmVzaXplSGFuZGxlcy5yZWR1Y2UoKGFjY3VtdWxhdGVkLCBoYW5kbGUpID0+IHtcbiAgICAgIHJldHVybiBhY2N1bXVsYXRlZCArIGhhbmRsZS5vZmZzZXRXaWR0aDtcbiAgICB9LCAwKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcGFuZWxHcm91cEVsZW1lbnQub2Zmc2V0SGVpZ2h0IC0gcmVzaXplSGFuZGxlcy5yZWR1Y2UoKGFjY3VtdWxhdGVkLCBoYW5kbGUpID0+IHtcbiAgICAgIHJldHVybiBhY2N1bXVsYXRlZCArIGhhbmRsZS5vZmZzZXRIZWlnaHQ7XG4gICAgfSwgMCk7XG4gIH1cbn1cblxuLy8gVGhpcyBtZXRob2QgcmV0dXJucyBhIG51bWJlciBiZXR3ZWVuIDEgYW5kIDEwMCByZXByZXNlbnRpbmdcbi8vIHRoZSAlIG9mIHRoZSBncm91cCdzIG92ZXJhbGwgc3BhY2UgdGhpcyBwYW5lbCBzaG91bGQgb2NjdXB5LlxuZnVuY3Rpb24gZ2V0RmxleEdyb3cocGFuZWxzLCBpZCwgc2l6ZXMpIHtcbiAgaWYgKHBhbmVscy5zaXplID09PSAxKSB7XG4gICAgcmV0dXJuIFwiMTAwXCI7XG4gIH1cbiAgY29uc3QgcGFuZWxzQXJyYXkgPSBwYW5lbHNNYXBUb1NvcnRlZEFycmF5KHBhbmVscyk7XG4gIGNvbnN0IGluZGV4ID0gcGFuZWxzQXJyYXkuZmluZEluZGV4KHBhbmVsID0+IHBhbmVsLmN1cnJlbnQuaWQgPT09IGlkKTtcbiAgY29uc3Qgc2l6ZSA9IHNpemVzW2luZGV4XTtcbiAgaWYgKHNpemUgPT0gbnVsbCkge1xuICAgIHJldHVybiBcIjBcIjtcbiAgfVxuICByZXR1cm4gc2l6ZS50b1ByZWNpc2lvbihQUkVDSVNJT04pO1xufVxuZnVuY3Rpb24gZ2V0UGFuZWwoaWQpIHtcbiAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLXBhbmVsLWlkPVwiJHtpZH1cIl1gKTtcbiAgaWYgKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldFBhbmVsR3JvdXAoaWQpIHtcbiAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLXBhbmVsLWdyb3VwLWlkPVwiJHtpZH1cIl1gKTtcbiAgaWYgKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldFJlc2l6ZUhhbmRsZShpZCkge1xuICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgW2RhdGEtcGFuZWwtcmVzaXplLWhhbmRsZS1pZD1cIiR7aWR9XCJdYCk7XG4gIGlmIChlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRSZXNpemVIYW5kbGVJbmRleChpZCkge1xuICBjb25zdCBoYW5kbGVzID0gZ2V0UmVzaXplSGFuZGxlcygpO1xuICBjb25zdCBpbmRleCA9IGhhbmRsZXMuZmluZEluZGV4KGhhbmRsZSA9PiBoYW5kbGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1wYW5lbC1yZXNpemUtaGFuZGxlLWlkXCIpID09PSBpZCk7XG4gIHJldHVybiBpbmRleCA/PyBudWxsO1xufVxuZnVuY3Rpb24gZ2V0UmVzaXplSGFuZGxlcygpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChgW2RhdGEtcGFuZWwtcmVzaXplLWhhbmRsZS1pZF1gKSk7XG59XG5mdW5jdGlvbiBnZXRSZXNpemVIYW5kbGVzRm9yR3JvdXAoZ3JvdXBJZCkge1xuICByZXR1cm4gQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGBbZGF0YS1wYW5lbC1yZXNpemUtaGFuZGxlLWlkXVtkYXRhLXBhbmVsLWdyb3VwLWlkPVwiJHtncm91cElkfVwiXWApKTtcbn1cbmZ1bmN0aW9uIGdldFJlc2l6ZUhhbmRsZVBhbmVsSWRzKGdyb3VwSWQsIGhhbmRsZUlkLCBwYW5lbHNBcnJheSkge1xuICBjb25zdCBoYW5kbGUgPSBnZXRSZXNpemVIYW5kbGUoaGFuZGxlSWQpO1xuICBjb25zdCBoYW5kbGVzID0gZ2V0UmVzaXplSGFuZGxlc0Zvckdyb3VwKGdyb3VwSWQpO1xuICBjb25zdCBpbmRleCA9IGhhbmRsZSA/IGhhbmRsZXMuaW5kZXhPZihoYW5kbGUpIDogLTE7XG4gIGNvbnN0IGlkQmVmb3JlID0gcGFuZWxzQXJyYXlbaW5kZXhdPy5jdXJyZW50Py5pZCA/PyBudWxsO1xuICBjb25zdCBpZEFmdGVyID0gcGFuZWxzQXJyYXlbaW5kZXggKyAxXT8uY3VycmVudD8uaWQgPz8gbnVsbDtcbiAgcmV0dXJuIFtpZEJlZm9yZSwgaWRBZnRlcl07XG59XG5mdW5jdGlvbiBwYW5lbHNNYXBUb1NvcnRlZEFycmF5KHBhbmVscykge1xuICByZXR1cm4gQXJyYXkuZnJvbShwYW5lbHMudmFsdWVzKCkpLnNvcnQoKHBhbmVsQSwgcGFuZWxCKSA9PiB7XG4gICAgY29uc3Qgb3JkZXJBID0gcGFuZWxBLmN1cnJlbnQub3JkZXI7XG4gICAgY29uc3Qgb3JkZXJCID0gcGFuZWxCLmN1cnJlbnQub3JkZXI7XG4gICAgaWYgKG9yZGVyQSA9PSBudWxsICYmIG9yZGVyQiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2UgaWYgKG9yZGVyQSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfSBlbHNlIGlmIChvcmRlckIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBvcmRlckEgLSBvcmRlckI7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHNhZmVSZXNpemVQYW5lbCh1bml0cywgZ3JvdXBTaXplUGl4ZWxzLCBwYW5lbCwgcHJldlNpemUsIG5leHRTaXplLCBldmVudCA9IG51bGwpIHtcbiAgbGV0IHtcbiAgICBjb2xsYXBzZWRTaXplLFxuICAgIGNvbGxhcHNpYmxlLFxuICAgIG1heFNpemUsXG4gICAgbWluU2l6ZVxuICB9ID0gcGFuZWwuY3VycmVudDtcbiAgaWYgKHVuaXRzID09PSBcInBpeGVsc1wiKSB7XG4gICAgY29sbGFwc2VkU2l6ZSA9IGNvbGxhcHNlZFNpemUgLyBncm91cFNpemVQaXhlbHMgKiAxMDA7XG4gICAgaWYgKG1heFNpemUgIT0gbnVsbCkge1xuICAgICAgbWF4U2l6ZSA9IG1heFNpemUgLyBncm91cFNpemVQaXhlbHMgKiAxMDA7XG4gICAgfVxuICAgIG1pblNpemUgPSBtaW5TaXplIC8gZ3JvdXBTaXplUGl4ZWxzICogMTAwO1xuICB9XG4gIGlmIChjb2xsYXBzaWJsZSkge1xuICAgIGlmIChwcmV2U2l6ZSA+IGNvbGxhcHNlZFNpemUpIHtcbiAgICAgIC8vIE1pbWljIFZTIENPZGUgYmVoYXZpb3I7IGNvbGxhcHNlIGEgcGFuZWwgaWYgaXQncyBzbWFsbGVyIHRoYW4gaGFsZiBvZiBpdHMgbWluLXNpemVcbiAgICAgIGlmIChuZXh0U2l6ZSA8PSBtaW5TaXplIC8gMiArIGNvbGxhcHNlZFNpemUpIHtcbiAgICAgICAgcmV0dXJuIGNvbGxhcHNlZFNpemU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGlzS2V5Ym9hcmRFdmVudCA9IGV2ZW50Py50eXBlPy5zdGFydHNXaXRoKFwia2V5XCIpO1xuICAgICAgaWYgKCFpc0tleWJvYXJkRXZlbnQpIHtcbiAgICAgICAgLy8gS2V5Ym9hcmQgZXZlbnRzIHNob3VsZCBleHBhbmQgYSBjb2xsYXBzZWQgcGFuZWwgdG8gdGhlIG1pbiBzaXplLFxuICAgICAgICAvLyBidXQgbW91c2UgZXZlbnRzIHNob3VsZCB3YWl0IHVudGlsIHRoZSBwYW5lbCBoYXMgcmVhY2hlZCBpdHMgbWluIHNpemVcbiAgICAgICAgLy8gdG8gYXZvaWQgYSB2aXN1YWwgZmxpY2tlcmluZyB3aGVuIGRyYWdnaW5nIGJldHdlZW4gY29sbGFwc2VkIGFuZCBtaW4gc2l6ZS5cbiAgICAgICAgaWYgKG5leHRTaXplIDwgbWluU2l6ZSkge1xuICAgICAgICAgIHJldHVybiBjb2xsYXBzZWRTaXplO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBNYXRoLm1pbihtYXhTaXplICE9IG51bGwgPyBtYXhTaXplIDogMTAwLCBNYXRoLm1heChtaW5TaXplLCBuZXh0U2l6ZSkpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVQYW5lbFByb3BzKHVuaXRzLCBwYW5lbERhdGEpIHtcbiAgY29uc3Qge1xuICAgIGNvbGxhcHNpYmxlLFxuICAgIGRlZmF1bHRTaXplLFxuICAgIG1heFNpemUsXG4gICAgbWluU2l6ZVxuICB9ID0gcGFuZWxEYXRhLmN1cnJlbnQ7XG5cbiAgLy8gQmFzaWMgcHJvcHMgdmFsaWRhdGlvblxuICBpZiAobWluU2l6ZSA8IDAgfHwgdW5pdHMgPT09IFwicGVyY2VudGFnZXNcIiAmJiBtaW5TaXplID4gMTAwKSB7XG4gICAge1xuICAgICAgY29uc29sZS5lcnJvcihgSW52YWxpZCBQYW5lbCBtaW5TaXplIHByb3ZpZGVkLCAke21pblNpemV9YCk7XG4gICAgfVxuICAgIHBhbmVsRGF0YS5jdXJyZW50Lm1pblNpemUgPSAwO1xuICB9XG4gIGlmIChtYXhTaXplICE9IG51bGwpIHtcbiAgICBpZiAobWF4U2l6ZSA8IDAgfHwgdW5pdHMgPT09IFwicGVyY2VudGFnZXNcIiAmJiBtYXhTaXplID4gMTAwKSB7XG4gICAgICB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEludmFsaWQgUGFuZWwgbWF4U2l6ZSBwcm92aWRlZCwgJHttYXhTaXplfWApO1xuICAgICAgfVxuICAgICAgcGFuZWxEYXRhLmN1cnJlbnQubWF4U2l6ZSA9IG51bGw7XG4gICAgfVxuICB9XG4gIGlmIChkZWZhdWx0U2l6ZSAhPT0gbnVsbCkge1xuICAgIGlmIChkZWZhdWx0U2l6ZSA8IDAgfHwgdW5pdHMgPT09IFwicGVyY2VudGFnZXNcIiAmJiBkZWZhdWx0U2l6ZSA+IDEwMCkge1xuICAgICAge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBJbnZhbGlkIFBhbmVsIGRlZmF1bHRTaXplIHByb3ZpZGVkLCAke2RlZmF1bHRTaXplfWApO1xuICAgICAgfVxuICAgICAgcGFuZWxEYXRhLmN1cnJlbnQuZGVmYXVsdFNpemUgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAoZGVmYXVsdFNpemUgPCBtaW5TaXplICYmICFjb2xsYXBzaWJsZSkge1xuICAgICAge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBQYW5lbCBtaW5TaXplICgke21pblNpemV9KSBjYW5ub3QgYmUgZ3JlYXRlciB0aGFuIGRlZmF1bHRTaXplICgke2RlZmF1bHRTaXplfSlgKTtcbiAgICAgIH1cbiAgICAgIHBhbmVsRGF0YS5jdXJyZW50LmRlZmF1bHRTaXplID0gbWluU2l6ZTtcbiAgICB9IGVsc2UgaWYgKG1heFNpemUgIT0gbnVsbCAmJiBkZWZhdWx0U2l6ZSA+IG1heFNpemUpIHtcbiAgICAgIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgUGFuZWwgbWF4U2l6ZSAoJHttYXhTaXplfSkgY2Fubm90IGJlIGxlc3MgdGhhbiBkZWZhdWx0U2l6ZSAoJHtkZWZhdWx0U2l6ZX0pYCk7XG4gICAgICB9XG4gICAgICBwYW5lbERhdGEuY3VycmVudC5kZWZhdWx0U2l6ZSA9IG1heFNpemU7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVBhbmVsR3JvdXBMYXlvdXQoe1xuICBncm91cElkLFxuICBwYW5lbHMsXG4gIG5leHRTaXplcyxcbiAgcHJldlNpemVzLFxuICB1bml0c1xufSkge1xuICAvLyBDbG9uZSBiZWNhdXNlIHRoaXMgbWV0aG9kIG1vZGlmaWVzXG4gIG5leHRTaXplcyA9IFsuLi5uZXh0U2l6ZXNdO1xuICBjb25zdCBwYW5lbHNBcnJheSA9IHBhbmVsc01hcFRvU29ydGVkQXJyYXkocGFuZWxzKTtcbiAgY29uc3QgZ3JvdXBTaXplUGl4ZWxzID0gdW5pdHMgPT09IFwicGl4ZWxzXCIgPyBnZXRBdmFpbGFibGVHcm91cFNpemVQaXhlbHMoZ3JvdXBJZCkgOiBOYU47XG4gIGxldCByZW1haW5pbmdTaXplID0gMDtcblxuICAvLyBGaXJzdCwgY2hlY2sgYWxsIG9mIHRoZSBwcm9wb3NlZCBzaXplcyBhZ2FpbnN0IHRoZSBtaW4vbWF4IGNvbnN0cmFpbnRzXG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBwYW5lbHNBcnJheS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBjb25zdCBwYW5lbCA9IHBhbmVsc0FycmF5W2luZGV4XTtcbiAgICBjb25zdCBwcmV2U2l6ZSA9IHByZXZTaXplc1tpbmRleF07XG4gICAgY29uc3QgbmV4dFNpemUgPSBuZXh0U2l6ZXNbaW5kZXhdO1xuICAgIGNvbnN0IHNhZmVOZXh0U2l6ZSA9IHNhZmVSZXNpemVQYW5lbCh1bml0cywgZ3JvdXBTaXplUGl4ZWxzLCBwYW5lbCwgcHJldlNpemUsIG5leHRTaXplKTtcbiAgICBpZiAobmV4dFNpemUgIT0gc2FmZU5leHRTaXplKSB7XG4gICAgICByZW1haW5pbmdTaXplICs9IG5leHRTaXplIC0gc2FmZU5leHRTaXplO1xuICAgICAgbmV4dFNpemVzW2luZGV4XSA9IHNhZmVOZXh0U2l6ZTtcbiAgICAgIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgSW52YWxpZCBzaXplICgke25leHRTaXplfSkgc3BlY2lmaWVkIGZvciBQYW5lbCBcIiR7cGFuZWwuY3VycmVudC5pZH1cIiBnaXZlbiB0aGUgcGFuZWwncyBtaW4vbWF4IHNpemUgY29uc3RyYWludHNgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBJZiB0aGVyZSBpcyBhZGRpdGlvbmFsLCBsZWZ0IG92ZXIgc3BhY2UsIGFzc2lnbiBpdCB0byBhbnkgcGFuZWwocykgdGhhdCBwZXJtaXRzIGl0XG4gIC8vIChJdCdzIG5vdCB3b3J0aCB0YWtpbmcgbXVsdGlwbGUgYWRkaXRpb25hbCBwYXNzZXMgdG8gZXZlbmx5IGRpc3RyaWJ1dGUpXG4gIGlmIChyZW1haW5pbmdTaXplLnRvRml4ZWQoMykgIT09IFwiMC4wMDBcIikge1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBwYW5lbHNBcnJheS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGNvbnN0IHBhbmVsID0gcGFuZWxzQXJyYXlbaW5kZXhdO1xuICAgICAgbGV0IHtcbiAgICAgICAgbWF4U2l6ZSxcbiAgICAgICAgbWluU2l6ZVxuICAgICAgfSA9IHBhbmVsLmN1cnJlbnQ7XG4gICAgICBpZiAodW5pdHMgPT09IFwicGl4ZWxzXCIpIHtcbiAgICAgICAgbWluU2l6ZSA9IG1pblNpemUgLyBncm91cFNpemVQaXhlbHMgKiAxMDA7XG4gICAgICAgIGlmIChtYXhTaXplICE9IG51bGwpIHtcbiAgICAgICAgICBtYXhTaXplID0gbWF4U2l6ZSAvIGdyb3VwU2l6ZVBpeGVscyAqIDEwMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qgc2l6ZSA9IE1hdGgubWluKG1heFNpemUgIT0gbnVsbCA/IG1heFNpemUgOiAxMDAsIE1hdGgubWF4KG1pblNpemUsIG5leHRTaXplc1tpbmRleF0gKyByZW1haW5pbmdTaXplKSk7XG4gICAgICBpZiAoc2l6ZSAhPT0gbmV4dFNpemVzW2luZGV4XSkge1xuICAgICAgICByZW1haW5pbmdTaXplIC09IHNpemUgLSBuZXh0U2l6ZXNbaW5kZXhdO1xuICAgICAgICBuZXh0U2l6ZXNbaW5kZXhdID0gc2l6ZTtcblxuICAgICAgICAvLyBGdXp6eSBjb21wYXJpc29uIHRvIGFjY291bnQgZm9yIGltcHJlY2lzZSBmbG9hdGluZyBwb2ludCBtYXRoXG4gICAgICAgIGlmIChNYXRoLmFicyhyZW1haW5pbmdTaXplKS50b0ZpeGVkKDMpID09PSBcIjAuMDAwXCIpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIElmIHdlIHN0aWxsIGhhdmUgcmVtYWluZGVyLCB0aGUgcmVxdWVzdGVkIGxheW91dCB3YXNuJ3QgdmFsaWQgYW5kIHdlIHNob3VsZCB3YXJuIGFib3V0IGl0XG4gIGlmIChyZW1haW5pbmdTaXplLnRvRml4ZWQoMykgIT09IFwiMC4wMDBcIikge1xuICAgIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFwiSW52YWxpZCBwYW5lbCBncm91cCBjb25maWd1cmF0aW9uOyBkZWZhdWx0IHBhbmVsIHNpemVzIHNob3VsZCB0b3RhbCAxMDAlIGJ1dCB3YXMgJHsxMDAgLSByZW1haW5pbmdTaXplfSVgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5leHRTaXplcztcbn1cblxuZnVuY3Rpb24gYXNzZXJ0KGV4cGVjdGVkQ29uZGl0aW9uLCBtZXNzYWdlID0gXCJBc3NlcnRpb24gZmFpbGVkIVwiKSB7XG4gIGlmICghZXhwZWN0ZWRDb25kaXRpb24pIHtcbiAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIHRocm93IEVycm9yKG1lc3NhZ2UpO1xuICB9XG59XG5cbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9XQUkvQVJJQS9hcGcvcGF0dGVybnMvd2luZG93c3BsaXR0ZXIvXG5cbmZ1bmN0aW9uIHVzZVdpbmRvd1NwbGl0dGVyUGFuZWxHcm91cEJlaGF2aW9yKHtcbiAgY29tbWl0dGVkVmFsdWVzUmVmLFxuICBncm91cElkLFxuICBwYW5lbHMsXG4gIHNldFNpemVzLFxuICBzaXplcyxcbiAgcGFuZWxTaXplQmVmb3JlQ29sbGFwc2Vcbn0pIHtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBkaXJlY3Rpb24sXG4gICAgICBwYW5lbHNcbiAgICB9ID0gY29tbWl0dGVkVmFsdWVzUmVmLmN1cnJlbnQ7XG4gICAgY29uc3QgZ3JvdXBFbGVtZW50ID0gZ2V0UGFuZWxHcm91cChncm91cElkKTtcbiAgICBhc3NlcnQoZ3JvdXBFbGVtZW50ICE9IG51bGwsIGBObyBncm91cCBmb3VuZCBmb3IgaWQgXCIke2dyb3VwSWR9XCJgKTtcbiAgICBjb25zdCB7XG4gICAgICBoZWlnaHQsXG4gICAgICB3aWR0aFxuICAgIH0gPSBncm91cEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgaGFuZGxlcyA9IGdldFJlc2l6ZUhhbmRsZXNGb3JHcm91cChncm91cElkKTtcbiAgICBjb25zdCBjbGVhbnVwRnVuY3Rpb25zID0gaGFuZGxlcy5tYXAoaGFuZGxlID0+IHtcbiAgICAgIGNvbnN0IGhhbmRsZUlkID0gaGFuZGxlLmdldEF0dHJpYnV0ZShcImRhdGEtcGFuZWwtcmVzaXplLWhhbmRsZS1pZFwiKTtcbiAgICAgIGNvbnN0IHBhbmVsc0FycmF5ID0gcGFuZWxzTWFwVG9Tb3J0ZWRBcnJheShwYW5lbHMpO1xuICAgICAgY29uc3QgW2lkQmVmb3JlLCBpZEFmdGVyXSA9IGdldFJlc2l6ZUhhbmRsZVBhbmVsSWRzKGdyb3VwSWQsIGhhbmRsZUlkLCBwYW5lbHNBcnJheSk7XG4gICAgICBpZiAoaWRCZWZvcmUgPT0gbnVsbCB8fCBpZEFmdGVyID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICgpID0+IHt9O1xuICAgICAgfVxuICAgICAgbGV0IGN1cnJlbnRNaW5TaXplID0gMDtcbiAgICAgIGxldCBjdXJyZW50TWF4U2l6ZSA9IDEwMDtcbiAgICAgIGxldCB0b3RhbE1pblNpemUgPSAwO1xuICAgICAgbGV0IHRvdGFsTWF4U2l6ZSA9IDA7XG5cbiAgICAgIC8vIEEgcGFuZWwncyBlZmZlY3RpdmUgbWluL21heCBzaXplcyBhbHNvIG5lZWQgdG8gYWNjb3VudCBmb3Igb3RoZXIgcGFuZWwncyBzaXplcy5cbiAgICAgIHBhbmVsc0FycmF5LmZvckVhY2gocGFuZWxEYXRhID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGlkLFxuICAgICAgICAgIG1heFNpemUsXG4gICAgICAgICAgbWluU2l6ZVxuICAgICAgICB9ID0gcGFuZWxEYXRhLmN1cnJlbnQ7XG4gICAgICAgIGlmIChpZCA9PT0gaWRCZWZvcmUpIHtcbiAgICAgICAgICBjdXJyZW50TWluU2l6ZSA9IG1pblNpemU7XG4gICAgICAgICAgY3VycmVudE1heFNpemUgPSBtYXhTaXplICE9IG51bGwgPyBtYXhTaXplIDogMTAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRvdGFsTWluU2l6ZSArPSBtaW5TaXplO1xuICAgICAgICAgIHRvdGFsTWF4U2l6ZSArPSBtYXhTaXplICE9IG51bGwgPyBtYXhTaXplIDogMTAwO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGFyaWFWYWx1ZU1heCA9IE1hdGgubWluKGN1cnJlbnRNYXhTaXplLCAxMDAgLSB0b3RhbE1pblNpemUpO1xuICAgICAgY29uc3QgYXJpYVZhbHVlTWluID0gTWF0aC5tYXgoY3VycmVudE1pblNpemUsIChwYW5lbHNBcnJheS5sZW5ndGggLSAxKSAqIDEwMCAtIHRvdGFsTWF4U2l6ZSk7XG4gICAgICBjb25zdCBmbGV4R3JvdyA9IGdldEZsZXhHcm93KHBhbmVscywgaWRCZWZvcmUsIHNpemVzKTtcbiAgICAgIGhhbmRsZS5zZXRBdHRyaWJ1dGUoXCJhcmlhLXZhbHVlbWF4XCIsIFwiXCIgKyBNYXRoLnJvdW5kKGFyaWFWYWx1ZU1heCkpO1xuICAgICAgaGFuZGxlLnNldEF0dHJpYnV0ZShcImFyaWEtdmFsdWVtaW5cIiwgXCJcIiArIE1hdGgucm91bmQoYXJpYVZhbHVlTWluKSk7XG4gICAgICBoYW5kbGUuc2V0QXR0cmlidXRlKFwiYXJpYS12YWx1ZW5vd1wiLCBcIlwiICsgTWF0aC5yb3VuZChwYXJzZUludChmbGV4R3JvdykpKTtcbiAgICAgIGNvbnN0IG9uS2V5RG93biA9IGV2ZW50ID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChldmVudC5rZXkpIHtcbiAgICAgICAgICBjYXNlIFwiRW50ZXJcIjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBwYW5lbHNBcnJheS5maW5kSW5kZXgocGFuZWwgPT4gcGFuZWwuY3VycmVudC5pZCA9PT0gaWRCZWZvcmUpO1xuICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhbmVsRGF0YSA9IHBhbmVsc0FycmF5W2luZGV4XTtcbiAgICAgICAgICAgICAgICBjb25zdCBzaXplID0gc2l6ZXNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmIChzaXplICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGxldCBkZWx0YSA9IDA7XG4gICAgICAgICAgICAgICAgICBpZiAoc2l6ZS50b1ByZWNpc2lvbihQUkVDSVNJT04pIDw9IHBhbmVsRGF0YS5jdXJyZW50Lm1pblNpemUudG9QcmVjaXNpb24oUFJFQ0lTSU9OKSkge1xuICAgICAgICAgICAgICAgICAgICBkZWx0YSA9IGRpcmVjdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgPyB3aWR0aCA6IGhlaWdodDtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbHRhID0gLShkaXJlY3Rpb24gPT09IFwiaG9yaXpvbnRhbFwiID8gd2lkdGggOiBoZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dFNpemVzID0gYWRqdXN0QnlEZWx0YShldmVudCwgY29tbWl0dGVkVmFsdWVzUmVmLmN1cnJlbnQsIGlkQmVmb3JlLCBpZEFmdGVyLCBkZWx0YSwgc2l6ZXMsIHBhbmVsU2l6ZUJlZm9yZUNvbGxhcHNlLmN1cnJlbnQsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgaWYgKHNpemVzICE9PSBuZXh0U2l6ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0U2l6ZXMobmV4dFNpemVzKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBoYW5kbGUuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgb25LZXlEb3duKTtcbiAgICAgIGNvbnN0IHBhbmVsQmVmb3JlID0gZ2V0UGFuZWwoaWRCZWZvcmUpO1xuICAgICAgaWYgKHBhbmVsQmVmb3JlICE9IG51bGwpIHtcbiAgICAgICAgaGFuZGxlLnNldEF0dHJpYnV0ZShcImFyaWEtY29udHJvbHNcIiwgcGFuZWxCZWZvcmUuaWQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaGFuZGxlLnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtdmFsdWVtYXhcIik7XG4gICAgICAgIGhhbmRsZS5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLXZhbHVlbWluXCIpO1xuICAgICAgICBoYW5kbGUucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS12YWx1ZW5vd1wiKTtcbiAgICAgICAgaGFuZGxlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIG9uS2V5RG93bik7XG4gICAgICAgIGlmIChwYW5lbEJlZm9yZSAhPSBudWxsKSB7XG4gICAgICAgICAgaGFuZGxlLnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtY29udHJvbHNcIik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNsZWFudXBGdW5jdGlvbnMuZm9yRWFjaChjbGVhbnVwRnVuY3Rpb24gPT4gY2xlYW51cEZ1bmN0aW9uKCkpO1xuICAgIH07XG4gIH0sIFtjb21taXR0ZWRWYWx1ZXNSZWYsIGdyb3VwSWQsIHBhbmVscywgcGFuZWxTaXplQmVmb3JlQ29sbGFwc2UsIHNldFNpemVzLCBzaXplc10pO1xufVxuZnVuY3Rpb24gdXNlV2luZG93U3BsaXR0ZXJSZXNpemVIYW5kbGVyQmVoYXZpb3Ioe1xuICBkaXNhYmxlZCxcbiAgaGFuZGxlSWQsXG4gIHJlc2l6ZUhhbmRsZXJcbn0pIHtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQgfHwgcmVzaXplSGFuZGxlciA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGhhbmRsZUVsZW1lbnQgPSBnZXRSZXNpemVIYW5kbGUoaGFuZGxlSWQpO1xuICAgIGlmIChoYW5kbGVFbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgb25LZXlEb3duID0gZXZlbnQgPT4ge1xuICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChldmVudC5rZXkpIHtcbiAgICAgICAgY2FzZSBcIkFycm93RG93blwiOlxuICAgICAgICBjYXNlIFwiQXJyb3dMZWZ0XCI6XG4gICAgICAgIGNhc2UgXCJBcnJvd1JpZ2h0XCI6XG4gICAgICAgIGNhc2UgXCJBcnJvd1VwXCI6XG4gICAgICAgIGNhc2UgXCJFbmRcIjpcbiAgICAgICAgY2FzZSBcIkhvbWVcIjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmVzaXplSGFuZGxlcihldmVudCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJGNlwiOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVzID0gZ2V0UmVzaXplSGFuZGxlcygpO1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBnZXRSZXNpemVIYW5kbGVJbmRleChoYW5kbGVJZCk7XG4gICAgICAgICAgICBhc3NlcnQoaW5kZXggIT09IG51bGwpO1xuICAgICAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gZXZlbnQuc2hpZnRLZXkgPyBpbmRleCA+IDAgPyBpbmRleCAtIDEgOiBoYW5kbGVzLmxlbmd0aCAtIDEgOiBpbmRleCArIDEgPCBoYW5kbGVzLmxlbmd0aCA/IGluZGV4ICsgMSA6IDA7XG4gICAgICAgICAgICBjb25zdCBuZXh0SGFuZGxlID0gaGFuZGxlc1tuZXh0SW5kZXhdO1xuICAgICAgICAgICAgbmV4dEhhbmRsZS5mb2N1cygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgaGFuZGxlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBvbktleURvd24pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBoYW5kbGVFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIG9uS2V5RG93bik7XG4gICAgfTtcbiAgfSwgW2Rpc2FibGVkLCBoYW5kbGVJZCwgcmVzaXplSGFuZGxlcl0pO1xufVxuXG5mdW5jdGlvbiBhcmVFcXVhbChhcnJheUEsIGFycmF5Qikge1xuICBpZiAoYXJyYXlBLmxlbmd0aCAhPT0gYXJyYXlCLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgYXJyYXlBLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGlmIChhcnJheUFbaW5kZXhdICE9PSBhcnJheUJbaW5kZXhdKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBnZXREcmFnT2Zmc2V0KGV2ZW50LCBoYW5kbGVJZCwgZGlyZWN0aW9uLCBpbml0aWFsT2Zmc2V0ID0gMCwgaW5pdGlhbEhhbmRsZUVsZW1lbnRSZWN0ID0gbnVsbCkge1xuICBjb25zdCBpc0hvcml6b250YWwgPSBkaXJlY3Rpb24gPT09IFwiaG9yaXpvbnRhbFwiO1xuICBsZXQgcG9pbnRlck9mZnNldCA9IDA7XG4gIGlmIChpc01vdXNlRXZlbnQoZXZlbnQpKSB7XG4gICAgcG9pbnRlck9mZnNldCA9IGlzSG9yaXpvbnRhbCA/IGV2ZW50LmNsaWVudFggOiBldmVudC5jbGllbnRZO1xuICB9IGVsc2UgaWYgKGlzVG91Y2hFdmVudChldmVudCkpIHtcbiAgICBjb25zdCBmaXJzdFRvdWNoID0gZXZlbnQudG91Y2hlc1swXTtcbiAgICBwb2ludGVyT2Zmc2V0ID0gaXNIb3Jpem9udGFsID8gZmlyc3RUb3VjaC5zY3JlZW5YIDogZmlyc3RUb3VjaC5zY3JlZW5ZO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGNvbnN0IGhhbmRsZUVsZW1lbnQgPSBnZXRSZXNpemVIYW5kbGUoaGFuZGxlSWQpO1xuICBjb25zdCByZWN0ID0gaW5pdGlhbEhhbmRsZUVsZW1lbnRSZWN0IHx8IGhhbmRsZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IGVsZW1lbnRPZmZzZXQgPSBpc0hvcml6b250YWwgPyByZWN0LmxlZnQgOiByZWN0LnRvcDtcbiAgcmV0dXJuIHBvaW50ZXJPZmZzZXQgLSBlbGVtZW50T2Zmc2V0IC0gaW5pdGlhbE9mZnNldDtcbn1cblxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01vdXNlRXZlbnQvbW92ZW1lbnRYXG5mdW5jdGlvbiBnZXRNb3ZlbWVudChldmVudCwgZ3JvdXBJZCwgaGFuZGxlSWQsIHBhbmVsc0FycmF5LCBkaXJlY3Rpb24sIHByZXZTaXplcywgaW5pdGlhbERyYWdTdGF0ZSkge1xuICBjb25zdCB7XG4gICAgZHJhZ09mZnNldCA9IDAsXG4gICAgZHJhZ0hhbmRsZVJlY3QsXG4gICAgc2l6ZXM6IGluaXRpYWxTaXplc1xuICB9ID0gaW5pdGlhbERyYWdTdGF0ZSB8fCB7fTtcblxuICAvLyBJZiB3ZSdyZSByZXNpemluZyBieSBtb3VzZSBvciB0b3VjaCwgdXNlIHRoZSBpbml0aWFsIHNpemVzIGFzIGEgYmFzZS5cbiAgLy8gVGhpcyBoYXMgdGhlIGJlbmVmaXQgb2YgY2F1c2luZyBmb3JjZS1jb2xsYXBzZWQgcGFuZWxzIHRvIHNwcmluZyBiYWNrIG9wZW4gaWYgZHJhZyBpcyByZXZlcnNlZC5cbiAgY29uc3QgYmFzZVNpemVzID0gaW5pdGlhbFNpemVzIHx8IHByZXZTaXplcztcbiAgaWYgKGlzS2V5RG93bihldmVudCkpIHtcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSBkaXJlY3Rpb24gPT09IFwiaG9yaXpvbnRhbFwiO1xuICAgIGNvbnN0IGdyb3VwRWxlbWVudCA9IGdldFBhbmVsR3JvdXAoZ3JvdXBJZCk7XG4gICAgY29uc3QgcmVjdCA9IGdyb3VwRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBncm91cFNpemVJblBpeGVscyA9IGlzSG9yaXpvbnRhbCA/IHJlY3Qud2lkdGggOiByZWN0LmhlaWdodDtcbiAgICBjb25zdCBkZW5vbWluYXRvciA9IGV2ZW50LnNoaWZ0S2V5ID8gMTAgOiAxMDA7XG4gICAgY29uc3QgZGVsdGEgPSBncm91cFNpemVJblBpeGVscyAvIGRlbm9taW5hdG9yO1xuICAgIGxldCBtb3ZlbWVudCA9IDA7XG4gICAgc3dpdGNoIChldmVudC5rZXkpIHtcbiAgICAgIGNhc2UgXCJBcnJvd0Rvd25cIjpcbiAgICAgICAgbW92ZW1lbnQgPSBpc0hvcml6b250YWwgPyAwIDogZGVsdGE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkFycm93TGVmdFwiOlxuICAgICAgICBtb3ZlbWVudCA9IGlzSG9yaXpvbnRhbCA/IC1kZWx0YSA6IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkFycm93UmlnaHRcIjpcbiAgICAgICAgbW92ZW1lbnQgPSBpc0hvcml6b250YWwgPyBkZWx0YSA6IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkFycm93VXBcIjpcbiAgICAgICAgbW92ZW1lbnQgPSBpc0hvcml6b250YWwgPyAwIDogLWRlbHRhO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJFbmRcIjpcbiAgICAgICAgbW92ZW1lbnQgPSBncm91cFNpemVJblBpeGVscztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiSG9tZVwiOlxuICAgICAgICBtb3ZlbWVudCA9IC1ncm91cFNpemVJblBpeGVscztcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIFBhbmVsIGJlaW5nIHJlc2l6ZWQgaXMgY29sbGFwc2libGUsXG4gICAgLy8gd2UgbmVlZCB0byBzcGVjaWFsIGNhc2UgcmVzaXppbmcgYXJvdW5kIHRoZSBtaW5TaXplIGJvdW5kYXJ5LlxuICAgIC8vIElmIGNvbnRyYWN0aW5nLCBQYW5lbHMgc2hvdWxkIHNocmluayB0byB0aGVpciBtaW5TaXplIGFuZCB0aGVuIHNuYXAgdG8gZnVsbHkgY29sbGFwc2VkLlxuICAgIC8vIElmIGV4cGFuZGluZyBmcm9tIGNvbGxhcHNlZCwgdGhleSBzaG91bGQgc25hcCBiYWNrIHRvIHRoZWlyIG1pblNpemUuXG4gICAgY29uc3QgW2lkQmVmb3JlLCBpZEFmdGVyXSA9IGdldFJlc2l6ZUhhbmRsZVBhbmVsSWRzKGdyb3VwSWQsIGhhbmRsZUlkLCBwYW5lbHNBcnJheSk7XG4gICAgY29uc3QgdGFyZ2V0UGFuZWxJZCA9IG1vdmVtZW50IDwgMCA/IGlkQmVmb3JlIDogaWRBZnRlcjtcbiAgICBjb25zdCB0YXJnZXRQYW5lbEluZGV4ID0gcGFuZWxzQXJyYXkuZmluZEluZGV4KHBhbmVsID0+IHBhbmVsLmN1cnJlbnQuaWQgPT09IHRhcmdldFBhbmVsSWQpO1xuICAgIGNvbnN0IHRhcmdldFBhbmVsID0gcGFuZWxzQXJyYXlbdGFyZ2V0UGFuZWxJbmRleF07XG4gICAgaWYgKHRhcmdldFBhbmVsLmN1cnJlbnQuY29sbGFwc2libGUpIHtcbiAgICAgIGNvbnN0IGJhc2VTaXplID0gYmFzZVNpemVzW3RhcmdldFBhbmVsSW5kZXhdO1xuICAgICAgaWYgKGJhc2VTaXplID09PSAwIHx8IGJhc2VTaXplLnRvUHJlY2lzaW9uKFBSRUNJU0lPTikgPT09IHRhcmdldFBhbmVsLmN1cnJlbnQubWluU2l6ZS50b1ByZWNpc2lvbihQUkVDSVNJT04pKSB7XG4gICAgICAgIG1vdmVtZW50ID0gbW92ZW1lbnQgPCAwID8gLXRhcmdldFBhbmVsLmN1cnJlbnQubWluU2l6ZSAqIGdyb3VwU2l6ZUluUGl4ZWxzIDogdGFyZ2V0UGFuZWwuY3VycmVudC5taW5TaXplICogZ3JvdXBTaXplSW5QaXhlbHM7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtb3ZlbWVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2V0RHJhZ09mZnNldChldmVudCwgaGFuZGxlSWQsIGRpcmVjdGlvbiwgZHJhZ09mZnNldCwgZHJhZ0hhbmRsZVJlY3QpO1xuICB9XG59XG5mdW5jdGlvbiBpc0tleURvd24oZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50LnR5cGUgPT09IFwia2V5ZG93blwiO1xufVxuZnVuY3Rpb24gaXNNb3VzZUV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBldmVudC50eXBlLnN0YXJ0c1dpdGgoXCJtb3VzZVwiKTtcbn1cbmZ1bmN0aW9uIGlzVG91Y2hFdmVudChldmVudCkge1xuICByZXR1cm4gZXZlbnQudHlwZS5zdGFydHNXaXRoKFwidG91Y2hcIik7XG59XG5cbmxldCBjdXJyZW50U3RhdGUgPSBudWxsO1xubGV0IGVsZW1lbnQgPSBudWxsO1xuZnVuY3Rpb24gZ2V0Q3Vyc29yU3R5bGUoc3RhdGUpIHtcbiAgc3dpdGNoIChzdGF0ZSkge1xuICAgIGNhc2UgXCJob3Jpem9udGFsXCI6XG4gICAgICByZXR1cm4gXCJldy1yZXNpemVcIjtcbiAgICBjYXNlIFwiaG9yaXpvbnRhbC1tYXhcIjpcbiAgICAgIHJldHVybiBcInctcmVzaXplXCI7XG4gICAgY2FzZSBcImhvcml6b250YWwtbWluXCI6XG4gICAgICByZXR1cm4gXCJlLXJlc2l6ZVwiO1xuICAgIGNhc2UgXCJ2ZXJ0aWNhbFwiOlxuICAgICAgcmV0dXJuIFwibnMtcmVzaXplXCI7XG4gICAgY2FzZSBcInZlcnRpY2FsLW1heFwiOlxuICAgICAgcmV0dXJuIFwibi1yZXNpemVcIjtcbiAgICBjYXNlIFwidmVydGljYWwtbWluXCI6XG4gICAgICByZXR1cm4gXCJzLXJlc2l6ZVwiO1xuICB9XG59XG5mdW5jdGlvbiByZXNldEdsb2JhbEN1cnNvclN0eWxlKCkge1xuICBpZiAoZWxlbWVudCAhPT0gbnVsbCkge1xuICAgIGRvY3VtZW50LmhlYWQucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gICAgY3VycmVudFN0YXRlID0gbnVsbDtcbiAgICBlbGVtZW50ID0gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gc2V0R2xvYmFsQ3Vyc29yU3R5bGUoc3RhdGUpIHtcbiAgaWYgKGN1cnJlbnRTdGF0ZSA9PT0gc3RhdGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY3VycmVudFN0YXRlID0gc3RhdGU7XG4gIGNvbnN0IHN0eWxlID0gZ2V0Q3Vyc29yU3R5bGUoc3RhdGUpO1xuICBpZiAoZWxlbWVudCA9PT0gbnVsbCkge1xuICAgIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgfVxuICBlbGVtZW50LmlubmVySFRNTCA9IGAqe2N1cnNvcjogJHtzdHlsZX0haW1wb3J0YW50O31gO1xufVxuXG5mdW5jdGlvbiBkZWJvdW5jZShjYWxsYmFjaywgZHVyYXRpb25NcyA9IDEwKSB7XG4gIGxldCB0aW1lb3V0SWQgPSBudWxsO1xuICBsZXQgY2FsbGFibGUgPSAoLi4uYXJncykgPT4ge1xuICAgIGlmICh0aW1lb3V0SWQgIT09IG51bGwpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgIH1cbiAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGNhbGxiYWNrKC4uLmFyZ3MpO1xuICAgIH0sIGR1cmF0aW9uTXMpO1xuICB9O1xuICByZXR1cm4gY2FsbGFibGU7XG59XG5cbi8vIE5vdGUgdGhhdCBQYW5lbCBpZHMgbWlnaHQgYmUgdXNlci1wcm92aWRlZCAoc3RhYmxlKSBvciB1c2VJZCBnZW5lcmF0ZWQgKG5vbi1kZXRlcm1pbmlzdGljKVxuLy8gc28gdGhleSBzaG91bGQgbm90IGJlIHVzZWQgYXMgcGFydCBvZiB0aGUgc2VyaWFsaXphdGlvbiBrZXkuXG4vLyBVc2luZyBhbiBhdHRyaWJ1dGUgbGlrZSBtaW5TaXplIGluc3RlYWQgc2hvdWxkIHdvcmsgd2VsbCBlbm91Z2guXG4vLyBQcmUtc29ydGluZyBieSBtaW5TaXplIGFsbG93cyByZW1lbWJlcmluZyBsYXlvdXRzIGV2ZW4gaWYgcGFuZWxzIGFyZSByZS1vcmRlcmVkL2RyYWdnZWQuXG5mdW5jdGlvbiBnZXRTZXJpYWxpemF0aW9uS2V5KHBhbmVscykge1xuICByZXR1cm4gcGFuZWxzLm1hcChwYW5lbCA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgbWluU2l6ZSxcbiAgICAgIG9yZGVyXG4gICAgfSA9IHBhbmVsLmN1cnJlbnQ7XG4gICAgcmV0dXJuIG9yZGVyID8gYCR7b3JkZXJ9OiR7bWluU2l6ZX1gIDogYCR7bWluU2l6ZX1gO1xuICB9KS5zb3J0KChhLCBiKSA9PiBhLmxvY2FsZUNvbXBhcmUoYikpLmpvaW4oXCIsXCIpO1xufVxuZnVuY3Rpb24gbG9hZFNlcmlhbGl6ZWRQYW5lbEdyb3VwU3RhdGUoYXV0b1NhdmVJZCwgc3RvcmFnZSkge1xuICB0cnkge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBzdG9yYWdlLmdldEl0ZW0oYFBhbmVsR3JvdXA6c2l6ZXM6JHthdXRvU2F2ZUlkfWApO1xuICAgIGlmIChzZXJpYWxpemVkKSB7XG4gICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKHNlcmlhbGl6ZWQpO1xuICAgICAgaWYgKHR5cGVvZiBwYXJzZWQgPT09IFwib2JqZWN0XCIgJiYgcGFyc2VkICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7fVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHNhdmVQYW5lbEdyb3VwTGF5b3V0KGF1dG9TYXZlSWQsIHBhbmVscywgc2l6ZXMsIHN0b3JhZ2UpIHtcbiAgY29uc3Qga2V5ID0gZ2V0U2VyaWFsaXphdGlvbktleShwYW5lbHMpO1xuICBjb25zdCBzdGF0ZSA9IGxvYWRTZXJpYWxpemVkUGFuZWxHcm91cFN0YXRlKGF1dG9TYXZlSWQsIHN0b3JhZ2UpIHx8IHt9O1xuICBzdGF0ZVtrZXldID0gc2l6ZXM7XG4gIHRyeSB7XG4gICAgc3RvcmFnZS5zZXRJdGVtKGBQYW5lbEdyb3VwOnNpemVzOiR7YXV0b1NhdmVJZH1gLCBKU09OLnN0cmluZ2lmeShzdGF0ZSkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICB9XG59XG5cbmNvbnN0IGRlYm91bmNlTWFwID0ge307XG5cbi8vIFBhbmVsR3JvdXAgbWlnaHQgYmUgcmVuZGVyaW5nIGluIGEgc2VydmVyLXNpZGUgZW52aXJvbm1lbnQgd2hlcmUgbG9jYWxTdG9yYWdlIGlzIG5vdCBhdmFpbGFibGVcbi8vIG9yIG9uIGEgYnJvd3NlciB3aXRoIGNvb2tpZXMvc3RvcmFnZSBkaXNhYmxlZC5cbi8vIEluIGVpdGhlciBjYXNlLCB0aGlzIGZ1bmN0aW9uIGF2b2lkcyBhY2Nlc3NpbmcgbG9jYWxTdG9yYWdlIHVudGlsIG5lZWRlZCxcbi8vIGFuZCBhdm9pZHMgdGhyb3dpbmcgdXNlci12aXNpYmxlIGVycm9ycy5cbmZ1bmN0aW9uIGluaXRpYWxpemVEZWZhdWx0U3RvcmFnZShzdG9yYWdlT2JqZWN0KSB7XG4gIHRyeSB7XG4gICAgaWYgKHR5cGVvZiBsb2NhbFN0b3JhZ2UgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIC8vIEJ5cGFzcyB0aGlzIGNoZWNrIGZvciBmdXR1cmUgY2FsbHNcbiAgICAgIHN0b3JhZ2VPYmplY3QuZ2V0SXRlbSA9IG5hbWUgPT4ge1xuICAgICAgICByZXR1cm4gbG9jYWxTdG9yYWdlLmdldEl0ZW0obmFtZSk7XG4gICAgICB9O1xuICAgICAgc3RvcmFnZU9iamVjdC5zZXRJdGVtID0gKG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKG5hbWUsIHZhbHVlKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImxvY2FsU3RvcmFnZSBub3Qgc3VwcG9ydGVkIGluIHRoaXMgZW52aXJvbm1lbnRcIik7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIHN0b3JhZ2VPYmplY3QuZ2V0SXRlbSA9ICgpID0+IG51bGw7XG4gICAgc3RvcmFnZU9iamVjdC5zZXRJdGVtID0gKCkgPT4ge307XG4gIH1cbn1cbmNvbnN0IGRlZmF1bHRTdG9yYWdlID0ge1xuICBnZXRJdGVtOiBuYW1lID0+IHtcbiAgICBpbml0aWFsaXplRGVmYXVsdFN0b3JhZ2UoZGVmYXVsdFN0b3JhZ2UpO1xuICAgIHJldHVybiBkZWZhdWx0U3RvcmFnZS5nZXRJdGVtKG5hbWUpO1xuICB9LFxuICBzZXRJdGVtOiAobmFtZSwgdmFsdWUpID0+IHtcbiAgICBpbml0aWFsaXplRGVmYXVsdFN0b3JhZ2UoZGVmYXVsdFN0b3JhZ2UpO1xuICAgIGRlZmF1bHRTdG9yYWdlLnNldEl0ZW0obmFtZSwgdmFsdWUpO1xuICB9XG59O1xuXG4vLyBJbml0aWFsIGRyYWcgc3RhdGUgc2VydmVzIGEgZmV3IHB1cnBvc2VzOlxuLy8gKiBkcmFnT2Zmc2V0OlxuLy8gICBSZXNpemUgaXMgY2FsY3VsYXRlZCBieSB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgY3VycmVudCBwb2ludGVyIGV2ZW50IGFuZCB0aGUgcmVzaXplIGhhbmRsZSBiZWluZyBcImRyYWdnZWRcIlxuLy8gICBUaGlzIHZhbHVlIGFjY291bnRzIGZvciB0aGUgaW5pdGlhbCBvZmZzZXQgd2hlbiB0aGUgdG91Y2gvY2xpY2sgc3RhcnRzLCBzbyB0aGUgaGFuZGxlIGRvZXNuJ3QgYXBwZWFyIHRvIFwianVtcFwiXG4vLyAqIGRyYWdIYW5kbGVSZWN0LCBzaXplczpcbi8vICAgV2hlbiByZXNpemluZyBpcyBkb25lIHZpYSBtb3VzZS90b3VjaCBldmVudOKAkyBzb21lIGluaXRpYWwgc3RhdGUgaXMgc3RvcmVkXG4vLyAgIHNvIHRoYXQgYW55IHBhbmVscyB0aGF0IGNvbnRyYWN0IHdpbGwgYWxzbyBleHBhbmQgaWYgZHJhZyBkaXJlY3Rpb24gaXMgcmV2ZXJzZWQuXG5mdW5jdGlvbiBQYW5lbEdyb3VwV2l0aEZvcndhcmRlZFJlZih7XG4gIGF1dG9TYXZlSWQsXG4gIGNoaWxkcmVuID0gbnVsbCxcbiAgY2xhc3NOYW1lOiBjbGFzc05hbWVGcm9tUHJvcHMgPSBcIlwiLFxuICBkaXJlY3Rpb24sXG4gIGRpc2FibGVQb2ludGVyRXZlbnRzRHVyaW5nUmVzaXplID0gZmFsc2UsXG4gIGZvcndhcmRlZFJlZixcbiAgaWQ6IGlkRnJvbVByb3BzID0gbnVsbCxcbiAgb25MYXlvdXQsXG4gIHN0b3JhZ2UgPSBkZWZhdWx0U3RvcmFnZSxcbiAgc3R5bGU6IHN0eWxlRnJvbVByb3BzID0ge30sXG4gIHRhZ05hbWU6IFR5cGUgPSBcImRpdlwiLFxuICB1bml0cyA9IFwicGVyY2VudGFnZXNcIlxufSkge1xuICBjb25zdCBncm91cElkID0gdXNlVW5pcXVlSWQoaWRGcm9tUHJvcHMpO1xuICBjb25zdCBbYWN0aXZlSGFuZGxlSWQsIHNldEFjdGl2ZUhhbmRsZUlkXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBbcGFuZWxzLCBzZXRQYW5lbHNdID0gdXNlU3RhdGUobmV3IE1hcCgpKTtcblxuICAvLyBXaGVuIHJlc2l6aW5nIGlzIGRvbmUgdmlhIG1vdXNlL3RvdWNoIGV2ZW504oCTXG4gIC8vIFdlIHN0b3JlIHRoZSBpbml0aWFsIFBhbmVsIHNpemVzIGluIHRoaXMgcmVmLCBhbmQgYXBwbHkgbW92ZSBkZWx0YXMgdG8gdGhlbSBpbnN0ZWFkIG9mIHRvIHRoZSBjdXJyZW50IHNpemVzLlxuICAvLyBUaGlzIGhhcyB0aGUgYmVuZWZpdCBvZiBjYXVzaW5nIGZvcmNlLWNvbGxhcHNlZCBwYW5lbHMgdG8gc3ByaW5nIGJhY2sgb3BlbiBpZiBkcmFnIGlzIHJldmVyc2VkLlxuICBjb25zdCBpbml0aWFsRHJhZ1N0YXRlUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBkZXZXYXJuaW5nc1JlZiA9IHVzZVJlZih7XG4gICAgZGlkTG9nRGVmYXVsdFNpemVXYXJuaW5nOiBmYWxzZSxcbiAgICBkaWRMb2dJZEFuZE9yZGVyV2FybmluZzogZmFsc2UsXG4gICAgZGlkTG9nSW52YWxpZExheW91dFdhcm5pbmc6IGZhbHNlLFxuICAgIHByZXZQYW5lbElkczogW11cbiAgfSk7XG5cbiAgLy8gVXNlIGEgcmVmIHRvIGd1YXJkIGFnYWluc3QgdXNlcnMgcGFzc2luZyBpbmxpbmUgcHJvcHNcbiAgY29uc3QgY2FsbGJhY2tzUmVmID0gdXNlUmVmKHtcbiAgICBvbkxheW91dFxuICB9KTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjYWxsYmFja3NSZWYuY3VycmVudC5vbkxheW91dCA9IG9uTGF5b3V0O1xuICB9KTtcbiAgY29uc3QgcGFuZWxJZFRvTGFzdE5vdGlmaWVkU2l6ZU1hcFJlZiA9IHVzZVJlZih7fSk7XG5cbiAgLy8gMC0xIHZhbHVlcyByZXByZXNlbnRpbmcgdGhlIHJlbGF0aXZlIHNpemUgb2YgZWFjaCBwYW5lbC5cbiAgY29uc3QgW3NpemVzLCBzZXRTaXplc10gPSB1c2VTdGF0ZShbXSk7XG5cbiAgLy8gVXNlZCB0byBzdXBwb3J0IGltcGVyYXRpdmUgY29sbGFwc2UvZXhwYW5kIEFQSS5cbiAgY29uc3QgcGFuZWxTaXplQmVmb3JlQ29sbGFwc2UgPSB1c2VSZWYobmV3IE1hcCgpKTtcbiAgY29uc3QgcHJldkRlbHRhUmVmID0gdXNlUmVmKDApO1xuXG4gIC8vIFN0b3JlIGNvbW1pdHRlZCB2YWx1ZXMgdG8gYXZvaWQgdW5uZWNlc3NhcmlseSByZS1ydW5uaW5nIG1lbW9pemF0aW9uL2VmZmVjdHMgZnVuY3Rpb25zLlxuICBjb25zdCBjb21taXR0ZWRWYWx1ZXNSZWYgPSB1c2VSZWYoe1xuICAgIGRpcmVjdGlvbixcbiAgICBpZDogZ3JvdXBJZCxcbiAgICBwYW5lbHMsXG4gICAgc2l6ZXMsXG4gICAgdW5pdHNcbiAgfSk7XG4gIHVzZUltcGVyYXRpdmVIYW5kbGUoZm9yd2FyZGVkUmVmLCAoKSA9PiAoe1xuICAgIGdldElkOiAoKSA9PiBncm91cElkLFxuICAgIGdldExheW91dDogdW5pdHNGcm9tUGFyYW1zID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2l6ZXMsXG4gICAgICAgIHVuaXRzOiB1bml0c0Zyb21Qcm9wc1xuICAgICAgfSA9IGNvbW1pdHRlZFZhbHVlc1JlZi5jdXJyZW50O1xuICAgICAgY29uc3QgdW5pdHMgPSB1bml0c0Zyb21QYXJhbXMgPz8gdW5pdHNGcm9tUHJvcHM7XG4gICAgICBpZiAodW5pdHMgPT09IFwicGl4ZWxzXCIpIHtcbiAgICAgICAgY29uc3QgZ3JvdXBTaXplUGl4ZWxzID0gZ2V0QXZhaWxhYmxlR3JvdXBTaXplUGl4ZWxzKGdyb3VwSWQpO1xuICAgICAgICByZXR1cm4gc2l6ZXMubWFwKHNpemUgPT4gc2l6ZSAvIDEwMCAqIGdyb3VwU2l6ZVBpeGVscyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2l6ZXM7XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXRMYXlvdXQ6IChzaXplcywgdW5pdHNGcm9tUGFyYW1zKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGlkOiBncm91cElkLFxuICAgICAgICBwYW5lbHMsXG4gICAgICAgIHNpemVzOiBwcmV2U2l6ZXMsXG4gICAgICAgIHVuaXRzXG4gICAgICB9ID0gY29tbWl0dGVkVmFsdWVzUmVmLmN1cnJlbnQ7XG4gICAgICBpZiAoKHVuaXRzRnJvbVBhcmFtcyB8fCB1bml0cykgPT09IFwicGl4ZWxzXCIpIHtcbiAgICAgICAgY29uc3QgZ3JvdXBTaXplUGl4ZWxzID0gZ2V0QXZhaWxhYmxlR3JvdXBTaXplUGl4ZWxzKGdyb3VwSWQpO1xuICAgICAgICBzaXplcyA9IHNpemVzLm1hcChzaXplID0+IHNpemUgLyBncm91cFNpemVQaXhlbHMgKiAxMDApO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFuZWxJZFRvTGFzdE5vdGlmaWVkU2l6ZU1hcCA9IHBhbmVsSWRUb0xhc3ROb3RpZmllZFNpemVNYXBSZWYuY3VycmVudDtcbiAgICAgIGNvbnN0IHBhbmVsc0FycmF5ID0gcGFuZWxzTWFwVG9Tb3J0ZWRBcnJheShwYW5lbHMpO1xuICAgICAgY29uc3QgbmV4dFNpemVzID0gdmFsaWRhdGVQYW5lbEdyb3VwTGF5b3V0KHtcbiAgICAgICAgZ3JvdXBJZCxcbiAgICAgICAgcGFuZWxzLFxuICAgICAgICBuZXh0U2l6ZXM6IHNpemVzLFxuICAgICAgICBwcmV2U2l6ZXMsXG4gICAgICAgIHVuaXRzXG4gICAgICB9KTtcbiAgICAgIGlmICghYXJlRXF1YWwocHJldlNpemVzLCBuZXh0U2l6ZXMpKSB7XG4gICAgICAgIHNldFNpemVzKG5leHRTaXplcyk7XG4gICAgICAgIGNhbGxQYW5lbENhbGxiYWNrcyhwYW5lbHNBcnJheSwgbmV4dFNpemVzLCBwYW5lbElkVG9MYXN0Tm90aWZpZWRTaXplTWFwKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pLCBbZ3JvdXBJZF0pO1xuICB1c2VXaW5kb3dTcGxpdHRlclBhbmVsR3JvdXBCZWhhdmlvcih7XG4gICAgY29tbWl0dGVkVmFsdWVzUmVmLFxuICAgIGdyb3VwSWQsXG4gICAgcGFuZWxzLFxuICAgIHNldFNpemVzLFxuICAgIHNpemVzLFxuICAgIHBhbmVsU2l6ZUJlZm9yZUNvbGxhcHNlXG4gIH0pO1xuXG4gIC8vIE5vdGlmeSBleHRlcm5hbCBjb2RlIHdoZW4gc2l6ZXMgaGF2ZSBjaGFuZ2VkLlxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIG9uTGF5b3V0XG4gICAgfSA9IGNhbGxiYWNrc1JlZi5jdXJyZW50O1xuICAgIGNvbnN0IHtcbiAgICAgIHBhbmVscyxcbiAgICAgIHNpemVzXG4gICAgfSA9IGNvbW1pdHRlZFZhbHVlc1JlZi5jdXJyZW50O1xuXG4gICAgLy8gRG9uJ3QgY29tbWl0IGxheW91dCB1bnRpbCBhbGwgcGFuZWxzIGhhdmUgcmVnaXN0ZXJlZCBhbmQgcmUtcmVuZGVyZWQgd2l0aCB0aGVpciBhY3R1YWwgc2l6ZXMuXG4gICAgaWYgKHNpemVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmIChvbkxheW91dCkge1xuICAgICAgICBvbkxheW91dChzaXplcyk7XG4gICAgICB9XG4gICAgICBjb25zdCBwYW5lbElkVG9MYXN0Tm90aWZpZWRTaXplTWFwID0gcGFuZWxJZFRvTGFzdE5vdGlmaWVkU2l6ZU1hcFJlZi5jdXJyZW50O1xuXG4gICAgICAvLyBXaGVuIHBvc3NpYmxlLCB3ZSBub3RpZnkgYmVmb3JlIHRoZSBuZXh0IHJlbmRlciBzbyB0aGF0IHJlbmRlcmluZyB3b3JrIGNhbiBiZSBiYXRjaGVkIHRvZ2V0aGVyLlxuICAgICAgLy8gU29tZSBjYXNlcyBhcmUgZGlmZmljdWx0IHRvIGRldGVjdCB0aG91Z2gsXG4gICAgICAvLyBmb3IgZXhhbXBsZeKAkyBwYW5lbHMgdGhhdCBhcmUgY29uZGl0aW9uYWxseSByZW5kZXJlZCBjYW4gYWZmZWN0IHRoZSBzaXplIG9mIG5laWdoYm9yaW5nIHBhbmVscy5cbiAgICAgIC8vIEluIHRoaXMgY2FzZSwgdGhlIGJlc3Qgd2UgY2FuIGRvIGlzIG5vdGlmeSBvbiBjb21taXQuXG4gICAgICAvLyBUaGUgY2FsbFBhbmVsQ2FsbGJhY2tzKCkgdXNlcyBpdHMgb3duIG1lbW9pemF0aW9uIHRvIGF2b2lkIG5vdGlmeWluZyBwYW5lbHMgdHdpY2UgaW4gdGhlc2UgY2FzZXMuXG4gICAgICBjb25zdCBwYW5lbHNBcnJheSA9IHBhbmVsc01hcFRvU29ydGVkQXJyYXkocGFuZWxzKTtcbiAgICAgIGNhbGxQYW5lbENhbGxiYWNrcyhwYW5lbHNBcnJheSwgc2l6ZXMsIHBhbmVsSWRUb0xhc3ROb3RpZmllZFNpemVNYXApO1xuICAgIH1cbiAgfSwgW3NpemVzXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gSWYgdGhpcyBwYW5lbCBoYXMgYmVlbiBjb25maWd1cmVkIHRvIHBlcnNpc3Qgc2l6aW5nIGluZm9ybWF0aW9uLCBzYXZlIHNpemVzIHRvIGxvY2FsIHN0b3JhZ2UuXG4gICAgaWYgKGF1dG9TYXZlSWQpIHtcbiAgICAgIGlmIChzaXplcy5sZW5ndGggPT09IDAgfHwgc2l6ZXMubGVuZ3RoICE9PSBwYW5lbHMuc2l6ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBwYW5lbHNBcnJheSA9IHBhbmVsc01hcFRvU29ydGVkQXJyYXkocGFuZWxzKTtcblxuICAgICAgLy8gTGltaXQgdGhlIGZyZXF1ZW5jeSBvZiBsb2NhbFN0b3JhZ2UgdXBkYXRlcy5cbiAgICAgIGlmICghZGVib3VuY2VNYXBbYXV0b1NhdmVJZF0pIHtcbiAgICAgICAgZGVib3VuY2VNYXBbYXV0b1NhdmVJZF0gPSBkZWJvdW5jZShzYXZlUGFuZWxHcm91cExheW91dCwgMTAwKTtcbiAgICAgIH1cbiAgICAgIGRlYm91bmNlTWFwW2F1dG9TYXZlSWRdKGF1dG9TYXZlSWQsIHBhbmVsc0FycmF5LCBzaXplcywgc3RvcmFnZSk7XG4gICAgfVxuICAgIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGlkTG9nSWRBbmRPcmRlcldhcm5pbmcsXG4gICAgICAgIHByZXZQYW5lbElkc1xuICAgICAgfSA9IGRldldhcm5pbmdzUmVmLmN1cnJlbnQ7XG4gICAgICBpZiAoIWRpZExvZ0lkQW5kT3JkZXJXYXJuaW5nKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBwYW5lbHNcbiAgICAgICAgfSA9IGNvbW1pdHRlZFZhbHVlc1JlZi5jdXJyZW50O1xuICAgICAgICBjb25zdCBwYW5lbElkcyA9IEFycmF5LmZyb20ocGFuZWxzLmtleXMoKSk7XG4gICAgICAgIGRldldhcm5pbmdzUmVmLmN1cnJlbnQucHJldlBhbmVsSWRzID0gcGFuZWxJZHM7XG4gICAgICAgIGNvbnN0IHBhbmVsc0hhdmVDaGFuZ2VkID0gcHJldlBhbmVsSWRzLmxlbmd0aCA+IDAgJiYgIWFyZUVxdWFsKHByZXZQYW5lbElkcywgcGFuZWxJZHMpO1xuICAgICAgICBpZiAocGFuZWxzSGF2ZUNoYW5nZWQpIHtcbiAgICAgICAgICBpZiAoQXJyYXkuZnJvbShwYW5lbHMudmFsdWVzKCkpLmZpbmQocGFuZWwgPT4gcGFuZWwuY3VycmVudC5pZFdhc0F1dG9HZW5lcmF0ZWQgfHwgcGFuZWwuY3VycmVudC5vcmRlciA9PSBudWxsKSkge1xuICAgICAgICAgICAgZGV2V2FybmluZ3NSZWYuY3VycmVudC5kaWRMb2dJZEFuZE9yZGVyV2FybmluZyA9IHRydWU7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFdBUk5JTkc6IFBhbmVsIGlkIGFuZCBvcmRlciBwcm9wcyByZWNvbW1lbmRlZCB3aGVuIHBhbmVscyBhcmUgZHluYW1pY2FsbHkgcmVuZGVyZWRgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIFthdXRvU2F2ZUlkLCBwYW5lbHMsIHNpemVzLCBzdG9yYWdlXSk7XG4gIGNvbnN0IGdldFBhbmVsU2l6ZSA9IHVzZUNhbGxiYWNrKChpZCwgdW5pdHNGcm9tUGFyYW1zKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgcGFuZWxzLFxuICAgICAgdW5pdHM6IHVuaXRzRnJvbVByb3BzXG4gICAgfSA9IGNvbW1pdHRlZFZhbHVlc1JlZi5jdXJyZW50O1xuICAgIGNvbnN0IHBhbmVsc0FycmF5ID0gcGFuZWxzTWFwVG9Tb3J0ZWRBcnJheShwYW5lbHMpO1xuICAgIGNvbnN0IGluZGV4ID0gcGFuZWxzQXJyYXkuZmluZEluZGV4KHBhbmVsID0+IHBhbmVsLmN1cnJlbnQuaWQgPT09IGlkKTtcbiAgICBjb25zdCBzaXplID0gc2l6ZXNbaW5kZXhdO1xuICAgIGNvbnN0IHVuaXRzID0gdW5pdHNGcm9tUGFyYW1zID8/IHVuaXRzRnJvbVByb3BzO1xuICAgIGlmICh1bml0cyA9PT0gXCJwaXhlbHNcIikge1xuICAgICAgY29uc3QgZ3JvdXBTaXplUGl4ZWxzID0gZ2V0QXZhaWxhYmxlR3JvdXBTaXplUGl4ZWxzKGdyb3VwSWQpO1xuICAgICAgcmV0dXJuIHNpemUgLyAxMDAgKiBncm91cFNpemVQaXhlbHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzaXplO1xuICAgIH1cbiAgfSwgW2dyb3VwSWQsIHNpemVzXSk7XG4gIGNvbnN0IGdldFBhbmVsU3R5bGUgPSB1c2VDYWxsYmFjaygoaWQsIGRlZmF1bHRTaXplKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgcGFuZWxzXG4gICAgfSA9IGNvbW1pdHRlZFZhbHVlc1JlZi5jdXJyZW50O1xuXG4gICAgLy8gQmVmb3JlIG1vdW50aW5nLCBQYW5lbHMgd2lsbCBub3QgeWV0IGhhdmUgcmVnaXN0ZXJlZCB0aGVtc2VsdmVzLlxuICAgIC8vIFRoaXMgaW5jbHVkZXMgc2VydmVyIHJlbmRlcmluZy5cbiAgICAvLyBBdCB0aGlzIHBvaW50IHRoZSBiZXN0IHdlIGNhbiBkbyBpcyByZW5kZXIgZXZlcnl0aGluZyB3aXRoIHRoZSBzYW1lIHNpemUuXG4gICAgaWYgKHBhbmVscy5zaXplID09PSAwKSB7XG4gICAgICB7XG4gICAgICAgIGlmICghZGV2V2FybmluZ3NSZWYuY3VycmVudC5kaWRMb2dEZWZhdWx0U2l6ZVdhcm5pbmcpIHtcbiAgICAgICAgICBpZiAoZGVmYXVsdFNpemUgPT0gbnVsbCkge1xuICAgICAgICAgICAgZGV2V2FybmluZ3NSZWYuY3VycmVudC5kaWRMb2dEZWZhdWx0U2l6ZVdhcm5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBXQVJOSU5HOiBQYW5lbCBkZWZhdWx0U2l6ZSBwcm9wIHJlY29tbWVuZGVkIHRvIGF2b2lkIGxheW91dCBzaGlmdCBhZnRlciBzZXJ2ZXIgcmVuZGVyaW5nYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBmbGV4QmFzaXM6IDAsXG4gICAgICAgIGZsZXhHcm93OiBkZWZhdWx0U2l6ZSAhPSBudWxsID8gZGVmYXVsdFNpemUgOiB1bmRlZmluZWQsXG4gICAgICAgIGZsZXhTaHJpbms6IDEsXG4gICAgICAgIC8vIFdpdGhvdXQgdGhpcywgUGFuZWwgc2l6ZXMgbWF5IGJlIHVuaW50ZW50aW9uYWxseSBvdmVycmlkZGVuIGJ5IHRoZWlyIGNvbnRlbnQuXG4gICAgICAgIG92ZXJmbG93OiBcImhpZGRlblwiXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBmbGV4R3JvdyA9IGdldEZsZXhHcm93KHBhbmVscywgaWQsIHNpemVzKTtcbiAgICByZXR1cm4ge1xuICAgICAgZmxleEJhc2lzOiAwLFxuICAgICAgZmxleEdyb3csXG4gICAgICBmbGV4U2hyaW5rOiAxLFxuICAgICAgLy8gV2l0aG91dCB0aGlzLCBQYW5lbCBzaXplcyBtYXkgYmUgdW5pbnRlbnRpb25hbGx5IG92ZXJyaWRkZW4gYnkgdGhlaXIgY29udGVudC5cbiAgICAgIG92ZXJmbG93OiBcImhpZGRlblwiLFxuICAgICAgLy8gRGlzYWJsZSBwb2ludGVyIGV2ZW50cyBpbnNpZGUgb2YgYSBwYW5lbCBkdXJpbmcgcmVzaXplLlxuICAgICAgLy8gVGhpcyBhdm9pZCBlZGdlIGNhc2VzIGxpa2UgbmVzdGVkIGlmcmFtZXMuXG4gICAgICBwb2ludGVyRXZlbnRzOiBkaXNhYmxlUG9pbnRlckV2ZW50c0R1cmluZ1Jlc2l6ZSAmJiBhY3RpdmVIYW5kbGVJZCAhPT0gbnVsbCA/IFwibm9uZVwiIDogdW5kZWZpbmVkXG4gICAgfTtcbiAgfSwgW2FjdGl2ZUhhbmRsZUlkLCBkaXNhYmxlUG9pbnRlckV2ZW50c0R1cmluZ1Jlc2l6ZSwgc2l6ZXNdKTtcbiAgY29uc3QgcmVnaXN0ZXJQYW5lbCA9IHVzZUNhbGxiYWNrKChpZCwgcGFuZWxSZWYpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICB1bml0c1xuICAgIH0gPSBjb21taXR0ZWRWYWx1ZXNSZWYuY3VycmVudDtcbiAgICB2YWxpZGF0ZVBhbmVsUHJvcHModW5pdHMsIHBhbmVsUmVmKTtcbiAgICBzZXRQYW5lbHMocHJldlBhbmVscyA9PiB7XG4gICAgICBpZiAocHJldlBhbmVscy5oYXMoaWQpKSB7XG4gICAgICAgIHJldHVybiBwcmV2UGFuZWxzO1xuICAgICAgfVxuICAgICAgY29uc3QgbmV4dFBhbmVscyA9IG5ldyBNYXAocHJldlBhbmVscyk7XG4gICAgICBuZXh0UGFuZWxzLnNldChpZCwgcGFuZWxSZWYpO1xuICAgICAgcmV0dXJuIG5leHRQYW5lbHM7XG4gICAgfSk7XG4gIH0sIFtdKTtcbiAgY29uc3QgcmVnaXN0ZXJSZXNpemVIYW5kbGUgPSB1c2VDYWxsYmFjayhoYW5kbGVJZCA9PiB7XG4gICAgY29uc3QgcmVzaXplSGFuZGxlciA9IGV2ZW50ID0+IHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRpcmVjdGlvbixcbiAgICAgICAgcGFuZWxzLFxuICAgICAgICBzaXplczogcHJldlNpemVzXG4gICAgICB9ID0gY29tbWl0dGVkVmFsdWVzUmVmLmN1cnJlbnQ7XG4gICAgICBjb25zdCBwYW5lbHNBcnJheSA9IHBhbmVsc01hcFRvU29ydGVkQXJyYXkocGFuZWxzKTtcbiAgICAgIGNvbnN0IFtpZEJlZm9yZSwgaWRBZnRlcl0gPSBnZXRSZXNpemVIYW5kbGVQYW5lbElkcyhncm91cElkLCBoYW5kbGVJZCwgcGFuZWxzQXJyYXkpO1xuICAgICAgaWYgKGlkQmVmb3JlID09IG51bGwgfHwgaWRBZnRlciA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBtb3ZlbWVudCA9IGdldE1vdmVtZW50KGV2ZW50LCBncm91cElkLCBoYW5kbGVJZCwgcGFuZWxzQXJyYXksIGRpcmVjdGlvbiwgcHJldlNpemVzLCBpbml0aWFsRHJhZ1N0YXRlUmVmLmN1cnJlbnQpO1xuICAgICAgaWYgKG1vdmVtZW50ID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGdyb3VwRWxlbWVudCA9IGdldFBhbmVsR3JvdXAoZ3JvdXBJZCk7XG4gICAgICBjb25zdCByZWN0ID0gZ3JvdXBFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3QgaXNIb3Jpem9udGFsID0gZGlyZWN0aW9uID09PSBcImhvcml6b250YWxcIjtcblxuICAgICAgLy8gU3VwcG9ydCBSVEwgbGF5b3V0c1xuICAgICAgaWYgKGRvY3VtZW50LmRpciA9PT0gXCJydGxcIiAmJiBpc0hvcml6b250YWwpIHtcbiAgICAgICAgbW92ZW1lbnQgPSAtbW92ZW1lbnQ7XG4gICAgICB9XG4gICAgICBjb25zdCBzaXplID0gaXNIb3Jpem9udGFsID8gcmVjdC53aWR0aCA6IHJlY3QuaGVpZ2h0O1xuICAgICAgY29uc3QgZGVsdGEgPSBtb3ZlbWVudCAvIHNpemUgKiAxMDA7XG5cbiAgICAgIC8vIElmIGEgdmFsaWRhdGVMYXlvdXQgbWV0aG9kIGhhcyBiZWVuIHByb3ZpZGVkXG4gICAgICAvLyBpdCdzIGltcG9ydGFudCB0byB1c2UgaXQgYmVmb3JlIHVwZGF0aW5nIHRoZSBtb3VzZSBjdXJzb3JcbiAgICAgIGNvbnN0IG5leHRTaXplcyA9IGFkanVzdEJ5RGVsdGEoZXZlbnQsIGNvbW1pdHRlZFZhbHVlc1JlZi5jdXJyZW50LCBpZEJlZm9yZSwgaWRBZnRlciwgZGVsdGEsIHByZXZTaXplcywgcGFuZWxTaXplQmVmb3JlQ29sbGFwc2UuY3VycmVudCwgaW5pdGlhbERyYWdTdGF0ZVJlZi5jdXJyZW50KTtcbiAgICAgIGNvbnN0IHNpemVzQ2hhbmdlZCA9ICFhcmVFcXVhbChwcmV2U2l6ZXMsIG5leHRTaXplcyk7XG5cbiAgICAgIC8vIERvbid0IHVwZGF0ZSBjdXJzb3IgZm9yIHJlc2l6ZXMgdHJpZ2dlcmVkIGJ5IGtleWJvYXJkIGludGVyYWN0aW9ucy5cbiAgICAgIGlmIChpc01vdXNlRXZlbnQoZXZlbnQpIHx8IGlzVG91Y2hFdmVudChldmVudCkpIHtcbiAgICAgICAgLy8gV2F0Y2ggZm9yIG11bHRpcGxlIHN1YnNlcXVlbnQgZGVsdGFzOyB0aGlzIG1pZ2h0IG9jY3VyIGZvciB0aW55IGN1cnNvciBtb3ZlbWVudHMuXG4gICAgICAgIC8vIEluIHRoaXMgY2FzZSwgUGFuZWwgc2l6ZXMgbWlnaHQgbm90IGNoYW5nZeKAk1xuICAgICAgICAvLyBidXQgdXBkYXRpbmcgY3Vyc29yIGluIHRoaXMgc2NlbmFyaW8gd291bGQgY2F1c2UgYSBmbGlja2VyLlxuICAgICAgICBpZiAocHJldkRlbHRhUmVmLmN1cnJlbnQgIT0gZGVsdGEpIHtcbiAgICAgICAgICBpZiAoIXNpemVzQ2hhbmdlZCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIHBvaW50ZXIgaGFzIG1vdmVkIHRvbyBmYXIgdG8gcmVzaXplIHRoZSBwYW5lbCBhbnkgZnVydGhlcixcbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgY3Vyc29yIHN0eWxlIGZvciBhIHZpc3VhbCBjbHVlLlxuICAgICAgICAgICAgLy8gVGhpcyBtaW1pY3MgVlMgQ29kZSBiZWhhdmlvci5cblxuICAgICAgICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICBzZXRHbG9iYWxDdXJzb3JTdHlsZShtb3ZlbWVudCA8IDAgPyBcImhvcml6b250YWwtbWluXCIgOiBcImhvcml6b250YWwtbWF4XCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2V0R2xvYmFsQ3Vyc29yU3R5bGUobW92ZW1lbnQgPCAwID8gXCJ2ZXJ0aWNhbC1taW5cIiA6IFwidmVydGljYWwtbWF4XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBSZXNldCB0aGUgY3Vyc29yIHN0eWxlIHRvIHRoZSB0aGUgbm9ybWFsIHJlc2l6ZSBjdXJzb3IuXG4gICAgICAgICAgICBzZXRHbG9iYWxDdXJzb3JTdHlsZShpc0hvcml6b250YWwgPyBcImhvcml6b250YWxcIiA6IFwidmVydGljYWxcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2l6ZXNDaGFuZ2VkKSB7XG4gICAgICAgIGNvbnN0IHBhbmVsSWRUb0xhc3ROb3RpZmllZFNpemVNYXAgPSBwYW5lbElkVG9MYXN0Tm90aWZpZWRTaXplTWFwUmVmLmN1cnJlbnQ7XG5cbiAgICAgICAgLy8gSXQncyBva2F5IHRvIGJ5cGFzcyBpbiB0aGlzIGNhc2UgYmVjYXVzZSB3ZSBhbHJlYWR5IHZhbGlkYXRlZCBhYm92ZVxuICAgICAgICBzZXRTaXplcyhuZXh0U2l6ZXMpO1xuXG4gICAgICAgIC8vIElmIHJlc2l6ZSBjaGFuZ2UgaGFuZGxlcnMgaGF2ZSBiZWVuIGRlY2xhcmVkLCB0aGlzIGlzIHRoZSB0aW1lIHRvIGNhbGwgdGhlbS5cbiAgICAgICAgLy8gVHJpZ2dlciB1c2VyIGNhbGxiYWNrcyBhZnRlciB1cGRhdGluZyBzdGF0ZSwgc28gdGhhdCB1c2VyIGNvZGUgY2FuIG92ZXJyaWRlIHRoZSBzaXplcy5cbiAgICAgICAgY2FsbFBhbmVsQ2FsbGJhY2tzKHBhbmVsc0FycmF5LCBuZXh0U2l6ZXMsIHBhbmVsSWRUb0xhc3ROb3RpZmllZFNpemVNYXApO1xuICAgICAgfVxuICAgICAgcHJldkRlbHRhUmVmLmN1cnJlbnQgPSBkZWx0YTtcbiAgICB9O1xuICAgIHJldHVybiByZXNpemVIYW5kbGVyO1xuICB9LCBbZ3JvdXBJZF0pO1xuICBjb25zdCB1bnJlZ2lzdGVyUGFuZWwgPSB1c2VDYWxsYmFjayhpZCA9PiB7XG4gICAgc2V0UGFuZWxzKHByZXZQYW5lbHMgPT4ge1xuICAgICAgaWYgKCFwcmV2UGFuZWxzLmhhcyhpZCkpIHtcbiAgICAgICAgcmV0dXJuIHByZXZQYW5lbHM7XG4gICAgICB9XG4gICAgICBjb25zdCBuZXh0UGFuZWxzID0gbmV3IE1hcChwcmV2UGFuZWxzKTtcbiAgICAgIG5leHRQYW5lbHMuZGVsZXRlKGlkKTtcbiAgICAgIHJldHVybiBuZXh0UGFuZWxzO1xuICAgIH0pO1xuICB9LCBbXSk7XG4gIGNvbnN0IGNvbGxhcHNlUGFuZWwgPSB1c2VDYWxsYmFjayhpZCA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgcGFuZWxzLFxuICAgICAgc2l6ZXM6IHByZXZTaXplc1xuICAgIH0gPSBjb21taXR0ZWRWYWx1ZXNSZWYuY3VycmVudDtcbiAgICBjb25zdCBwYW5lbCA9IHBhbmVscy5nZXQoaWQpO1xuICAgIGlmIChwYW5lbCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGNvbGxhcHNlZFNpemUsXG4gICAgICBjb2xsYXBzaWJsZVxuICAgIH0gPSBwYW5lbC5jdXJyZW50O1xuICAgIGlmICghY29sbGFwc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcGFuZWxzQXJyYXkgPSBwYW5lbHNNYXBUb1NvcnRlZEFycmF5KHBhbmVscyk7XG4gICAgY29uc3QgaW5kZXggPSBwYW5lbHNBcnJheS5pbmRleE9mKHBhbmVsKTtcbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRTaXplID0gcHJldlNpemVzW2luZGV4XTtcbiAgICBpZiAoY3VycmVudFNpemUgPT09IGNvbGxhcHNlZFNpemUpIHtcbiAgICAgIC8vIFBhbmVsIGlzIGFscmVhZHkgY29sbGFwc2VkLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwYW5lbFNpemVCZWZvcmVDb2xsYXBzZS5jdXJyZW50LnNldChpZCwgY3VycmVudFNpemUpO1xuICAgIGNvbnN0IFtpZEJlZm9yZSwgaWRBZnRlcl0gPSBnZXRCZWZvcmVBbmRBZnRlcklkcyhpZCwgcGFuZWxzQXJyYXkpO1xuICAgIGlmIChpZEJlZm9yZSA9PSBudWxsIHx8IGlkQWZ0ZXIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpc0xhc3RQYW5lbCA9IGluZGV4ID09PSBwYW5lbHNBcnJheS5sZW5ndGggLSAxO1xuICAgIGNvbnN0IGRlbHRhID0gaXNMYXN0UGFuZWwgPyBjdXJyZW50U2l6ZSA6IGNvbGxhcHNlZFNpemUgLSBjdXJyZW50U2l6ZTtcbiAgICBjb25zdCBuZXh0U2l6ZXMgPSBhZGp1c3RCeURlbHRhKG51bGwsIGNvbW1pdHRlZFZhbHVlc1JlZi5jdXJyZW50LCBpZEJlZm9yZSwgaWRBZnRlciwgZGVsdGEsIHByZXZTaXplcywgcGFuZWxTaXplQmVmb3JlQ29sbGFwc2UuY3VycmVudCwgbnVsbCk7XG4gICAgaWYgKHByZXZTaXplcyAhPT0gbmV4dFNpemVzKSB7XG4gICAgICBjb25zdCBwYW5lbElkVG9MYXN0Tm90aWZpZWRTaXplTWFwID0gcGFuZWxJZFRvTGFzdE5vdGlmaWVkU2l6ZU1hcFJlZi5jdXJyZW50O1xuICAgICAgc2V0U2l6ZXMobmV4dFNpemVzKTtcblxuICAgICAgLy8gSWYgcmVzaXplIGNoYW5nZSBoYW5kbGVycyBoYXZlIGJlZW4gZGVjbGFyZWQsIHRoaXMgaXMgdGhlIHRpbWUgdG8gY2FsbCB0aGVtLlxuICAgICAgLy8gVHJpZ2dlciB1c2VyIGNhbGxiYWNrcyBhZnRlciB1cGRhdGluZyBzdGF0ZSwgc28gdGhhdCB1c2VyIGNvZGUgY2FuIG92ZXJyaWRlIHRoZSBzaXplcy5cbiAgICAgIGNhbGxQYW5lbENhbGxiYWNrcyhwYW5lbHNBcnJheSwgbmV4dFNpemVzLCBwYW5lbElkVG9MYXN0Tm90aWZpZWRTaXplTWFwKTtcbiAgICB9XG4gIH0sIFtdKTtcbiAgY29uc3QgZXhwYW5kUGFuZWwgPSB1c2VDYWxsYmFjayhpZCA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgcGFuZWxzLFxuICAgICAgc2l6ZXM6IHByZXZTaXplc1xuICAgIH0gPSBjb21taXR0ZWRWYWx1ZXNSZWYuY3VycmVudDtcbiAgICBjb25zdCBwYW5lbCA9IHBhbmVscy5nZXQoaWQpO1xuICAgIGlmIChwYW5lbCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGNvbGxhcHNlZFNpemUsXG4gICAgICBtaW5TaXplXG4gICAgfSA9IHBhbmVsLmN1cnJlbnQ7XG4gICAgY29uc3Qgc2l6ZUJlZm9yZUNvbGxhcHNlID0gcGFuZWxTaXplQmVmb3JlQ29sbGFwc2UuY3VycmVudC5nZXQoaWQpIHx8IG1pblNpemU7XG4gICAgaWYgKCFzaXplQmVmb3JlQ29sbGFwc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcGFuZWxzQXJyYXkgPSBwYW5lbHNNYXBUb1NvcnRlZEFycmF5KHBhbmVscyk7XG4gICAgY29uc3QgaW5kZXggPSBwYW5lbHNBcnJheS5pbmRleE9mKHBhbmVsKTtcbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRTaXplID0gcHJldlNpemVzW2luZGV4XTtcbiAgICBpZiAoY3VycmVudFNpemUgIT09IGNvbGxhcHNlZFNpemUpIHtcbiAgICAgIC8vIFBhbmVsIGlzIGFscmVhZHkgZXhwYW5kZWQuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IFtpZEJlZm9yZSwgaWRBZnRlcl0gPSBnZXRCZWZvcmVBbmRBZnRlcklkcyhpZCwgcGFuZWxzQXJyYXkpO1xuICAgIGlmIChpZEJlZm9yZSA9PSBudWxsIHx8IGlkQWZ0ZXIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpc0xhc3RQYW5lbCA9IGluZGV4ID09PSBwYW5lbHNBcnJheS5sZW5ndGggLSAxO1xuICAgIGNvbnN0IGRlbHRhID0gaXNMYXN0UGFuZWwgPyBjb2xsYXBzZWRTaXplIC0gc2l6ZUJlZm9yZUNvbGxhcHNlIDogc2l6ZUJlZm9yZUNvbGxhcHNlO1xuICAgIGNvbnN0IG5leHRTaXplcyA9IGFkanVzdEJ5RGVsdGEobnVsbCwgY29tbWl0dGVkVmFsdWVzUmVmLmN1cnJlbnQsIGlkQmVmb3JlLCBpZEFmdGVyLCBkZWx0YSwgcHJldlNpemVzLCBwYW5lbFNpemVCZWZvcmVDb2xsYXBzZS5jdXJyZW50LCBudWxsKTtcbiAgICBpZiAocHJldlNpemVzICE9PSBuZXh0U2l6ZXMpIHtcbiAgICAgIGNvbnN0IHBhbmVsSWRUb0xhc3ROb3RpZmllZFNpemVNYXAgPSBwYW5lbElkVG9MYXN0Tm90aWZpZWRTaXplTWFwUmVmLmN1cnJlbnQ7XG4gICAgICBzZXRTaXplcyhuZXh0U2l6ZXMpO1xuXG4gICAgICAvLyBJZiByZXNpemUgY2hhbmdlIGhhbmRsZXJzIGhhdmUgYmVlbiBkZWNsYXJlZCwgdGhpcyBpcyB0aGUgdGltZSB0byBjYWxsIHRoZW0uXG4gICAgICAvLyBUcmlnZ2VyIHVzZXIgY2FsbGJhY2tzIGFmdGVyIHVwZGF0aW5nIHN0YXRlLCBzbyB0aGF0IHVzZXIgY29kZSBjYW4gb3ZlcnJpZGUgdGhlIHNpemVzLlxuICAgICAgY2FsbFBhbmVsQ2FsbGJhY2tzKHBhbmVsc0FycmF5LCBuZXh0U2l6ZXMsIHBhbmVsSWRUb0xhc3ROb3RpZmllZFNpemVNYXApO1xuICAgIH1cbiAgfSwgW10pO1xuICBjb25zdCByZXNpemVQYW5lbCA9IHVzZUNhbGxiYWNrKChpZCwgbmV4dFNpemUsIHVuaXRzRnJvbVBhcmFtcykgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGlkOiBncm91cElkLFxuICAgICAgcGFuZWxzLFxuICAgICAgc2l6ZXM6IHByZXZTaXplcyxcbiAgICAgIHVuaXRzXG4gICAgfSA9IGNvbW1pdHRlZFZhbHVlc1JlZi5jdXJyZW50O1xuICAgIGlmICgodW5pdHNGcm9tUGFyYW1zIHx8IHVuaXRzKSA9PT0gXCJwaXhlbHNcIikge1xuICAgICAgY29uc3QgZ3JvdXBTaXplUGl4ZWxzID0gZ2V0QXZhaWxhYmxlR3JvdXBTaXplUGl4ZWxzKGdyb3VwSWQpO1xuICAgICAgbmV4dFNpemUgPSBuZXh0U2l6ZSAvIGdyb3VwU2l6ZVBpeGVscyAqIDEwMDtcbiAgICB9XG4gICAgY29uc3QgcGFuZWwgPSBwYW5lbHMuZ2V0KGlkKTtcbiAgICBpZiAocGFuZWwgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQge1xuICAgICAgY29sbGFwc2VkU2l6ZSxcbiAgICAgIGNvbGxhcHNpYmxlLFxuICAgICAgbWF4U2l6ZSxcbiAgICAgIG1pblNpemVcbiAgICB9ID0gcGFuZWwuY3VycmVudDtcbiAgICBpZiAodW5pdHMgPT09IFwicGl4ZWxzXCIpIHtcbiAgICAgIGNvbnN0IGdyb3VwU2l6ZVBpeGVscyA9IGdldEF2YWlsYWJsZUdyb3VwU2l6ZVBpeGVscyhncm91cElkKTtcbiAgICAgIG1pblNpemUgPSBtaW5TaXplIC8gZ3JvdXBTaXplUGl4ZWxzICogMTAwO1xuICAgICAgaWYgKG1heFNpemUgIT0gbnVsbCkge1xuICAgICAgICBtYXhTaXplID0gbWF4U2l6ZSAvIGdyb3VwU2l6ZVBpeGVscyAqIDEwMDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcGFuZWxzQXJyYXkgPSBwYW5lbHNNYXBUb1NvcnRlZEFycmF5KHBhbmVscyk7XG4gICAgY29uc3QgaW5kZXggPSBwYW5lbHNBcnJheS5pbmRleE9mKHBhbmVsKTtcbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRTaXplID0gcHJldlNpemVzW2luZGV4XTtcbiAgICBpZiAoY3VycmVudFNpemUgPT09IG5leHRTaXplKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjb2xsYXBzaWJsZSAmJiBuZXh0U2l6ZSA9PT0gY29sbGFwc2VkU2l6ZSkgOyBlbHNlIHtcbiAgICAgIGNvbnN0IHVuc2FmZU5leHRTaXplID0gbmV4dFNpemU7XG4gICAgICBuZXh0U2l6ZSA9IE1hdGgubWluKG1heFNpemUgIT0gbnVsbCA/IG1heFNpemUgOiAxMDAsIE1hdGgubWF4KG1pblNpemUsIG5leHRTaXplKSk7XG4gICAgICB7XG4gICAgICAgIGlmICh1bnNhZmVOZXh0U2l6ZSAhPT0gbmV4dFNpemUpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBJbnZhbGlkIHNpemUgKCR7dW5zYWZlTmV4dFNpemV9KSBzcGVjaWZpZWQgZm9yIFBhbmVsIFwiJHtwYW5lbC5jdXJyZW50LmlkfVwiIGdpdmVuIHRoZSBwYW5lbCdzIG1pbi9tYXggc2l6ZSBjb25zdHJhaW50c2ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IFtpZEJlZm9yZSwgaWRBZnRlcl0gPSBnZXRCZWZvcmVBbmRBZnRlcklkcyhpZCwgcGFuZWxzQXJyYXkpO1xuICAgIGlmIChpZEJlZm9yZSA9PSBudWxsIHx8IGlkQWZ0ZXIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpc0xhc3RQYW5lbCA9IGluZGV4ID09PSBwYW5lbHNBcnJheS5sZW5ndGggLSAxO1xuICAgIGNvbnN0IGRlbHRhID0gaXNMYXN0UGFuZWwgPyBjdXJyZW50U2l6ZSAtIG5leHRTaXplIDogbmV4dFNpemUgLSBjdXJyZW50U2l6ZTtcbiAgICBjb25zdCBuZXh0U2l6ZXMgPSBhZGp1c3RCeURlbHRhKG51bGwsIGNvbW1pdHRlZFZhbHVlc1JlZi5jdXJyZW50LCBpZEJlZm9yZSwgaWRBZnRlciwgZGVsdGEsIHByZXZTaXplcywgcGFuZWxTaXplQmVmb3JlQ29sbGFwc2UuY3VycmVudCwgbnVsbCk7XG4gICAgaWYgKHByZXZTaXplcyAhPT0gbmV4dFNpemVzKSB7XG4gICAgICBjb25zdCBwYW5lbElkVG9MYXN0Tm90aWZpZWRTaXplTWFwID0gcGFuZWxJZFRvTGFzdE5vdGlmaWVkU2l6ZU1hcFJlZi5jdXJyZW50O1xuICAgICAgc2V0U2l6ZXMobmV4dFNpemVzKTtcblxuICAgICAgLy8gSWYgcmVzaXplIGNoYW5nZSBoYW5kbGVycyBoYXZlIGJlZW4gZGVjbGFyZWQsIHRoaXMgaXMgdGhlIHRpbWUgdG8gY2FsbCB0aGVtLlxuICAgICAgLy8gVHJpZ2dlciB1c2VyIGNhbGxiYWNrcyBhZnRlciB1cGRhdGluZyBzdGF0ZSwgc28gdGhhdCB1c2VyIGNvZGUgY2FuIG92ZXJyaWRlIHRoZSBzaXplcy5cbiAgICAgIGNhbGxQYW5lbENhbGxiYWNrcyhwYW5lbHNBcnJheSwgbmV4dFNpemVzLCBwYW5lbElkVG9MYXN0Tm90aWZpZWRTaXplTWFwKTtcbiAgICB9XG4gIH0sIFtdKTtcbiAgY29uc3QgY29udGV4dCA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBhY3RpdmVIYW5kbGVJZCxcbiAgICBjb2xsYXBzZVBhbmVsLFxuICAgIGRpcmVjdGlvbixcbiAgICBleHBhbmRQYW5lbCxcbiAgICBnZXRQYW5lbFNpemUsXG4gICAgZ2V0UGFuZWxTdHlsZSxcbiAgICBncm91cElkLFxuICAgIHJlZ2lzdGVyUGFuZWwsXG4gICAgcmVnaXN0ZXJSZXNpemVIYW5kbGUsXG4gICAgcmVzaXplUGFuZWwsXG4gICAgc3RhcnREcmFnZ2luZzogKGlkLCBldmVudCkgPT4ge1xuICAgICAgc2V0QWN0aXZlSGFuZGxlSWQoaWQpO1xuICAgICAgaWYgKGlzTW91c2VFdmVudChldmVudCkgfHwgaXNUb3VjaEV2ZW50KGV2ZW50KSkge1xuICAgICAgICBjb25zdCBoYW5kbGVFbGVtZW50ID0gZ2V0UmVzaXplSGFuZGxlKGlkKTtcbiAgICAgICAgaW5pdGlhbERyYWdTdGF0ZVJlZi5jdXJyZW50ID0ge1xuICAgICAgICAgIGRyYWdIYW5kbGVSZWN0OiBoYW5kbGVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgIGRyYWdPZmZzZXQ6IGdldERyYWdPZmZzZXQoZXZlbnQsIGlkLCBkaXJlY3Rpb24pLFxuICAgICAgICAgIHNpemVzOiBjb21taXR0ZWRWYWx1ZXNSZWYuY3VycmVudC5zaXplc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG4gICAgc3RvcERyYWdnaW5nOiAoKSA9PiB7XG4gICAgICByZXNldEdsb2JhbEN1cnNvclN0eWxlKCk7XG4gICAgICBzZXRBY3RpdmVIYW5kbGVJZChudWxsKTtcbiAgICAgIGluaXRpYWxEcmFnU3RhdGVSZWYuY3VycmVudCA9IG51bGw7XG4gICAgfSxcbiAgICB1bml0cyxcbiAgICB1bnJlZ2lzdGVyUGFuZWxcbiAgfSksIFthY3RpdmVIYW5kbGVJZCwgY29sbGFwc2VQYW5lbCwgZGlyZWN0aW9uLCBleHBhbmRQYW5lbCwgZ2V0UGFuZWxTaXplLCBnZXRQYW5lbFN0eWxlLCBncm91cElkLCByZWdpc3RlclBhbmVsLCByZWdpc3RlclJlc2l6ZUhhbmRsZSwgcmVzaXplUGFuZWwsIHVuaXRzLCB1bnJlZ2lzdGVyUGFuZWxdKTtcbiAgY29uc3Qgc3R5bGUgPSB7XG4gICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgZmxleERpcmVjdGlvbjogZGlyZWN0aW9uID09PSBcImhvcml6b250YWxcIiA/IFwicm93XCIgOiBcImNvbHVtblwiLFxuICAgIGhlaWdodDogXCIxMDAlXCIsXG4gICAgb3ZlcmZsb3c6IFwiaGlkZGVuXCIsXG4gICAgd2lkdGg6IFwiMTAwJVwiXG4gIH07XG4gIHJldHVybiBjcmVhdGVFbGVtZW50KFBhbmVsR3JvdXBDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgY2hpbGRyZW46IGNyZWF0ZUVsZW1lbnQoVHlwZSwge1xuICAgICAgY2hpbGRyZW4sXG4gICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZUZyb21Qcm9wcyxcbiAgICAgIFwiZGF0YS1wYW5lbC1ncm91cFwiOiBcIlwiLFxuICAgICAgXCJkYXRhLXBhbmVsLWdyb3VwLWRpcmVjdGlvblwiOiBkaXJlY3Rpb24sXG4gICAgICBcImRhdGEtcGFuZWwtZ3JvdXAtaWRcIjogZ3JvdXBJZCxcbiAgICAgIFwiZGF0YS1wYW5lbC1ncm91cC11bml0c1wiOiB1bml0cyxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIC4uLnN0eWxlLFxuICAgICAgICAuLi5zdHlsZUZyb21Qcm9wc1xuICAgICAgfVxuICAgIH0pLFxuICAgIHZhbHVlOiBjb250ZXh0XG4gIH0pO1xufVxuY29uc3QgUGFuZWxHcm91cCA9IGZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IGNyZWF0ZUVsZW1lbnQoUGFuZWxHcm91cFdpdGhGb3J3YXJkZWRSZWYsIHtcbiAgLi4ucHJvcHMsXG4gIGZvcndhcmRlZFJlZjogcmVmXG59KSk7XG5QYW5lbEdyb3VwV2l0aEZvcndhcmRlZFJlZi5kaXNwbGF5TmFtZSA9IFwiUGFuZWxHcm91cFwiO1xuUGFuZWxHcm91cC5kaXNwbGF5TmFtZSA9IFwiZm9yd2FyZFJlZihQYW5lbEdyb3VwKVwiO1xuXG5mdW5jdGlvbiBQYW5lbFJlc2l6ZUhhbmRsZSh7XG4gIGNoaWxkcmVuID0gbnVsbCxcbiAgY2xhc3NOYW1lOiBjbGFzc05hbWVGcm9tUHJvcHMgPSBcIlwiLFxuICBkaXNhYmxlZCA9IGZhbHNlLFxuICBpZDogaWRGcm9tUHJvcHMgPSBudWxsLFxuICBvbkRyYWdnaW5nLFxuICBzdHlsZTogc3R5bGVGcm9tUHJvcHMgPSB7fSxcbiAgdGFnTmFtZTogVHlwZSA9IFwiZGl2XCJcbn0pIHtcbiAgY29uc3QgZGl2RWxlbWVudFJlZiA9IHVzZVJlZihudWxsKTtcblxuICAvLyBVc2UgYSByZWYgdG8gZ3VhcmQgYWdhaW5zdCB1c2VycyBwYXNzaW5nIGlubGluZSBwcm9wc1xuICBjb25zdCBjYWxsYmFja3NSZWYgPSB1c2VSZWYoe1xuICAgIG9uRHJhZ2dpbmdcbiAgfSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY2FsbGJhY2tzUmVmLmN1cnJlbnQub25EcmFnZ2luZyA9IG9uRHJhZ2dpbmc7XG4gIH0pO1xuICBjb25zdCBwYW5lbEdyb3VwQ29udGV4dCA9IHVzZUNvbnRleHQoUGFuZWxHcm91cENvbnRleHQpO1xuICBpZiAocGFuZWxHcm91cENvbnRleHQgPT09IG51bGwpIHtcbiAgICB0aHJvdyBFcnJvcihgUGFuZWxSZXNpemVIYW5kbGUgY29tcG9uZW50cyBtdXN0IGJlIHJlbmRlcmVkIHdpdGhpbiBhIFBhbmVsR3JvdXAgY29udGFpbmVyYCk7XG4gIH1cbiAgY29uc3Qge1xuICAgIGFjdGl2ZUhhbmRsZUlkLFxuICAgIGRpcmVjdGlvbixcbiAgICBncm91cElkLFxuICAgIHJlZ2lzdGVyUmVzaXplSGFuZGxlLFxuICAgIHN0YXJ0RHJhZ2dpbmcsXG4gICAgc3RvcERyYWdnaW5nXG4gIH0gPSBwYW5lbEdyb3VwQ29udGV4dDtcbiAgY29uc3QgcmVzaXplSGFuZGxlSWQgPSB1c2VVbmlxdWVJZChpZEZyb21Qcm9wcyk7XG4gIGNvbnN0IGlzRHJhZ2dpbmcgPSBhY3RpdmVIYW5kbGVJZCA9PT0gcmVzaXplSGFuZGxlSWQ7XG4gIGNvbnN0IFtpc0ZvY3VzZWQsIHNldElzRm9jdXNlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtyZXNpemVIYW5kbGVyLCBzZXRSZXNpemVIYW5kbGVyXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBzdG9wRHJhZ2dpbmdBbmRCbHVyID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIC8vIENsaWNraW5nIG9uIHRoZSBkcmFnIGhhbmRsZSBzaG91bGRuJ3QgbGVhdmUgaXQgZm9jdXNlZDtcbiAgICAvLyBUaGF0IHdvdWxkIGNhdXNlIHRoZSBQYW5lbEdyb3VwIHRvIHRoaW5rIGl0IHdhcyBzdGlsbCBhY3RpdmUuXG4gICAgY29uc3QgZGl2ID0gZGl2RWxlbWVudFJlZi5jdXJyZW50O1xuICAgIGRpdi5ibHVyKCk7XG4gICAgc3RvcERyYWdnaW5nKCk7XG4gICAgY29uc3Qge1xuICAgICAgb25EcmFnZ2luZ1xuICAgIH0gPSBjYWxsYmFja3NSZWYuY3VycmVudDtcbiAgICBpZiAob25EcmFnZ2luZykge1xuICAgICAgb25EcmFnZ2luZyhmYWxzZSk7XG4gICAgfVxuICB9LCBbc3RvcERyYWdnaW5nXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICBzZXRSZXNpemVIYW5kbGVyKG51bGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByZXNpemVIYW5kbGVyID0gcmVnaXN0ZXJSZXNpemVIYW5kbGUocmVzaXplSGFuZGxlSWQpO1xuICAgICAgc2V0UmVzaXplSGFuZGxlcigoKSA9PiByZXNpemVIYW5kbGVyKTtcbiAgICB9XG4gIH0sIFtkaXNhYmxlZCwgcmVzaXplSGFuZGxlSWQsIHJlZ2lzdGVyUmVzaXplSGFuZGxlXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGRpc2FibGVkIHx8IHJlc2l6ZUhhbmRsZXIgPT0gbnVsbCB8fCAhaXNEcmFnZ2luZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvbk1vdmUgPSBldmVudCA9PiB7XG4gICAgICByZXNpemVIYW5kbGVyKGV2ZW50KTtcbiAgICB9O1xuICAgIGNvbnN0IG9uTW91c2VMZWF2ZSA9IGV2ZW50ID0+IHtcbiAgICAgIHJlc2l6ZUhhbmRsZXIoZXZlbnQpO1xuICAgIH07XG4gICAgY29uc3QgZGl2RWxlbWVudCA9IGRpdkVsZW1lbnRSZWYuY3VycmVudDtcbiAgICBjb25zdCB0YXJnZXREb2N1bWVudCA9IGRpdkVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgICB0YXJnZXREb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBzdG9wRHJhZ2dpbmdBbmRCbHVyKTtcbiAgICB0YXJnZXREb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgb25Nb3ZlKTtcbiAgICB0YXJnZXREb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgb25Nb3ZlKTtcbiAgICB0YXJnZXREb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIG9uTW91c2VMZWF2ZSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHN0b3BEcmFnZ2luZ0FuZEJsdXIpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgc3RvcERyYWdnaW5nQW5kQmx1cik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHRhcmdldERvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIHN0b3BEcmFnZ2luZ0FuZEJsdXIpO1xuICAgICAgdGFyZ2V0RG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIG9uTW92ZSk7XG4gICAgICB0YXJnZXREb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgb25Nb3ZlKTtcbiAgICAgIHRhcmdldERvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgb25Nb3VzZUxlYXZlKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBzdG9wRHJhZ2dpbmdBbmRCbHVyKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgc3RvcERyYWdnaW5nQW5kQmx1cik7XG4gICAgfTtcbiAgfSwgW2RpcmVjdGlvbiwgZGlzYWJsZWQsIGlzRHJhZ2dpbmcsIHJlc2l6ZUhhbmRsZXIsIHN0b3BEcmFnZ2luZ0FuZEJsdXJdKTtcbiAgdXNlV2luZG93U3BsaXR0ZXJSZXNpemVIYW5kbGVyQmVoYXZpb3Ioe1xuICAgIGRpc2FibGVkLFxuICAgIGhhbmRsZUlkOiByZXNpemVIYW5kbGVJZCxcbiAgICByZXNpemVIYW5kbGVyXG4gIH0pO1xuICBjb25zdCBzdHlsZSA9IHtcbiAgICBjdXJzb3I6IGdldEN1cnNvclN0eWxlKGRpcmVjdGlvbiksXG4gICAgdG91Y2hBY3Rpb246IFwibm9uZVwiLFxuICAgIHVzZXJTZWxlY3Q6IFwibm9uZVwiXG4gIH07XG4gIHJldHVybiBjcmVhdGVFbGVtZW50KFR5cGUsIHtcbiAgICBjaGlsZHJlbixcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZUZyb21Qcm9wcyxcbiAgICBcImRhdGEtcmVzaXplLWhhbmRsZS1hY3RpdmVcIjogaXNEcmFnZ2luZyA/IFwicG9pbnRlclwiIDogaXNGb2N1c2VkID8gXCJrZXlib2FyZFwiIDogdW5kZWZpbmVkLFxuICAgIFwiZGF0YS1wYW5lbC1ncm91cC1kaXJlY3Rpb25cIjogZGlyZWN0aW9uLFxuICAgIFwiZGF0YS1wYW5lbC1ncm91cC1pZFwiOiBncm91cElkLFxuICAgIFwiZGF0YS1wYW5lbC1yZXNpemUtaGFuZGxlLWVuYWJsZWRcIjogIWRpc2FibGVkLFxuICAgIFwiZGF0YS1wYW5lbC1yZXNpemUtaGFuZGxlLWlkXCI6IHJlc2l6ZUhhbmRsZUlkLFxuICAgIG9uQmx1cjogKCkgPT4gc2V0SXNGb2N1c2VkKGZhbHNlKSxcbiAgICBvbkZvY3VzOiAoKSA9PiBzZXRJc0ZvY3VzZWQodHJ1ZSksXG4gICAgb25Nb3VzZURvd246IGV2ZW50ID0+IHtcbiAgICAgIHN0YXJ0RHJhZ2dpbmcocmVzaXplSGFuZGxlSWQsIGV2ZW50Lm5hdGl2ZUV2ZW50KTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb25EcmFnZ2luZ1xuICAgICAgfSA9IGNhbGxiYWNrc1JlZi5jdXJyZW50O1xuICAgICAgaWYgKG9uRHJhZ2dpbmcpIHtcbiAgICAgICAgb25EcmFnZ2luZyh0cnVlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uTW91c2VVcDogc3RvcERyYWdnaW5nQW5kQmx1cixcbiAgICBvblRvdWNoQ2FuY2VsOiBzdG9wRHJhZ2dpbmdBbmRCbHVyLFxuICAgIG9uVG91Y2hFbmQ6IHN0b3BEcmFnZ2luZ0FuZEJsdXIsXG4gICAgb25Ub3VjaFN0YXJ0OiBldmVudCA9PiB7XG4gICAgICBzdGFydERyYWdnaW5nKHJlc2l6ZUhhbmRsZUlkLCBldmVudC5uYXRpdmVFdmVudCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG9uRHJhZ2dpbmdcbiAgICAgIH0gPSBjYWxsYmFja3NSZWYuY3VycmVudDtcbiAgICAgIGlmIChvbkRyYWdnaW5nKSB7XG4gICAgICAgIG9uRHJhZ2dpbmcodHJ1ZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICByZWY6IGRpdkVsZW1lbnRSZWYsXG4gICAgcm9sZTogXCJzZXBhcmF0b3JcIixcbiAgICBzdHlsZToge1xuICAgICAgLi4uc3R5bGUsXG4gICAgICAuLi5zdHlsZUZyb21Qcm9wc1xuICAgIH0sXG4gICAgdGFiSW5kZXg6IDBcbiAgfSk7XG59XG5QYW5lbFJlc2l6ZUhhbmRsZS5kaXNwbGF5TmFtZSA9IFwiUGFuZWxSZXNpemVIYW5kbGVcIjtcblxuZXhwb3J0IHsgUGFuZWwsIFBhbmVsR3JvdXAsIFBhbmVsUmVzaXplSGFuZGxlLCBnZXRBdmFpbGFibGVHcm91cFNpemVQaXhlbHMgfTtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsImNyZWF0ZUVsZW1lbnQiLCJjcmVhdGVDb250ZXh0IiwiZm9yd2FyZFJlZiIsInVzZUNhbGxiYWNrIiwidXNlQ29udGV4dCIsInVzZUVmZmVjdCIsInVzZUltcGVyYXRpdmVIYW5kbGUiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VNZW1vIiwidXNlUmVmIiwidXNlU3RhdGUiLCJ1c2VJZCIsInRvU3RyaW5nIiwid3JhcHBlZFVzZUlkIiwiY291bnRlciIsInVzZVVuaXF1ZUlkIiwiaWRGcm9tUGFyYW1zIiwiaWRGcm9tVXNlSWQiLCJpZFJlZiIsImN1cnJlbnQiLCJQYW5lbEdyb3VwQ29udGV4dCIsImRpc3BsYXlOYW1lIiwiUGFuZWxXaXRoRm9yd2FyZGVkUmVmIiwiY2hpbGRyZW4iLCJjbGFzc05hbWUiLCJjbGFzc05hbWVGcm9tUHJvcHMiLCJjb2xsYXBzZWRTaXplIiwiY29sbGFwc2libGUiLCJkZWZhdWx0U2l6ZSIsImZvcndhcmRlZFJlZiIsImlkIiwiaWRGcm9tUHJvcHMiLCJtYXhTaXplIiwibWluU2l6ZSIsIm9uQ29sbGFwc2UiLCJvblJlc2l6ZSIsIm9yZGVyIiwic3R5bGUiLCJzdHlsZUZyb21Qcm9wcyIsInRhZ05hbWUiLCJUeXBlIiwiY29udGV4dCIsIkVycm9yIiwicGFuZWxJZCIsImNvbGxhcHNlUGFuZWwiLCJleHBhbmRQYW5lbCIsImdldFBhbmVsU2l6ZSIsImdldFBhbmVsU3R5bGUiLCJyZWdpc3RlclBhbmVsIiwicmVzaXplUGFuZWwiLCJ1bml0cyIsInVucmVnaXN0ZXJQYW5lbCIsImNhbGxiYWNrc1JlZiIsImNvbW1pdHRlZFZhbHVlc1JlZiIsInNpemUiLCJwYXJzZVNpemVGcm9tU3R5bGUiLCJpZFdhc0F1dG9HZW5lcmF0ZWQiLCJjb2xsYXBzZSIsImV4cGFuZCIsImdldENvbGxhcHNlZCIsImdldElkIiwiZ2V0U2l6ZSIsInJlc2l6ZSIsInBlcmNlbnRhZ2UiLCJ1bmRlZmluZWQiLCJwYXJzZUZsb2F0IiwiZmxleEdyb3ciLCJ0b0ZpeGVkIiwiUGFuZWwiLCJwcm9wcyIsInJlZiIsIlBSRUNJU0lPTiIsImFkanVzdEJ5RGVsdGEiLCJldmVudCIsImNvbW1pdHRlZFZhbHVlcyIsImlkQmVmb3JlIiwiaWRBZnRlciIsImRlbHRhUGl4ZWxzIiwicHJldlNpemVzIiwicGFuZWxTaXplQmVmb3JlQ29sbGFwc2UiLCJpbml0aWFsRHJhZ1N0YXRlIiwiZ3JvdXBJZCIsInBhbmVscyIsImdyb3VwU2l6ZVBpeGVscyIsImdldEF2YWlsYWJsZUdyb3VwU2l6ZVBpeGVscyIsIk5hTiIsInNpemVzIiwiaW5pdGlhbFNpemVzIiwiYmFzZVNpemVzIiwicGFuZWxzQXJyYXkiLCJwYW5lbHNNYXBUb1NvcnRlZEFycmF5IiwibmV4dFNpemVzIiwiY29uY2F0IiwiZGVsdGFBcHBsaWVkIiwicGl2b3RJZCIsImluZGV4IiwiZmluZEluZGV4IiwicGFuZWwiLCJiYXNlU2l6ZSIsIm5leHRTaXplIiwic2FmZVJlc2l6ZVBhbmVsIiwiTWF0aCIsImFicyIsInNldCIsImRlbHRhUmVtYWluaW5nIiwidG9QcmVjaXNpb24iLCJsb2NhbGVDb21wYXJlIiwibnVtZXJpYyIsImxlbmd0aCIsImNhbGxQYW5lbENhbGxiYWNrcyIsInBhbmVsSWRUb0xhc3ROb3RpZmllZFNpemVNYXAiLCJmb3JFYWNoIiwicGFuZWxSZWYiLCJsYXN0Tm90aWZpZWRTaXplIiwiZ2V0QmVmb3JlQW5kQWZ0ZXJJZHMiLCJpc0xhc3RQYW5lbCIsInBhbmVsR3JvdXBFbGVtZW50IiwiZ2V0UGFuZWxHcm91cCIsImRpcmVjdGlvbiIsImdldEF0dHJpYnV0ZSIsInJlc2l6ZUhhbmRsZXMiLCJnZXRSZXNpemVIYW5kbGVzRm9yR3JvdXAiLCJvZmZzZXRXaWR0aCIsInJlZHVjZSIsImFjY3VtdWxhdGVkIiwiaGFuZGxlIiwib2Zmc2V0SGVpZ2h0IiwiZ2V0RmxleEdyb3ciLCJnZXRQYW5lbCIsImVsZW1lbnQiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJnZXRSZXNpemVIYW5kbGUiLCJnZXRSZXNpemVIYW5kbGVJbmRleCIsImhhbmRsZXMiLCJnZXRSZXNpemVIYW5kbGVzIiwiQXJyYXkiLCJmcm9tIiwicXVlcnlTZWxlY3RvckFsbCIsImdldFJlc2l6ZUhhbmRsZVBhbmVsSWRzIiwiaGFuZGxlSWQiLCJpbmRleE9mIiwidmFsdWVzIiwic29ydCIsInBhbmVsQSIsInBhbmVsQiIsIm9yZGVyQSIsIm9yZGVyQiIsInByZXZTaXplIiwiaXNLZXlib2FyZEV2ZW50IiwidHlwZSIsInN0YXJ0c1dpdGgiLCJtaW4iLCJtYXgiLCJ2YWxpZGF0ZVBhbmVsUHJvcHMiLCJwYW5lbERhdGEiLCJjb25zb2xlIiwiZXJyb3IiLCJ2YWxpZGF0ZVBhbmVsR3JvdXBMYXlvdXQiLCJyZW1haW5pbmdTaXplIiwic2FmZU5leHRTaXplIiwiYXNzZXJ0IiwiZXhwZWN0ZWRDb25kaXRpb24iLCJtZXNzYWdlIiwidXNlV2luZG93U3BsaXR0ZXJQYW5lbEdyb3VwQmVoYXZpb3IiLCJzZXRTaXplcyIsImdyb3VwRWxlbWVudCIsImhlaWdodCIsIndpZHRoIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiY2xlYW51cEZ1bmN0aW9ucyIsIm1hcCIsImN1cnJlbnRNaW5TaXplIiwiY3VycmVudE1heFNpemUiLCJ0b3RhbE1pblNpemUiLCJ0b3RhbE1heFNpemUiLCJhcmlhVmFsdWVNYXgiLCJhcmlhVmFsdWVNaW4iLCJzZXRBdHRyaWJ1dGUiLCJyb3VuZCIsInBhcnNlSW50Iiwib25LZXlEb3duIiwiZGVmYXVsdFByZXZlbnRlZCIsImtleSIsInByZXZlbnREZWZhdWx0IiwiZGVsdGEiLCJhZGRFdmVudExpc3RlbmVyIiwicGFuZWxCZWZvcmUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2xlYW51cEZ1bmN0aW9uIiwidXNlV2luZG93U3BsaXR0ZXJSZXNpemVIYW5kbGVyQmVoYXZpb3IiLCJkaXNhYmxlZCIsInJlc2l6ZUhhbmRsZXIiLCJoYW5kbGVFbGVtZW50IiwibmV4dEluZGV4Iiwic2hpZnRLZXkiLCJuZXh0SGFuZGxlIiwiZm9jdXMiLCJhcmVFcXVhbCIsImFycmF5QSIsImFycmF5QiIsImdldERyYWdPZmZzZXQiLCJpbml0aWFsT2Zmc2V0IiwiaW5pdGlhbEhhbmRsZUVsZW1lbnRSZWN0IiwiaXNIb3Jpem9udGFsIiwicG9pbnRlck9mZnNldCIsImlzTW91c2VFdmVudCIsImNsaWVudFgiLCJjbGllbnRZIiwiaXNUb3VjaEV2ZW50IiwiZmlyc3RUb3VjaCIsInRvdWNoZXMiLCJzY3JlZW5YIiwic2NyZWVuWSIsInJlY3QiLCJlbGVtZW50T2Zmc2V0IiwibGVmdCIsInRvcCIsImdldE1vdmVtZW50IiwiZHJhZ09mZnNldCIsImRyYWdIYW5kbGVSZWN0IiwiaXNLZXlEb3duIiwiZ3JvdXBTaXplSW5QaXhlbHMiLCJkZW5vbWluYXRvciIsIm1vdmVtZW50IiwidGFyZ2V0UGFuZWxJZCIsInRhcmdldFBhbmVsSW5kZXgiLCJ0YXJnZXRQYW5lbCIsImN1cnJlbnRTdGF0ZSIsImdldEN1cnNvclN0eWxlIiwic3RhdGUiLCJyZXNldEdsb2JhbEN1cnNvclN0eWxlIiwiaGVhZCIsInJlbW92ZUNoaWxkIiwic2V0R2xvYmFsQ3Vyc29yU3R5bGUiLCJhcHBlbmRDaGlsZCIsImlubmVySFRNTCIsImRlYm91bmNlIiwiY2FsbGJhY2siLCJkdXJhdGlvbk1zIiwidGltZW91dElkIiwiY2FsbGFibGUiLCJhcmdzIiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsImdldFNlcmlhbGl6YXRpb25LZXkiLCJhIiwiYiIsImpvaW4iLCJsb2FkU2VyaWFsaXplZFBhbmVsR3JvdXBTdGF0ZSIsImF1dG9TYXZlSWQiLCJzdG9yYWdlIiwic2VyaWFsaXplZCIsImdldEl0ZW0iLCJwYXJzZWQiLCJKU09OIiwicGFyc2UiLCJzYXZlUGFuZWxHcm91cExheW91dCIsInNldEl0ZW0iLCJzdHJpbmdpZnkiLCJkZWJvdW5jZU1hcCIsImluaXRpYWxpemVEZWZhdWx0U3RvcmFnZSIsInN0b3JhZ2VPYmplY3QiLCJsb2NhbFN0b3JhZ2UiLCJuYW1lIiwidmFsdWUiLCJkZWZhdWx0U3RvcmFnZSIsIlBhbmVsR3JvdXBXaXRoRm9yd2FyZGVkUmVmIiwiZGlzYWJsZVBvaW50ZXJFdmVudHNEdXJpbmdSZXNpemUiLCJvbkxheW91dCIsImFjdGl2ZUhhbmRsZUlkIiwic2V0QWN0aXZlSGFuZGxlSWQiLCJzZXRQYW5lbHMiLCJNYXAiLCJpbml0aWFsRHJhZ1N0YXRlUmVmIiwiZGV2V2FybmluZ3NSZWYiLCJkaWRMb2dEZWZhdWx0U2l6ZVdhcm5pbmciLCJkaWRMb2dJZEFuZE9yZGVyV2FybmluZyIsImRpZExvZ0ludmFsaWRMYXlvdXRXYXJuaW5nIiwicHJldlBhbmVsSWRzIiwicGFuZWxJZFRvTGFzdE5vdGlmaWVkU2l6ZU1hcFJlZiIsInByZXZEZWx0YVJlZiIsImdldExheW91dCIsInVuaXRzRnJvbVBhcmFtcyIsInVuaXRzRnJvbVByb3BzIiwic2V0TGF5b3V0IiwicGFuZWxJZHMiLCJrZXlzIiwicGFuZWxzSGF2ZUNoYW5nZWQiLCJmaW5kIiwid2FybiIsImZsZXhCYXNpcyIsImZsZXhTaHJpbmsiLCJvdmVyZmxvdyIsInBvaW50ZXJFdmVudHMiLCJwcmV2UGFuZWxzIiwiaGFzIiwibmV4dFBhbmVscyIsInJlZ2lzdGVyUmVzaXplSGFuZGxlIiwiZGlyIiwic2l6ZXNDaGFuZ2VkIiwiZGVsZXRlIiwiZ2V0IiwiY3VycmVudFNpemUiLCJzaXplQmVmb3JlQ29sbGFwc2UiLCJ1bnNhZmVOZXh0U2l6ZSIsInN0YXJ0RHJhZ2dpbmciLCJzdG9wRHJhZ2dpbmciLCJkaXNwbGF5IiwiZmxleERpcmVjdGlvbiIsIlByb3ZpZGVyIiwiUGFuZWxHcm91cCIsIlBhbmVsUmVzaXplSGFuZGxlIiwib25EcmFnZ2luZyIsImRpdkVsZW1lbnRSZWYiLCJwYW5lbEdyb3VwQ29udGV4dCIsInJlc2l6ZUhhbmRsZUlkIiwiaXNEcmFnZ2luZyIsImlzRm9jdXNlZCIsInNldElzRm9jdXNlZCIsInNldFJlc2l6ZUhhbmRsZXIiLCJzdG9wRHJhZ2dpbmdBbmRCbHVyIiwiZGl2IiwiYmx1ciIsIm9uTW92ZSIsIm9uTW91c2VMZWF2ZSIsImRpdkVsZW1lbnQiLCJ0YXJnZXREb2N1bWVudCIsIm93bmVyRG9jdW1lbnQiLCJib2R5Iiwid2luZG93IiwiY3Vyc29yIiwidG91Y2hBY3Rpb24iLCJ1c2VyU2VsZWN0Iiwib25CbHVyIiwib25Gb2N1cyIsIm9uTW91c2VEb3duIiwibmF0aXZlRXZlbnQiLCJvbk1vdXNlVXAiLCJvblRvdWNoQ2FuY2VsIiwib25Ub3VjaEVuZCIsIm9uVG91Y2hTdGFydCIsInJvbGUiLCJ0YWJJbmRleCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/react-resizable-panels@0.0.55_react-dom@18.2.0_react@18.2.0/node_modules/react-resizable-panels/dist/react-resizable-panels.development.node.esm.js\n");

/***/ })

};
;