"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mdast-util-from-markdown@1.3.1";
exports.ids = ["vendor-chunks/mdast-util-from-markdown@1.3.1"];
exports.modules = {

/***/ "(rsc)/../../node_modules/.pnpm/mdast-util-from-markdown@1.3.1/node_modules/mdast-util-from-markdown/dev/lib/index.js":
/*!**********************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/mdast-util-from-markdown@1.3.1/node_modules/mdast-util-from-markdown/dev/lib/index.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromMarkdown: () => (/* binding */ fromMarkdown)\n/* harmony export */ });\n/* harmony import */ var uvu_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uvu/assert */ \"(rsc)/../../node_modules/.pnpm/uvu@0.5.6/node_modules/uvu/assert/index.mjs\");\n/* harmony import */ var mdast_util_to_string__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! mdast-util-to-string */ \"(rsc)/../../node_modules/.pnpm/mdast-util-to-string@3.2.0/node_modules/mdast-util-to-string/lib/index.js\");\n/* harmony import */ var micromark_lib_parse_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! micromark/lib/parse.js */ \"(rsc)/../../node_modules/.pnpm/micromark@3.2.0/node_modules/micromark/dev/lib/parse.js\");\n/* harmony import */ var micromark_lib_preprocess_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! micromark/lib/preprocess.js */ \"(rsc)/../../node_modules/.pnpm/micromark@3.2.0/node_modules/micromark/dev/lib/preprocess.js\");\n/* harmony import */ var micromark_lib_postprocess_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark/lib/postprocess.js */ \"(rsc)/../../node_modules/.pnpm/micromark@3.2.0/node_modules/micromark/dev/lib/postprocess.js\");\n/* harmony import */ var micromark_util_decode_numeric_character_reference__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! micromark-util-decode-numeric-character-reference */ \"(rsc)/../../node_modules/.pnpm/micromark-util-decode-numeric-character-reference@1.1.0/node_modules/micromark-util-decode-numeric-character-reference/dev/index.js\");\n/* harmony import */ var micromark_util_decode_string__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! micromark-util-decode-string */ \"(rsc)/../../node_modules/.pnpm/micromark-util-decode-string@1.1.0/node_modules/micromark-util-decode-string/dev/index.js\");\n/* harmony import */ var micromark_util_normalize_identifier__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! micromark-util-normalize-identifier */ \"(rsc)/../../node_modules/.pnpm/micromark-util-normalize-identifier@1.1.0/node_modules/micromark-util-normalize-identifier/dev/index.js\");\n/* harmony import */ var micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! micromark-util-symbol/codes.js */ \"(rsc)/../../node_modules/.pnpm/micromark-util-symbol@1.1.0/node_modules/micromark-util-symbol/codes.js\");\n/* harmony import */ var micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! micromark-util-symbol/constants.js */ \"(rsc)/../../node_modules/.pnpm/micromark-util-symbol@1.1.0/node_modules/micromark-util-symbol/constants.js\");\n/* harmony import */ var micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! micromark-util-symbol/types.js */ \"(rsc)/../../node_modules/.pnpm/micromark-util-symbol@1.1.0/node_modules/micromark-util-symbol/types.js\");\n/* harmony import */ var decode_named_character_reference__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! decode-named-character-reference */ \"(rsc)/../../node_modules/.pnpm/decode-named-character-reference@1.0.2/node_modules/decode-named-character-reference/index.js\");\n/* harmony import */ var unist_util_stringify_position__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! unist-util-stringify-position */ \"(rsc)/../../node_modules/.pnpm/unist-util-stringify-position@3.0.3/node_modules/unist-util-stringify-position/lib/index.js\");\n/**\n * @typedef {import('micromark-util-types').Encoding} Encoding\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').ParseOptions} ParseOptions\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Value} Value\n *\n * @typedef {import('unist').Parent} UnistParent\n * @typedef {import('unist').Point} Point\n *\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n * @typedef {import('mdast').StaticPhrasingContent} StaticPhrasingContent\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').Break} Break\n * @typedef {import('mdast').Blockquote} Blockquote\n * @typedef {import('mdast').Code} Code\n * @typedef {import('mdast').Definition} Definition\n * @typedef {import('mdast').Emphasis} Emphasis\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('mdast').HTML} HTML\n * @typedef {import('mdast').Image} Image\n * @typedef {import('mdast').ImageReference} ImageReference\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('mdast').Link} Link\n * @typedef {import('mdast').LinkReference} LinkReference\n * @typedef {import('mdast').List} List\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Strong} Strong\n * @typedef {import('mdast').Text} Text\n * @typedef {import('mdast').ThematicBreak} ThematicBreak\n * @typedef {import('mdast').ReferenceType} ReferenceType\n * @typedef {import('../index.js').CompileData} CompileData\n */ /**\n * @typedef {Root | Content} Node\n * @typedef {Extract<Node, UnistParent>} Parent\n *\n * @typedef {Omit<UnistParent, 'type' | 'children'> & {type: 'fragment', children: Array<PhrasingContent>}} Fragment\n */ /**\n * @callback Transform\n *   Extra transform, to change the AST afterwards.\n * @param {Root} tree\n *   Tree to transform.\n * @returns {Root | undefined | null | void}\n *   New tree or nothing (in which case the current tree is used).\n *\n * @callback Handle\n *   Handle a token.\n * @param {CompileContext} this\n *   Context.\n * @param {Token} token\n *   Current token.\n * @returns {void}\n *   Nothing.\n *\n * @typedef {Record<string, Handle>} Handles\n *   Token types mapping to handles\n *\n * @callback OnEnterError\n *   Handle the case where the `right` token is open, but it is closed (by the\n *   `left` token) or because we reached the end of the document.\n * @param {Omit<CompileContext, 'sliceSerialize'>} this\n *   Context.\n * @param {Token | undefined} left\n *   Left token.\n * @param {Token} right\n *   Right token.\n * @returns {void}\n *   Nothing.\n *\n * @callback OnExitError\n *   Handle the case where the `right` token is open but it is closed by\n *   exiting the `left` token.\n * @param {Omit<CompileContext, 'sliceSerialize'>} this\n *   Context.\n * @param {Token} left\n *   Left token.\n * @param {Token} right\n *   Right token.\n * @returns {void}\n *   Nothing.\n *\n * @typedef {[Token, OnEnterError | undefined]} TokenTuple\n *   Open token on the stack, with an optional error handler for when\n *   that token isn’t closed properly.\n */ /**\n * @typedef Config\n *   Configuration.\n *\n *   We have our defaults, but extensions will add more.\n * @property {Array<string>} canContainEols\n *   Token types where line endings are used.\n * @property {Handles} enter\n *   Opening handles.\n * @property {Handles} exit\n *   Closing handles.\n * @property {Array<Transform>} transforms\n *   Tree transforms.\n *\n * @typedef {Partial<Config>} Extension\n *   Change how markdown tokens from micromark are turned into mdast.\n *\n * @typedef CompileContext\n *   mdast compiler context.\n * @property {Array<Node | Fragment>} stack\n *   Stack of nodes.\n * @property {Array<TokenTuple>} tokenStack\n *   Stack of tokens.\n * @property {<Key extends keyof CompileData>(key: Key) => CompileData[Key]} getData\n *   Get data from the key/value store.\n * @property {<Key extends keyof CompileData>(key: Key, value?: CompileData[Key]) => void} setData\n *   Set data into the key/value store.\n * @property {(this: CompileContext) => void} buffer\n *   Capture some of the output data.\n * @property {(this: CompileContext) => string} resume\n *   Stop capturing and access the output data.\n * @property {<Kind extends Node>(this: CompileContext, node: Kind, token: Token, onError?: OnEnterError) => Kind} enter\n *   Enter a token.\n * @property {(this: CompileContext, token: Token, onError?: OnExitError) => Node} exit\n *   Exit a token.\n * @property {TokenizeContext['sliceSerialize']} sliceSerialize\n *   Get the string value of a token.\n * @property {Config} config\n *   Configuration.\n *\n * @typedef FromMarkdownOptions\n *   Configuration for how to build mdast.\n * @property {Array<Extension | Array<Extension>> | null | undefined} [mdastExtensions]\n *   Extensions for this utility to change how tokens are turned into a tree.\n *\n * @typedef {ParseOptions & FromMarkdownOptions} Options\n *   Configuration.\n */ // To do: micromark: create a registry of tokens?\n// To do: next major: don’t return given `Node` from `enter`.\n// To do: next major: remove setter/getter.\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst own = {}.hasOwnProperty;\n/**\n * @param value\n *   Markdown to parse.\n * @param encoding\n *   Character encoding for when `value` is `Buffer`.\n * @param options\n *   Configuration.\n * @returns\n *   mdast tree.\n */ const fromMarkdown = /**\n   * @type {(\n   *   ((value: Value, encoding: Encoding, options?: Options | null | undefined) => Root) &\n   *   ((value: Value, options?: Options | null | undefined) => Root)\n   * )}\n   */ /**\n     * @param {Value} value\n     * @param {Encoding | Options | null | undefined} [encoding]\n     * @param {Options | null | undefined} [options]\n     * @returns {Root}\n     */ function(value, encoding, options) {\n    if (typeof encoding !== \"string\") {\n        options = encoding;\n        encoding = undefined;\n    }\n    return compiler(options)((0,micromark_lib_postprocess_js__WEBPACK_IMPORTED_MODULE_1__.postprocess)((0,micromark_lib_parse_js__WEBPACK_IMPORTED_MODULE_2__.parse)(options).document().write((0,micromark_lib_preprocess_js__WEBPACK_IMPORTED_MODULE_3__.preprocess)()(value, encoding, true))));\n};\n/**\n * Note this compiler only understand complete buffering, not streaming.\n *\n * @param {Options | null | undefined} [options]\n */ function compiler(options) {\n    /** @type {Config} */ const config = {\n        transforms: [],\n        canContainEols: [\n            \"emphasis\",\n            \"fragment\",\n            \"heading\",\n            \"paragraph\",\n            \"strong\"\n        ],\n        enter: {\n            autolink: opener(link),\n            autolinkProtocol: onenterdata,\n            autolinkEmail: onenterdata,\n            atxHeading: opener(heading),\n            blockQuote: opener(blockQuote),\n            characterEscape: onenterdata,\n            characterReference: onenterdata,\n            codeFenced: opener(codeFlow),\n            codeFencedFenceInfo: buffer,\n            codeFencedFenceMeta: buffer,\n            codeIndented: opener(codeFlow, buffer),\n            codeText: opener(codeText, buffer),\n            codeTextData: onenterdata,\n            data: onenterdata,\n            codeFlowValue: onenterdata,\n            definition: opener(definition),\n            definitionDestinationString: buffer,\n            definitionLabelString: buffer,\n            definitionTitleString: buffer,\n            emphasis: opener(emphasis),\n            hardBreakEscape: opener(hardBreak),\n            hardBreakTrailing: opener(hardBreak),\n            htmlFlow: opener(html, buffer),\n            htmlFlowData: onenterdata,\n            htmlText: opener(html, buffer),\n            htmlTextData: onenterdata,\n            image: opener(image),\n            label: buffer,\n            link: opener(link),\n            listItem: opener(listItem),\n            listItemValue: onenterlistitemvalue,\n            listOrdered: opener(list, onenterlistordered),\n            listUnordered: opener(list),\n            paragraph: opener(paragraph),\n            reference: onenterreference,\n            referenceString: buffer,\n            resourceDestinationString: buffer,\n            resourceTitleString: buffer,\n            setextHeading: opener(heading),\n            strong: opener(strong),\n            thematicBreak: opener(thematicBreak)\n        },\n        exit: {\n            atxHeading: closer(),\n            atxHeadingSequence: onexitatxheadingsequence,\n            autolink: closer(),\n            autolinkEmail: onexitautolinkemail,\n            autolinkProtocol: onexitautolinkprotocol,\n            blockQuote: closer(),\n            characterEscapeValue: onexitdata,\n            characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,\n            characterReferenceMarkerNumeric: onexitcharacterreferencemarker,\n            characterReferenceValue: onexitcharacterreferencevalue,\n            codeFenced: closer(onexitcodefenced),\n            codeFencedFence: onexitcodefencedfence,\n            codeFencedFenceInfo: onexitcodefencedfenceinfo,\n            codeFencedFenceMeta: onexitcodefencedfencemeta,\n            codeFlowValue: onexitdata,\n            codeIndented: closer(onexitcodeindented),\n            codeText: closer(onexitcodetext),\n            codeTextData: onexitdata,\n            data: onexitdata,\n            definition: closer(),\n            definitionDestinationString: onexitdefinitiondestinationstring,\n            definitionLabelString: onexitdefinitionlabelstring,\n            definitionTitleString: onexitdefinitiontitlestring,\n            emphasis: closer(),\n            hardBreakEscape: closer(onexithardbreak),\n            hardBreakTrailing: closer(onexithardbreak),\n            htmlFlow: closer(onexithtmlflow),\n            htmlFlowData: onexitdata,\n            htmlText: closer(onexithtmltext),\n            htmlTextData: onexitdata,\n            image: closer(onexitimage),\n            label: onexitlabel,\n            labelText: onexitlabeltext,\n            lineEnding: onexitlineending,\n            link: closer(onexitlink),\n            listItem: closer(),\n            listOrdered: closer(),\n            listUnordered: closer(),\n            paragraph: closer(),\n            referenceString: onexitreferencestring,\n            resourceDestinationString: onexitresourcedestinationstring,\n            resourceTitleString: onexitresourcetitlestring,\n            resource: onexitresource,\n            setextHeading: closer(onexitsetextheading),\n            setextHeadingLineSequence: onexitsetextheadinglinesequence,\n            setextHeadingText: onexitsetextheadingtext,\n            strong: closer(),\n            thematicBreak: closer()\n        }\n    };\n    configure(config, (options || {}).mdastExtensions || []);\n    /** @type {CompileData} */ const data = {};\n    return compile;\n    /**\n   * Turn micromark events into an mdast tree.\n   *\n   * @param {Array<Event>} events\n   *   Events.\n   * @returns {Root}\n   *   mdast tree.\n   */ function compile(events) {\n        /** @type {Root} */ let tree = {\n            type: \"root\",\n            children: []\n        };\n        /** @type {Omit<CompileContext, 'sliceSerialize'>} */ const context = {\n            stack: [\n                tree\n            ],\n            tokenStack: [],\n            config,\n            enter,\n            exit,\n            buffer,\n            resume,\n            setData,\n            getData\n        };\n        /** @type {Array<number>} */ const listStack = [];\n        let index = -1;\n        while(++index < events.length){\n            // We preprocess lists to add `listItem` tokens, and to infer whether\n            // items the list itself are spread out.\n            if (events[index][1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listOrdered || events[index][1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listUnordered) {\n                if (events[index][0] === \"enter\") {\n                    listStack.push(index);\n                } else {\n                    const tail = listStack.pop();\n                    (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(typeof tail === \"number\", \"expected list ot be open\");\n                    index = prepareList(events, tail, index);\n                }\n            }\n        }\n        index = -1;\n        while(++index < events.length){\n            const handler = config[events[index][0]];\n            if (own.call(handler, events[index][1].type)) {\n                handler[events[index][1].type].call(Object.assign({\n                    sliceSerialize: events[index][2].sliceSerialize\n                }, context), events[index][1]);\n            }\n        }\n        // Handle tokens still being open.\n        if (context.tokenStack.length > 0) {\n            const tail = context.tokenStack[context.tokenStack.length - 1];\n            const handler = tail[1] || defaultOnError;\n            handler.call(context, undefined, tail[0]);\n        }\n        // Figure out `root` position.\n        tree.position = {\n            start: point(events.length > 0 ? events[0][1].start : {\n                line: 1,\n                column: 1,\n                offset: 0\n            }),\n            end: point(events.length > 0 ? events[events.length - 2][1].end : {\n                line: 1,\n                column: 1,\n                offset: 0\n            })\n        };\n        // Call transforms.\n        index = -1;\n        while(++index < config.transforms.length){\n            tree = config.transforms[index](tree) || tree;\n        }\n        return tree;\n    }\n    /**\n   * @param {Array<Event>} events\n   * @param {number} start\n   * @param {number} length\n   * @returns {number}\n   */ function prepareList(events, start, length) {\n        let index = start - 1;\n        let containerBalance = -1;\n        let listSpread = false;\n        /** @type {Token | undefined} */ let listItem;\n        /** @type {number | undefined} */ let lineIndex;\n        /** @type {number | undefined} */ let firstBlankLineIndex;\n        /** @type {boolean | undefined} */ let atMarker;\n        while(++index <= length){\n            const event = events[index];\n            if (event[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listUnordered || event[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listOrdered || event[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.blockQuote) {\n                if (event[0] === \"enter\") {\n                    containerBalance++;\n                } else {\n                    containerBalance--;\n                }\n                atMarker = undefined;\n            } else if (event[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.lineEndingBlank) {\n                if (event[0] === \"enter\") {\n                    if (listItem && !atMarker && !containerBalance && !firstBlankLineIndex) {\n                        firstBlankLineIndex = index;\n                    }\n                    atMarker = undefined;\n                }\n            } else if (event[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.linePrefix || event[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listItemValue || event[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listItemMarker || event[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listItemPrefix || event[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listItemPrefixWhitespace) {\n            // Empty.\n            } else {\n                atMarker = undefined;\n            }\n            if (!containerBalance && event[0] === \"enter\" && event[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listItemPrefix || containerBalance === -1 && event[0] === \"exit\" && (event[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listUnordered || event[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listOrdered)) {\n                if (listItem) {\n                    let tailIndex = index;\n                    lineIndex = undefined;\n                    while(tailIndex--){\n                        const tailEvent = events[tailIndex];\n                        if (tailEvent[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.lineEnding || tailEvent[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.lineEndingBlank) {\n                            if (tailEvent[0] === \"exit\") continue;\n                            if (lineIndex) {\n                                events[lineIndex][1].type = micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.lineEndingBlank;\n                                listSpread = true;\n                            }\n                            tailEvent[1].type = micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.lineEnding;\n                            lineIndex = tailIndex;\n                        } else if (tailEvent[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.linePrefix || tailEvent[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.blockQuotePrefix || tailEvent[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.blockQuotePrefixWhitespace || tailEvent[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.blockQuoteMarker || tailEvent[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listItemIndent) {\n                        // Empty\n                        } else {\n                            break;\n                        }\n                    }\n                    if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {\n                        listItem._spread = true;\n                    }\n                    // Fix position.\n                    listItem.end = Object.assign({}, lineIndex ? events[lineIndex][1].start : event[1].end);\n                    events.splice(lineIndex || index, 0, [\n                        \"exit\",\n                        listItem,\n                        event[2]\n                    ]);\n                    index++;\n                    length++;\n                }\n                // Create a new list item.\n                if (event[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listItemPrefix) {\n                    listItem = {\n                        type: \"listItem\",\n                        _spread: false,\n                        start: Object.assign({}, event[1].start),\n                        // @ts-expect-error: we’ll add `end` in a second.\n                        end: undefined\n                    };\n                    // @ts-expect-error: `listItem` is most definitely defined, TS...\n                    events.splice(index, 0, [\n                        \"enter\",\n                        listItem,\n                        event[2]\n                    ]);\n                    index++;\n                    length++;\n                    firstBlankLineIndex = undefined;\n                    atMarker = true;\n                }\n            }\n        }\n        events[start][1]._spread = listSpread;\n        return length;\n    }\n    /**\n   * Set data.\n   *\n   * @template {keyof CompileData} Key\n   *   Field type.\n   * @param {Key} key\n   *   Key of field.\n   * @param {CompileData[Key]} [value]\n   *   New value.\n   * @returns {void}\n   *   Nothing.\n   */ function setData(key, value) {\n        data[key] = value;\n    }\n    /**\n   * Get data.\n   *\n   * @template {keyof CompileData} Key\n   *   Field type.\n   * @param {Key} key\n   *   Key of field.\n   * @returns {CompileData[Key]}\n   *   Value.\n   */ function getData(key) {\n        return data[key];\n    }\n    /**\n   * Create an opener handle.\n   *\n   * @param {(token: Token) => Node} create\n   *   Create a node.\n   * @param {Handle} [and]\n   *   Optional function to also run.\n   * @returns {Handle}\n   *   Handle.\n   */ function opener(create, and) {\n        return open;\n        /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {void}\n     */ function open(token) {\n            enter.call(this, create(token), token);\n            if (and) and.call(this, token);\n        }\n    }\n    /**\n   * @this {CompileContext}\n   * @returns {void}\n   */ function buffer() {\n        this.stack.push({\n            type: \"fragment\",\n            children: []\n        });\n    }\n    /**\n   * @template {Node} Kind\n   *   Node type.\n   * @this {CompileContext}\n   *   Context.\n   * @param {Kind} node\n   *   Node to enter.\n   * @param {Token} token\n   *   Corresponding token.\n   * @param {OnEnterError | undefined} [errorHandler]\n   *   Handle the case where this token is open, but it is closed by something else.\n   * @returns {Kind}\n   *   The given node.\n   */ function enter(node, token, errorHandler) {\n        const parent = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(parent, \"expected `parent`\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(\"children\" in parent, \"expected `parent`\");\n        // @ts-expect-error: Assume `Node` can exist as a child of `parent`.\n        parent.children.push(node);\n        this.stack.push(node);\n        this.tokenStack.push([\n            token,\n            errorHandler\n        ]);\n        // @ts-expect-error: `end` will be patched later.\n        node.position = {\n            start: point(token.start)\n        };\n        return node;\n    }\n    /**\n   * Create a closer handle.\n   *\n   * @param {Handle} [and]\n   *   Optional function to also run.\n   * @returns {Handle}\n   *   Handle.\n   */ function closer(and) {\n        return close;\n        /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {void}\n     */ function close(token) {\n            if (and) and.call(this, token);\n            exit.call(this, token);\n        }\n    }\n    /**\n   * @this {CompileContext}\n   *   Context.\n   * @param {Token} token\n   *   Corresponding token.\n   * @param {OnExitError | undefined} [onExitError]\n   *   Handle the case where another token is open.\n   * @returns {Node}\n   *   The closed node.\n   */ function exit(token, onExitError) {\n        const node = this.stack.pop();\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected `node`\");\n        const open = this.tokenStack.pop();\n        if (!open) {\n            throw new Error(\"Cannot close `\" + token.type + \"` (\" + (0,unist_util_stringify_position__WEBPACK_IMPORTED_MODULE_5__.stringifyPosition)({\n                start: token.start,\n                end: token.end\n            }) + \"): it’s not open\");\n        } else if (open[0].type !== token.type) {\n            if (onExitError) {\n                onExitError.call(this, token, open[0]);\n            } else {\n                const handler = open[1] || defaultOnError;\n                handler.call(this, token, open[0]);\n            }\n        }\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type !== \"fragment\", \"unexpected fragment `exit`ed\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.position, \"expected `position` to be defined\");\n        node.position.end = point(token.end);\n        return node;\n    }\n    /**\n   * @this {CompileContext}\n   * @returns {string}\n   */ function resume() {\n        return (0,mdast_util_to_string__WEBPACK_IMPORTED_MODULE_6__.toString)(this.stack.pop());\n    }\n    //\n    // Handlers.\n    //\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onenterlistordered() {\n        setData(\"expectingFirstListItemValue\", true);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onenterlistitemvalue(token) {\n        if (getData(\"expectingFirstListItemValue\")) {\n            const ancestor = this.stack[this.stack.length - 2];\n            (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(ancestor, \"expected nodes on stack\");\n            (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(ancestor.type === \"list\", \"expected list on stack\");\n            ancestor.start = Number.parseInt(this.sliceSerialize(token), micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_7__.constants.numericBaseDecimal);\n            setData(\"expectingFirstListItemValue\");\n        }\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcodefencedfenceinfo() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"code\", \"expected code on stack\");\n        node.lang = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcodefencedfencemeta() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"code\", \"expected code on stack\");\n        node.meta = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcodefencedfence() {\n        // Exit if this is the closing fence.\n        if (getData(\"flowCodeInside\")) return;\n        this.buffer();\n        setData(\"flowCodeInside\", true);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcodefenced() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"code\", \"expected code on stack\");\n        node.value = data.replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, \"\");\n        setData(\"flowCodeInside\");\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcodeindented() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"code\", \"expected code on stack\");\n        node.value = data.replace(/(\\r?\\n|\\r)$/g, \"\");\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitdefinitionlabelstring(token) {\n        const label = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"definition\", \"expected definition on stack\");\n        node.label = label;\n        node.identifier = (0,micromark_util_normalize_identifier__WEBPACK_IMPORTED_MODULE_8__.normalizeIdentifier)(this.sliceSerialize(token)).toLowerCase();\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitdefinitiontitlestring() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"definition\", \"expected definition on stack\");\n        node.title = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitdefinitiondestinationstring() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"definition\", \"expected definition on stack\");\n        node.url = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitatxheadingsequence(token) {\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"heading\", \"expected heading on stack\");\n        if (!node.depth) {\n            const depth = this.sliceSerialize(token).length;\n            (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(depth === 1 || depth === 2 || depth === 3 || depth === 4 || depth === 5 || depth === 6, \"expected `depth` between `1` and `6`\");\n            node.depth = depth;\n        }\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitsetextheadingtext() {\n        setData(\"setextHeadingSlurpLineEnding\", true);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitsetextheadinglinesequence(token) {\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"heading\", \"expected heading on stack\");\n        node.depth = this.sliceSerialize(token).charCodeAt(0) === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_9__.codes.equalsTo ? 1 : 2;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitsetextheading() {\n        setData(\"setextHeadingSlurpLineEnding\");\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onenterdata(token) {\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(\"children\" in node, \"expected parent on stack\");\n        let tail = node.children[node.children.length - 1];\n        if (!tail || tail.type !== \"text\") {\n            // Add a new text node.\n            tail = text();\n            // @ts-expect-error: we’ll add `end` later.\n            tail.position = {\n                start: point(token.start)\n            };\n            // @ts-expect-error: Assume `parent` accepts `text`.\n            node.children.push(tail);\n        }\n        this.stack.push(tail);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitdata(token) {\n        const tail = this.stack.pop();\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(tail, \"expected a `node` to be on the stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(\"value\" in tail, \"expected a `literal` to be on the stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(tail.position, \"expected `node` to have an open position\");\n        tail.value += this.sliceSerialize(token);\n        tail.position.end = point(token.end);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitlineending(token) {\n        const context = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(context, \"expected `node`\");\n        // If we’re at a hard break, include the line ending in there.\n        if (getData(\"atHardBreak\")) {\n            (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(\"children\" in context, \"expected `parent`\");\n            const tail = context.children[context.children.length - 1];\n            (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(tail.position, \"expected tail to have a starting position\");\n            tail.position.end = point(token.end);\n            setData(\"atHardBreak\");\n            return;\n        }\n        if (!getData(\"setextHeadingSlurpLineEnding\") && config.canContainEols.includes(context.type)) {\n            onenterdata.call(this, token);\n            onexitdata.call(this, token);\n        }\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexithardbreak() {\n        setData(\"atHardBreak\", true);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexithtmlflow() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"html\", \"expected html on stack\");\n        node.value = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexithtmltext() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"html\", \"expected html on stack\");\n        node.value = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcodetext() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"inlineCode\", \"expected inline code on stack\");\n        node.value = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitlink() {\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"link\", \"expected link on stack\");\n        // Note: there are also `identifier` and `label` fields on this link node!\n        // These are used / cleaned here.\n        // To do: clean.\n        if (getData(\"inReference\")) {\n            /** @type {ReferenceType} */ const referenceType = getData(\"referenceType\") || \"shortcut\";\n            node.type += \"Reference\";\n            // @ts-expect-error: mutate.\n            node.referenceType = referenceType;\n            // @ts-expect-error: mutate.\n            delete node.url;\n            delete node.title;\n        } else {\n            // @ts-expect-error: mutate.\n            delete node.identifier;\n            // @ts-expect-error: mutate.\n            delete node.label;\n        }\n        setData(\"referenceType\");\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitimage() {\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"image\", \"expected image on stack\");\n        // Note: there are also `identifier` and `label` fields on this link node!\n        // These are used / cleaned here.\n        // To do: clean.\n        if (getData(\"inReference\")) {\n            /** @type {ReferenceType} */ const referenceType = getData(\"referenceType\") || \"shortcut\";\n            node.type += \"Reference\";\n            // @ts-expect-error: mutate.\n            node.referenceType = referenceType;\n            // @ts-expect-error: mutate.\n            delete node.url;\n            delete node.title;\n        } else {\n            // @ts-expect-error: mutate.\n            delete node.identifier;\n            // @ts-expect-error: mutate.\n            delete node.label;\n        }\n        setData(\"referenceType\");\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitlabeltext(token) {\n        const string = this.sliceSerialize(token);\n        const ancestor = this.stack[this.stack.length - 2];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(ancestor, \"expected ancestor on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(ancestor.type === \"image\" || ancestor.type === \"link\", \"expected image or link on stack\");\n        // @ts-expect-error: stash this on the node, as it might become a reference\n        // later.\n        ancestor.label = (0,micromark_util_decode_string__WEBPACK_IMPORTED_MODULE_10__.decodeString)(string);\n        // @ts-expect-error: same as above.\n        ancestor.identifier = (0,micromark_util_normalize_identifier__WEBPACK_IMPORTED_MODULE_8__.normalizeIdentifier)(string).toLowerCase();\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitlabel() {\n        const fragment = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(fragment, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(fragment.type === \"fragment\", \"expected fragment on stack\");\n        const value = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"image\" || node.type === \"link\", \"expected image or link on stack\");\n        // Assume a reference.\n        setData(\"inReference\", true);\n        if (node.type === \"link\") {\n            /** @type {Array<StaticPhrasingContent>} */ // @ts-expect-error: Assume static phrasing content.\n            const children = fragment.children;\n            node.children = children;\n        } else {\n            node.alt = value;\n        }\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitresourcedestinationstring() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"image\" || node.type === \"link\", \"expected image or link on stack\");\n        node.url = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitresourcetitlestring() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"image\" || node.type === \"link\", \"expected image or link on stack\");\n        node.title = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitresource() {\n        setData(\"inReference\");\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onenterreference() {\n        setData(\"referenceType\", \"collapsed\");\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitreferencestring(token) {\n        const label = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"image\" || node.type === \"link\", \"expected image reference or link reference on stack\");\n        // @ts-expect-error: stash this on the node, as it might become a reference\n        // later.\n        node.label = label;\n        // @ts-expect-error: same as above.\n        node.identifier = (0,micromark_util_normalize_identifier__WEBPACK_IMPORTED_MODULE_8__.normalizeIdentifier)(this.sliceSerialize(token)).toLowerCase();\n        setData(\"referenceType\", \"full\");\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcharacterreferencemarker(token) {\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(token.type === \"characterReferenceMarkerNumeric\" || token.type === \"characterReferenceMarkerHexadecimal\");\n        setData(\"characterReferenceType\", token.type);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcharacterreferencevalue(token) {\n        const data = this.sliceSerialize(token);\n        const type = getData(\"characterReferenceType\");\n        /** @type {string} */ let value;\n        if (type) {\n            value = (0,micromark_util_decode_numeric_character_reference__WEBPACK_IMPORTED_MODULE_11__.decodeNumericCharacterReference)(data, type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.characterReferenceMarkerNumeric ? micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_7__.constants.numericBaseDecimal : micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_7__.constants.numericBaseHexadecimal);\n            setData(\"characterReferenceType\");\n        } else {\n            const result = (0,decode_named_character_reference__WEBPACK_IMPORTED_MODULE_12__.decodeNamedCharacterReference)(data);\n            (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(result !== false, \"expected reference to decode\");\n            value = result;\n        }\n        const tail = this.stack.pop();\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(tail, \"expected `node`\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(tail.position, \"expected `node.position`\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(\"value\" in tail, \"expected `node.value`\");\n        tail.value += value;\n        tail.position.end = point(token.end);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitautolinkprotocol(token) {\n        onexitdata.call(this, token);\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"link\", \"expected link on stack\");\n        node.url = this.sliceSerialize(token);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitautolinkemail(token) {\n        onexitdata.call(this, token);\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"link\", \"expected link on stack\");\n        node.url = \"mailto:\" + this.sliceSerialize(token);\n    }\n    //\n    // Creaters.\n    //\n    /** @returns {Blockquote} */ function blockQuote() {\n        return {\n            type: \"blockquote\",\n            children: []\n        };\n    }\n    /** @returns {Code} */ function codeFlow() {\n        return {\n            type: \"code\",\n            lang: null,\n            meta: null,\n            value: \"\"\n        };\n    }\n    /** @returns {InlineCode} */ function codeText() {\n        return {\n            type: \"inlineCode\",\n            value: \"\"\n        };\n    }\n    /** @returns {Definition} */ function definition() {\n        return {\n            type: \"definition\",\n            identifier: \"\",\n            label: null,\n            title: null,\n            url: \"\"\n        };\n    }\n    /** @returns {Emphasis} */ function emphasis() {\n        return {\n            type: \"emphasis\",\n            children: []\n        };\n    }\n    /** @returns {Heading} */ function heading() {\n        // @ts-expect-error `depth` will be set later.\n        return {\n            type: \"heading\",\n            depth: undefined,\n            children: []\n        };\n    }\n    /** @returns {Break} */ function hardBreak() {\n        return {\n            type: \"break\"\n        };\n    }\n    /** @returns {HTML} */ function html() {\n        return {\n            type: \"html\",\n            value: \"\"\n        };\n    }\n    /** @returns {Image} */ function image() {\n        return {\n            type: \"image\",\n            title: null,\n            url: \"\",\n            alt: null\n        };\n    }\n    /** @returns {Link} */ function link() {\n        return {\n            type: \"link\",\n            title: null,\n            url: \"\",\n            children: []\n        };\n    }\n    /**\n   * @param {Token} token\n   * @returns {List}\n   */ function list(token) {\n        return {\n            type: \"list\",\n            ordered: token.type === \"listOrdered\",\n            start: null,\n            spread: token._spread,\n            children: []\n        };\n    }\n    /**\n   * @param {Token} token\n   * @returns {ListItem}\n   */ function listItem(token) {\n        return {\n            type: \"listItem\",\n            spread: token._spread,\n            checked: null,\n            children: []\n        };\n    }\n    /** @returns {Paragraph} */ function paragraph() {\n        return {\n            type: \"paragraph\",\n            children: []\n        };\n    }\n    /** @returns {Strong} */ function strong() {\n        return {\n            type: \"strong\",\n            children: []\n        };\n    }\n    /** @returns {Text} */ function text() {\n        return {\n            type: \"text\",\n            value: \"\"\n        };\n    }\n    /** @returns {ThematicBreak} */ function thematicBreak() {\n        return {\n            type: \"thematicBreak\"\n        };\n    }\n}\n/**\n * Copy a point-like value.\n *\n * @param {Point} d\n *   Point-like value.\n * @returns {Point}\n *   unist point.\n */ function point(d) {\n    return {\n        line: d.line,\n        column: d.column,\n        offset: d.offset\n    };\n}\n/**\n * @param {Config} combined\n * @param {Array<Extension | Array<Extension>>} extensions\n * @returns {void}\n */ function configure(combined, extensions) {\n    let index = -1;\n    while(++index < extensions.length){\n        const value = extensions[index];\n        if (Array.isArray(value)) {\n            configure(combined, value);\n        } else {\n            extension(combined, value);\n        }\n    }\n}\n/**\n * @param {Config} combined\n * @param {Extension} extension\n * @returns {void}\n */ function extension(combined, extension) {\n    /** @type {keyof Extension} */ let key;\n    for(key in extension){\n        if (own.call(extension, key)) {\n            if (key === \"canContainEols\") {\n                const right = extension[key];\n                if (right) {\n                    combined[key].push(...right);\n                }\n            } else if (key === \"transforms\") {\n                const right = extension[key];\n                if (right) {\n                    combined[key].push(...right);\n                }\n            } else if (key === \"enter\" || key === \"exit\") {\n                const right = extension[key];\n                if (right) {\n                    Object.assign(combined[key], right);\n                }\n            }\n        }\n    }\n}\n/** @type {OnEnterError} */ function defaultOnError(left, right) {\n    if (left) {\n        throw new Error(\"Cannot close `\" + left.type + \"` (\" + (0,unist_util_stringify_position__WEBPACK_IMPORTED_MODULE_5__.stringifyPosition)({\n            start: left.start,\n            end: left.end\n        }) + \"): a different token (`\" + right.type + \"`, \" + (0,unist_util_stringify_position__WEBPACK_IMPORTED_MODULE_5__.stringifyPosition)({\n            start: right.start,\n            end: right.end\n        }) + \") is open\");\n    } else {\n        throw new Error(\"Cannot close document, a token (`\" + right.type + \"`, \" + (0,unist_util_stringify_position__WEBPACK_IMPORTED_MODULE_5__.stringifyPosition)({\n            start: right.start,\n            end: right.end\n        }) + \") is still open\");\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21kYXN0LXV0aWwtZnJvbS1tYXJrZG93bkAxLjMuMS9ub2RlX21vZHVsZXMvbWRhc3QtdXRpbC1mcm9tLW1hcmtkb3duL2Rldi9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FtQ0MsR0FFRDs7Ozs7Q0FLQyxHQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQStDQyxHQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQStDQyxHQUVELGlEQUFpRDtBQUNqRCw2REFBNkQ7QUFDN0QsMkNBQTJDO0FBRUo7QUFDTTtBQUNEO0FBQ1U7QUFDRTtBQUN5QztBQUN4QztBQUNjO0FBQ25CO0FBQ1E7QUFDUjtBQUMwQjtBQUNmO0FBRS9ELE1BQU1jLE1BQU0sQ0FBQyxFQUFFQyxjQUFjO0FBRTdCOzs7Ozs7Ozs7Q0FTQyxHQUNNLE1BQU1DLGVBQ1g7Ozs7O0dBS0MsR0FFQzs7Ozs7S0FLQyxHQUNELFNBQVVDLEtBQUssRUFBRUMsUUFBUSxFQUFFQyxPQUFPO0lBQ2hDLElBQUksT0FBT0QsYUFBYSxVQUFVO1FBQ2hDQyxVQUFVRDtRQUNWQSxXQUFXRTtJQUNiO0lBRUEsT0FBT0MsU0FBU0YsU0FDZGQseUVBQVdBLENBQ1RGLDZEQUFLQSxDQUFDZ0IsU0FBU0csUUFBUSxHQUFHQyxLQUFLLENBQUNuQix1RUFBVUEsR0FBR2EsT0FBT0MsVUFBVTtBQUdwRSxFQUNEO0FBRUg7Ozs7Q0FJQyxHQUNELFNBQVNHLFNBQVNGLE9BQU87SUFDdkIsbUJBQW1CLEdBQ25CLE1BQU1LLFNBQVM7UUFDYkMsWUFBWSxFQUFFO1FBQ2RDLGdCQUFnQjtZQUFDO1lBQVk7WUFBWTtZQUFXO1lBQWE7U0FBUztRQUMxRUMsT0FBTztZQUNMQyxVQUFVQyxPQUFP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IjpbIndlYnBhY2s6Ly9oYXdhLWRvY3MvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21kYXN0LXV0aWwtZnJvbS1tYXJrZG93bkAxLjMuMS9ub2RlX21vZHVsZXMvbWRhc3QtdXRpbC1mcm9tLW1hcmtkb3duL2Rldi9saWIvaW5kZXguanM/ZjMzOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuRW5jb2Rpbmd9IEVuY29kaW5nXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkV2ZW50fSBFdmVudFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5QYXJzZU9wdGlvbnN9IFBhcnNlT3B0aW9uc1xuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Ub2tlbn0gVG9rZW5cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVG9rZW5pemVDb250ZXh0fSBUb2tlbml6ZUNvbnRleHRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVmFsdWV9IFZhbHVlXG4gKlxuICogQHR5cGVkZWYge2ltcG9ydCgndW5pc3QnKS5QYXJlbnR9IFVuaXN0UGFyZW50XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCd1bmlzdCcpLlBvaW50fSBQb2ludFxuICpcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuUGhyYXNpbmdDb250ZW50fSBQaHJhc2luZ0NvbnRlbnRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuU3RhdGljUGhyYXNpbmdDb250ZW50fSBTdGF0aWNQaHJhc2luZ0NvbnRlbnRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuQ29udGVudH0gQ29udGVudFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5CcmVha30gQnJlYWtcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuQmxvY2txdW90ZX0gQmxvY2txdW90ZVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5Db2RlfSBDb2RlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLkRlZmluaXRpb259IERlZmluaXRpb25cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuRW1waGFzaXN9IEVtcGhhc2lzXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLkhlYWRpbmd9IEhlYWRpbmdcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuSFRNTH0gSFRNTFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5JbWFnZX0gSW1hZ2VcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuSW1hZ2VSZWZlcmVuY2V9IEltYWdlUmVmZXJlbmNlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLklubGluZUNvZGV9IElubGluZUNvZGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuTGlua30gTGlua1xuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5MaW5rUmVmZXJlbmNlfSBMaW5rUmVmZXJlbmNlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLkxpc3R9IExpc3RcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuTGlzdEl0ZW19IExpc3RJdGVtXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLlBhcmFncmFwaH0gUGFyYWdyYXBoXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLlJvb3R9IFJvb3RcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuU3Ryb25nfSBTdHJvbmdcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuVGV4dH0gVGV4dFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5UaGVtYXRpY0JyZWFrfSBUaGVtYXRpY0JyZWFrXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLlJlZmVyZW5jZVR5cGV9IFJlZmVyZW5jZVR5cGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL2luZGV4LmpzJykuQ29tcGlsZURhdGF9IENvbXBpbGVEYXRhXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7Um9vdCB8IENvbnRlbnR9IE5vZGVcbiAqIEB0eXBlZGVmIHtFeHRyYWN0PE5vZGUsIFVuaXN0UGFyZW50Pn0gUGFyZW50XG4gKlxuICogQHR5cGVkZWYge09taXQ8VW5pc3RQYXJlbnQsICd0eXBlJyB8ICdjaGlsZHJlbic+ICYge3R5cGU6ICdmcmFnbWVudCcsIGNoaWxkcmVuOiBBcnJheTxQaHJhc2luZ0NvbnRlbnQ+fX0gRnJhZ21lbnRcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBUcmFuc2Zvcm1cbiAqICAgRXh0cmEgdHJhbnNmb3JtLCB0byBjaGFuZ2UgdGhlIEFTVCBhZnRlcndhcmRzLlxuICogQHBhcmFtIHtSb290fSB0cmVlXG4gKiAgIFRyZWUgdG8gdHJhbnNmb3JtLlxuICogQHJldHVybnMge1Jvb3QgfCB1bmRlZmluZWQgfCBudWxsIHwgdm9pZH1cbiAqICAgTmV3IHRyZWUgb3Igbm90aGluZyAoaW4gd2hpY2ggY2FzZSB0aGUgY3VycmVudCB0cmVlIGlzIHVzZWQpLlxuICpcbiAqIEBjYWxsYmFjayBIYW5kbGVcbiAqICAgSGFuZGxlIGEgdG9rZW4uXG4gKiBAcGFyYW0ge0NvbXBpbGVDb250ZXh0fSB0aGlzXG4gKiAgIENvbnRleHQuXG4gKiBAcGFyYW0ge1Rva2VufSB0b2tlblxuICogICBDdXJyZW50IHRva2VuLlxuICogQHJldHVybnMge3ZvaWR9XG4gKiAgIE5vdGhpbmcuXG4gKlxuICogQHR5cGVkZWYge1JlY29yZDxzdHJpbmcsIEhhbmRsZT59IEhhbmRsZXNcbiAqICAgVG9rZW4gdHlwZXMgbWFwcGluZyB0byBoYW5kbGVzXG4gKlxuICogQGNhbGxiYWNrIE9uRW50ZXJFcnJvclxuICogICBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgdGhlIGByaWdodGAgdG9rZW4gaXMgb3BlbiwgYnV0IGl0IGlzIGNsb3NlZCAoYnkgdGhlXG4gKiAgIGBsZWZ0YCB0b2tlbikgb3IgYmVjYXVzZSB3ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50LlxuICogQHBhcmFtIHtPbWl0PENvbXBpbGVDb250ZXh0LCAnc2xpY2VTZXJpYWxpemUnPn0gdGhpc1xuICogICBDb250ZXh0LlxuICogQHBhcmFtIHtUb2tlbiB8IHVuZGVmaW5lZH0gbGVmdFxuICogICBMZWZ0IHRva2VuLlxuICogQHBhcmFtIHtUb2tlbn0gcmlnaHRcbiAqICAgUmlnaHQgdG9rZW4uXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqICAgTm90aGluZy5cbiAqXG4gKiBAY2FsbGJhY2sgT25FeGl0RXJyb3JcbiAqICAgSGFuZGxlIHRoZSBjYXNlIHdoZXJlIHRoZSBgcmlnaHRgIHRva2VuIGlzIG9wZW4gYnV0IGl0IGlzIGNsb3NlZCBieVxuICogICBleGl0aW5nIHRoZSBgbGVmdGAgdG9rZW4uXG4gKiBAcGFyYW0ge09taXQ8Q29tcGlsZUNvbnRleHQsICdzbGljZVNlcmlhbGl6ZSc+fSB0aGlzXG4gKiAgIENvbnRleHQuXG4gKiBAcGFyYW0ge1Rva2VufSBsZWZ0XG4gKiAgIExlZnQgdG9rZW4uXG4gKiBAcGFyYW0ge1Rva2VufSByaWdodFxuICogICBSaWdodCB0b2tlbi5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICogICBOb3RoaW5nLlxuICpcbiAqIEB0eXBlZGVmIHtbVG9rZW4sIE9uRW50ZXJFcnJvciB8IHVuZGVmaW5lZF19IFRva2VuVHVwbGVcbiAqICAgT3BlbiB0b2tlbiBvbiB0aGUgc3RhY2ssIHdpdGggYW4gb3B0aW9uYWwgZXJyb3IgaGFuZGxlciBmb3Igd2hlblxuICogICB0aGF0IHRva2VuIGlzbuKAmXQgY2xvc2VkIHByb3Blcmx5LlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgQ29uZmlnXG4gKiAgIENvbmZpZ3VyYXRpb24uXG4gKlxuICogICBXZSBoYXZlIG91ciBkZWZhdWx0cywgYnV0IGV4dGVuc2lvbnMgd2lsbCBhZGQgbW9yZS5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8c3RyaW5nPn0gY2FuQ29udGFpbkVvbHNcbiAqICAgVG9rZW4gdHlwZXMgd2hlcmUgbGluZSBlbmRpbmdzIGFyZSB1c2VkLlxuICogQHByb3BlcnR5IHtIYW5kbGVzfSBlbnRlclxuICogICBPcGVuaW5nIGhhbmRsZXMuXG4gKiBAcHJvcGVydHkge0hhbmRsZXN9IGV4aXRcbiAqICAgQ2xvc2luZyBoYW5kbGVzLlxuICogQHByb3BlcnR5IHtBcnJheTxUcmFuc2Zvcm0+fSB0cmFuc2Zvcm1zXG4gKiAgIFRyZWUgdHJhbnNmb3Jtcy5cbiAqXG4gKiBAdHlwZWRlZiB7UGFydGlhbDxDb25maWc+fSBFeHRlbnNpb25cbiAqICAgQ2hhbmdlIGhvdyBtYXJrZG93biB0b2tlbnMgZnJvbSBtaWNyb21hcmsgYXJlIHR1cm5lZCBpbnRvIG1kYXN0LlxuICpcbiAqIEB0eXBlZGVmIENvbXBpbGVDb250ZXh0XG4gKiAgIG1kYXN0IGNvbXBpbGVyIGNvbnRleHQuXG4gKiBAcHJvcGVydHkge0FycmF5PE5vZGUgfCBGcmFnbWVudD59IHN0YWNrXG4gKiAgIFN0YWNrIG9mIG5vZGVzLlxuICogQHByb3BlcnR5IHtBcnJheTxUb2tlblR1cGxlPn0gdG9rZW5TdGFja1xuICogICBTdGFjayBvZiB0b2tlbnMuXG4gKiBAcHJvcGVydHkgezxLZXkgZXh0ZW5kcyBrZXlvZiBDb21waWxlRGF0YT4oa2V5OiBLZXkpID0+IENvbXBpbGVEYXRhW0tleV19IGdldERhdGFcbiAqICAgR2V0IGRhdGEgZnJvbSB0aGUga2V5L3ZhbHVlIHN0b3JlLlxuICogQHByb3BlcnR5IHs8S2V5IGV4dGVuZHMga2V5b2YgQ29tcGlsZURhdGE+KGtleTogS2V5LCB2YWx1ZT86IENvbXBpbGVEYXRhW0tleV0pID0+IHZvaWR9IHNldERhdGFcbiAqICAgU2V0IGRhdGEgaW50byB0aGUga2V5L3ZhbHVlIHN0b3JlLlxuICogQHByb3BlcnR5IHsodGhpczogQ29tcGlsZUNvbnRleHQpID0+IHZvaWR9IGJ1ZmZlclxuICogICBDYXB0dXJlIHNvbWUgb2YgdGhlIG91dHB1dCBkYXRhLlxuICogQHByb3BlcnR5IHsodGhpczogQ29tcGlsZUNvbnRleHQpID0+IHN0cmluZ30gcmVzdW1lXG4gKiAgIFN0b3AgY2FwdHVyaW5nIGFuZCBhY2Nlc3MgdGhlIG91dHB1dCBkYXRhLlxuICogQHByb3BlcnR5IHs8S2luZCBleHRlbmRzIE5vZGU+KHRoaXM6IENvbXBpbGVDb250ZXh0LCBub2RlOiBLaW5kLCB0b2tlbjogVG9rZW4sIG9uRXJyb3I/OiBPbkVudGVyRXJyb3IpID0+IEtpbmR9IGVudGVyXG4gKiAgIEVudGVyIGEgdG9rZW4uXG4gKiBAcHJvcGVydHkgeyh0aGlzOiBDb21waWxlQ29udGV4dCwgdG9rZW46IFRva2VuLCBvbkVycm9yPzogT25FeGl0RXJyb3IpID0+IE5vZGV9IGV4aXRcbiAqICAgRXhpdCBhIHRva2VuLlxuICogQHByb3BlcnR5IHtUb2tlbml6ZUNvbnRleHRbJ3NsaWNlU2VyaWFsaXplJ119IHNsaWNlU2VyaWFsaXplXG4gKiAgIEdldCB0aGUgc3RyaW5nIHZhbHVlIG9mIGEgdG9rZW4uXG4gKiBAcHJvcGVydHkge0NvbmZpZ30gY29uZmlnXG4gKiAgIENvbmZpZ3VyYXRpb24uXG4gKlxuICogQHR5cGVkZWYgRnJvbU1hcmtkb3duT3B0aW9uc1xuICogICBDb25maWd1cmF0aW9uIGZvciBob3cgdG8gYnVpbGQgbWRhc3QuXG4gKiBAcHJvcGVydHkge0FycmF5PEV4dGVuc2lvbiB8IEFycmF5PEV4dGVuc2lvbj4+IHwgbnVsbCB8IHVuZGVmaW5lZH0gW21kYXN0RXh0ZW5zaW9uc11cbiAqICAgRXh0ZW5zaW9ucyBmb3IgdGhpcyB1dGlsaXR5IHRvIGNoYW5nZSBob3cgdG9rZW5zIGFyZSB0dXJuZWQgaW50byBhIHRyZWUuXG4gKlxuICogQHR5cGVkZWYge1BhcnNlT3B0aW9ucyAmIEZyb21NYXJrZG93bk9wdGlvbnN9IE9wdGlvbnNcbiAqICAgQ29uZmlndXJhdGlvbi5cbiAqL1xuXG4vLyBUbyBkbzogbWljcm9tYXJrOiBjcmVhdGUgYSByZWdpc3RyeSBvZiB0b2tlbnM/XG4vLyBUbyBkbzogbmV4dCBtYWpvcjogZG9u4oCZdCByZXR1cm4gZ2l2ZW4gYE5vZGVgIGZyb20gYGVudGVyYC5cbi8vIFRvIGRvOiBuZXh0IG1ham9yOiByZW1vdmUgc2V0dGVyL2dldHRlci5cblxuaW1wb3J0IHtvayBhcyBhc3NlcnR9IGZyb20gJ3V2dS9hc3NlcnQnXG5pbXBvcnQge3RvU3RyaW5nfSBmcm9tICdtZGFzdC11dGlsLXRvLXN0cmluZydcbmltcG9ydCB7cGFyc2V9IGZyb20gJ21pY3JvbWFyay9saWIvcGFyc2UuanMnXG5pbXBvcnQge3ByZXByb2Nlc3N9IGZyb20gJ21pY3JvbWFyay9saWIvcHJlcHJvY2Vzcy5qcydcbmltcG9ydCB7cG9zdHByb2Nlc3N9IGZyb20gJ21pY3JvbWFyay9saWIvcG9zdHByb2Nlc3MuanMnXG5pbXBvcnQge2RlY29kZU51bWVyaWNDaGFyYWN0ZXJSZWZlcmVuY2V9IGZyb20gJ21pY3JvbWFyay11dGlsLWRlY29kZS1udW1lcmljLWNoYXJhY3Rlci1yZWZlcmVuY2UnXG5pbXBvcnQge2RlY29kZVN0cmluZ30gZnJvbSAnbWljcm9tYXJrLXV0aWwtZGVjb2RlLXN0cmluZydcbmltcG9ydCB7bm9ybWFsaXplSWRlbnRpZmllcn0gZnJvbSAnbWljcm9tYXJrLXV0aWwtbm9ybWFsaXplLWlkZW50aWZpZXInXG5pbXBvcnQge2NvZGVzfSBmcm9tICdtaWNyb21hcmstdXRpbC1zeW1ib2wvY29kZXMuanMnXG5pbXBvcnQge2NvbnN0YW50c30gZnJvbSAnbWljcm9tYXJrLXV0aWwtc3ltYm9sL2NvbnN0YW50cy5qcydcbmltcG9ydCB7dHlwZXN9IGZyb20gJ21pY3JvbWFyay11dGlsLXN5bWJvbC90eXBlcy5qcydcbmltcG9ydCB7ZGVjb2RlTmFtZWRDaGFyYWN0ZXJSZWZlcmVuY2V9IGZyb20gJ2RlY29kZS1uYW1lZC1jaGFyYWN0ZXItcmVmZXJlbmNlJ1xuaW1wb3J0IHtzdHJpbmdpZnlQb3NpdGlvbn0gZnJvbSAndW5pc3QtdXRpbC1zdHJpbmdpZnktcG9zaXRpb24nXG5cbmNvbnN0IG93biA9IHt9Lmhhc093blByb3BlcnR5XG5cbi8qKlxuICogQHBhcmFtIHZhbHVlXG4gKiAgIE1hcmtkb3duIHRvIHBhcnNlLlxuICogQHBhcmFtIGVuY29kaW5nXG4gKiAgIENoYXJhY3RlciBlbmNvZGluZyBmb3Igd2hlbiBgdmFsdWVgIGlzIGBCdWZmZXJgLlxuICogQHBhcmFtIG9wdGlvbnNcbiAqICAgQ29uZmlndXJhdGlvbi5cbiAqIEByZXR1cm5zXG4gKiAgIG1kYXN0IHRyZWUuXG4gKi9cbmV4cG9ydCBjb25zdCBmcm9tTWFya2Rvd24gPVxuICAvKipcbiAgICogQHR5cGUgeyhcbiAgICogICAoKHZhbHVlOiBWYWx1ZSwgZW5jb2Rpbmc6IEVuY29kaW5nLCBvcHRpb25zPzogT3B0aW9ucyB8IG51bGwgfCB1bmRlZmluZWQpID0+IFJvb3QpICZcbiAgICogICAoKHZhbHVlOiBWYWx1ZSwgb3B0aW9ucz86IE9wdGlvbnMgfCBudWxsIHwgdW5kZWZpbmVkKSA9PiBSb290KVxuICAgKiApfVxuICAgKi9cbiAgKFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VmFsdWV9IHZhbHVlXG4gICAgICogQHBhcmFtIHtFbmNvZGluZyB8IE9wdGlvbnMgfCBudWxsIHwgdW5kZWZpbmVkfSBbZW5jb2RpbmddXG4gICAgICogQHBhcmFtIHtPcHRpb25zIHwgbnVsbCB8IHVuZGVmaW5lZH0gW29wdGlvbnNdXG4gICAgICogQHJldHVybnMge1Jvb3R9XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZywgb3B0aW9ucykge1xuICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgb3B0aW9ucyA9IGVuY29kaW5nXG4gICAgICAgIGVuY29kaW5nID0gdW5kZWZpbmVkXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb21waWxlcihvcHRpb25zKShcbiAgICAgICAgcG9zdHByb2Nlc3MoXG4gICAgICAgICAgcGFyc2Uob3B0aW9ucykuZG9jdW1lbnQoKS53cml0ZShwcmVwcm9jZXNzKCkodmFsdWUsIGVuY29kaW5nLCB0cnVlKSlcbiAgICAgICAgKVxuICAgICAgKVxuICAgIH1cbiAgKVxuXG4vKipcbiAqIE5vdGUgdGhpcyBjb21waWxlciBvbmx5IHVuZGVyc3RhbmQgY29tcGxldGUgYnVmZmVyaW5nLCBub3Qgc3RyZWFtaW5nLlxuICpcbiAqIEBwYXJhbSB7T3B0aW9ucyB8IG51bGwgfCB1bmRlZmluZWR9IFtvcHRpb25zXVxuICovXG5mdW5jdGlvbiBjb21waWxlcihvcHRpb25zKSB7XG4gIC8qKiBAdHlwZSB7Q29uZmlnfSAqL1xuICBjb25zdCBjb25maWcgPSB7XG4gICAgdHJhbnNmb3JtczogW10sXG4gICAgY2FuQ29udGFpbkVvbHM6IFsnZW1waGFzaXMnLCAnZnJhZ21lbnQnLCAnaGVhZGluZycsICdwYXJhZ3JhcGgnLCAnc3Ryb25nJ10sXG4gICAgZW50ZXI6IHtcbiAgICAgIGF1dG9saW5rOiBvcGVuZXIobGluayksXG4gICAgICBhdXRvbGlua1Byb3RvY29sOiBvbmVudGVyZGF0YSxcbiAgICAgIGF1dG9saW5rRW1haWw6IG9uZW50ZXJkYXRhLFxuICAgICAgYXR4SGVhZGluZzogb3BlbmVyKGhlYWRpbmcpLFxuICAgICAgYmxvY2tRdW90ZTogb3BlbmVyKGJsb2NrUXVvdGUpLFxuICAgICAgY2hhcmFjdGVyRXNjYXBlOiBvbmVudGVyZGF0YSxcbiAgICAgIGNoYXJhY3RlclJlZmVyZW5jZTogb25lbnRlcmRhdGEsXG4gICAgICBjb2RlRmVuY2VkOiBvcGVuZXIoY29kZUZsb3cpLFxuICAgICAgY29kZUZlbmNlZEZlbmNlSW5mbzogYnVmZmVyLFxuICAgICAgY29kZUZlbmNlZEZlbmNlTWV0YTogYnVmZmVyLFxuICAgICAgY29kZUluZGVudGVkOiBvcGVuZXIoY29kZUZsb3csIGJ1ZmZlciksXG4gICAgICBjb2RlVGV4dDogb3BlbmVyKGNvZGVUZXh0LCBidWZmZXIpLFxuICAgICAgY29kZVRleHREYXRhOiBvbmVudGVyZGF0YSxcbiAgICAgIGRhdGE6IG9uZW50ZXJkYXRhLFxuICAgICAgY29kZUZsb3dWYWx1ZTogb25lbnRlcmRhdGEsXG4gICAgICBkZWZpbml0aW9uOiBvcGVuZXIoZGVmaW5pdGlvbiksXG4gICAgICBkZWZpbml0aW9uRGVzdGluYXRpb25TdHJpbmc6IGJ1ZmZlcixcbiAgICAgIGRlZmluaXRpb25MYWJlbFN0cmluZzogYnVmZmVyLFxuICAgICAgZGVmaW5pdGlvblRpdGxlU3RyaW5nOiBidWZmZXIsXG4gICAgICBlbXBoYXNpczogb3BlbmVyKGVtcGhhc2lzKSxcbiAgICAgIGhhcmRCcmVha0VzY2FwZTogb3BlbmVyKGhhcmRCcmVhayksXG4gICAgICBoYXJkQnJlYWtUcmFpbGluZzogb3BlbmVyKGhhcmRCcmVhayksXG4gICAgICBodG1sRmxvdzogb3BlbmVyKGh0bWwsIGJ1ZmZlciksXG4gICAgICBodG1sRmxvd0RhdGE6IG9uZW50ZXJkYXRhLFxuICAgICAgaHRtbFRleHQ6IG9wZW5lcihodG1sLCBidWZmZXIpLFxuICAgICAgaHRtbFRleHREYXRhOiBvbmVudGVyZGF0YSxcbiAgICAgIGltYWdlOiBvcGVuZXIoaW1hZ2UpLFxuICAgICAgbGFiZWw6IGJ1ZmZlcixcbiAgICAgIGxpbms6IG9wZW5lcihsaW5rKSxcbiAgICAgIGxpc3RJdGVtOiBvcGVuZXIobGlzdEl0ZW0pLFxuICAgICAgbGlzdEl0ZW1WYWx1ZTogb25lbnRlcmxpc3RpdGVtdmFsdWUsXG4gICAgICBsaXN0T3JkZXJlZDogb3BlbmVyKGxpc3QsIG9uZW50ZXJsaXN0b3JkZXJlZCksXG4gICAgICBsaXN0VW5vcmRlcmVkOiBvcGVuZXIobGlzdCksXG4gICAgICBwYXJhZ3JhcGg6IG9wZW5lcihwYXJhZ3JhcGgpLFxuICAgICAgcmVmZXJlbmNlOiBvbmVudGVycmVmZXJlbmNlLFxuICAgICAgcmVmZXJlbmNlU3RyaW5nOiBidWZmZXIsXG4gICAgICByZXNvdXJjZURlc3RpbmF0aW9uU3RyaW5nOiBidWZmZXIsXG4gICAgICByZXNvdXJjZVRpdGxlU3RyaW5nOiBidWZmZXIsXG4gICAgICBzZXRleHRIZWFkaW5nOiBvcGVuZXIoaGVhZGluZyksXG4gICAgICBzdHJvbmc6IG9wZW5lcihzdHJvbmcpLFxuICAgICAgdGhlbWF0aWNCcmVhazogb3BlbmVyKHRoZW1hdGljQnJlYWspXG4gICAgfSxcbiAgICBleGl0OiB7XG4gICAgICBhdHhIZWFkaW5nOiBjbG9zZXIoKSxcbiAgICAgIGF0eEhlYWRpbmdTZXF1ZW5jZTogb25leGl0YXR4aGVhZGluZ3NlcXVlbmNlLFxuICAgICAgYXV0b2xpbms6IGNsb3NlcigpLFxuICAgICAgYXV0b2xpbmtFbWFpbDogb25leGl0YXV0b2xpbmtlbWFpbCxcbiAgICAgIGF1dG9saW5rUHJvdG9jb2w6IG9uZXhpdGF1dG9saW5rcHJvdG9jb2wsXG4gICAgICBibG9ja1F1b3RlOiBjbG9zZXIoKSxcbiAgICAgIGNoYXJhY3RlckVzY2FwZVZhbHVlOiBvbmV4aXRkYXRhLFxuICAgICAgY2hhcmFjdGVyUmVmZXJlbmNlTWFya2VySGV4YWRlY2ltYWw6IG9uZXhpdGNoYXJhY3RlcnJlZmVyZW5jZW1hcmtlcixcbiAgICAgIGNoYXJhY3RlclJlZmVyZW5jZU1hcmtlck51bWVyaWM6IG9uZXhpdGNoYXJhY3RlcnJlZmVyZW5jZW1hcmtlcixcbiAgICAgIGNoYXJhY3RlclJlZmVyZW5jZVZhbHVlOiBvbmV4aXRjaGFyYWN0ZXJyZWZlcmVuY2V2YWx1ZSxcbiAgICAgIGNvZGVGZW5jZWQ6IGNsb3NlcihvbmV4aXRjb2RlZmVuY2VkKSxcbiAgICAgIGNvZGVGZW5jZWRGZW5jZTogb25leGl0Y29kZWZlbmNlZGZlbmNlLFxuICAgICAgY29kZUZlbmNlZEZlbmNlSW5mbzogb25leGl0Y29kZWZlbmNlZGZlbmNlaW5mbyxcbiAgICAgIGNvZGVGZW5jZWRGZW5jZU1ldGE6IG9uZXhpdGNvZGVmZW5jZWRmZW5jZW1ldGEsXG4gICAgICBjb2RlRmxvd1ZhbHVlOiBvbmV4aXRkYXRhLFxuICAgICAgY29kZUluZGVudGVkOiBjbG9zZXIob25leGl0Y29kZWluZGVudGVkKSxcbiAgICAgIGNvZGVUZXh0OiBjbG9zZXIob25leGl0Y29kZXRleHQpLFxuICAgICAgY29kZVRleHREYXRhOiBvbmV4aXRkYXRhLFxuICAgICAgZGF0YTogb25leGl0ZGF0YSxcbiAgICAgIGRlZmluaXRpb246IGNsb3NlcigpLFxuICAgICAgZGVmaW5pdGlvbkRlc3RpbmF0aW9uU3RyaW5nOiBvbmV4aXRkZWZpbml0aW9uZGVzdGluYXRpb25zdHJpbmcsXG4gICAgICBkZWZpbml0aW9uTGFiZWxTdHJpbmc6IG9uZXhpdGRlZmluaXRpb25sYWJlbHN0cmluZyxcbiAgICAgIGRlZmluaXRpb25UaXRsZVN0cmluZzogb25leGl0ZGVmaW5pdGlvbnRpdGxlc3RyaW5nLFxuICAgICAgZW1waGFzaXM6IGNsb3NlcigpLFxuICAgICAgaGFyZEJyZWFrRXNjYXBlOiBjbG9zZXIob25leGl0aGFyZGJyZWFrKSxcbiAgICAgIGhhcmRCcmVha1RyYWlsaW5nOiBjbG9zZXIob25leGl0aGFyZGJyZWFrKSxcbiAgICAgIGh0bWxGbG93OiBjbG9zZXIob25leGl0aHRtbGZsb3cpLFxuICAgICAgaHRtbEZsb3dEYXRhOiBvbmV4aXRkYXRhLFxuICAgICAgaHRtbFRleHQ6IGNsb3NlcihvbmV4aXRodG1sdGV4dCksXG4gICAgICBodG1sVGV4dERhdGE6IG9uZXhpdGRhdGEsXG4gICAgICBpbWFnZTogY2xvc2VyKG9uZXhpdGltYWdlKSxcbiAgICAgIGxhYmVsOiBvbmV4aXRsYWJlbCxcbiAgICAgIGxhYmVsVGV4dDogb25leGl0bGFiZWx0ZXh0LFxuICAgICAgbGluZUVuZGluZzogb25leGl0bGluZWVuZGluZyxcbiAgICAgIGxpbms6IGNsb3NlcihvbmV4aXRsaW5rKSxcbiAgICAgIGxpc3RJdGVtOiBjbG9zZXIoKSxcbiAgICAgIGxpc3RPcmRlcmVkOiBjbG9zZXIoKSxcbiAgICAgIGxpc3RVbm9yZGVyZWQ6IGNsb3NlcigpLFxuICAgICAgcGFyYWdyYXBoOiBjbG9zZXIoKSxcbiAgICAgIHJlZmVyZW5jZVN0cmluZzogb25leGl0cmVmZXJlbmNlc3RyaW5nLFxuICAgICAgcmVzb3VyY2VEZXN0aW5hdGlvblN0cmluZzogb25leGl0cmVzb3VyY2VkZXN0aW5hdGlvbnN0cmluZyxcbiAgICAgIHJlc291cmNlVGl0bGVTdHJpbmc6IG9uZXhpdHJlc291cmNldGl0bGVzdHJpbmcsXG4gICAgICByZXNvdXJjZTogb25leGl0cmVzb3VyY2UsXG4gICAgICBzZXRleHRIZWFkaW5nOiBjbG9zZXIob25leGl0c2V0ZXh0aGVhZGluZyksXG4gICAgICBzZXRleHRIZWFkaW5nTGluZVNlcXVlbmNlOiBvbmV4aXRzZXRleHRoZWFkaW5nbGluZXNlcXVlbmNlLFxuICAgICAgc2V0ZXh0SGVhZGluZ1RleHQ6IG9uZXhpdHNldGV4dGhlYWRpbmd0ZXh0LFxuICAgICAgc3Ryb25nOiBjbG9zZXIoKSxcbiAgICAgIHRoZW1hdGljQnJlYWs6IGNsb3NlcigpXG4gICAgfVxuICB9XG5cbiAgY29uZmlndXJlKGNvbmZpZywgKG9wdGlvbnMgfHwge30pLm1kYXN0RXh0ZW5zaW9ucyB8fCBbXSlcblxuICAvKiogQHR5cGUge0NvbXBpbGVEYXRhfSAqL1xuICBjb25zdCBkYXRhID0ge31cblxuICByZXR1cm4gY29tcGlsZVxuXG4gIC8qKlxuICAgKiBUdXJuIG1pY3JvbWFyayBldmVudHMgaW50byBhbiBtZGFzdCB0cmVlLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PEV2ZW50Pn0gZXZlbnRzXG4gICAqICAgRXZlbnRzLlxuICAgKiBAcmV0dXJucyB7Um9vdH1cbiAgICogICBtZGFzdCB0cmVlLlxuICAgKi9cbiAgZnVuY3Rpb24gY29tcGlsZShldmVudHMpIHtcbiAgICAvKiogQHR5cGUge1Jvb3R9ICovXG4gICAgbGV0IHRyZWUgPSB7dHlwZTogJ3Jvb3QnLCBjaGlsZHJlbjogW119XG4gICAgLyoqIEB0eXBlIHtPbWl0PENvbXBpbGVDb250ZXh0LCAnc2xpY2VTZXJpYWxpemUnPn0gKi9cbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgc3RhY2s6IFt0cmVlXSxcbiAgICAgIHRva2VuU3RhY2s6IFtdLFxuICAgICAgY29uZmlnLFxuICAgICAgZW50ZXIsXG4gICAgICBleGl0LFxuICAgICAgYnVmZmVyLFxuICAgICAgcmVzdW1lLFxuICAgICAgc2V0RGF0YSxcbiAgICAgIGdldERhdGFcbiAgICB9XG4gICAgLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqL1xuICAgIGNvbnN0IGxpc3RTdGFjayA9IFtdXG4gICAgbGV0IGluZGV4ID0gLTFcblxuICAgIHdoaWxlICgrK2luZGV4IDwgZXZlbnRzLmxlbmd0aCkge1xuICAgICAgLy8gV2UgcHJlcHJvY2VzcyBsaXN0cyB0byBhZGQgYGxpc3RJdGVtYCB0b2tlbnMsIGFuZCB0byBpbmZlciB3aGV0aGVyXG4gICAgICAvLyBpdGVtcyB0aGUgbGlzdCBpdHNlbGYgYXJlIHNwcmVhZCBvdXQuXG4gICAgICBpZiAoXG4gICAgICAgIGV2ZW50c1tpbmRleF1bMV0udHlwZSA9PT0gdHlwZXMubGlzdE9yZGVyZWQgfHxcbiAgICAgICAgZXZlbnRzW2luZGV4XVsxXS50eXBlID09PSB0eXBlcy5saXN0VW5vcmRlcmVkXG4gICAgICApIHtcbiAgICAgICAgaWYgKGV2ZW50c1tpbmRleF1bMF0gPT09ICdlbnRlcicpIHtcbiAgICAgICAgICBsaXN0U3RhY2sucHVzaChpbmRleClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCB0YWlsID0gbGlzdFN0YWNrLnBvcCgpXG4gICAgICAgICAgYXNzZXJ0KHR5cGVvZiB0YWlsID09PSAnbnVtYmVyJywgJ2V4cGVjdGVkIGxpc3Qgb3QgYmUgb3BlbicpXG4gICAgICAgICAgaW5kZXggPSBwcmVwYXJlTGlzdChldmVudHMsIHRhaWwsIGluZGV4KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW5kZXggPSAtMVxuXG4gICAgd2hpbGUgKCsraW5kZXggPCBldmVudHMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBoYW5kbGVyID0gY29uZmlnW2V2ZW50c1tpbmRleF1bMF1dXG5cbiAgICAgIGlmIChvd24uY2FsbChoYW5kbGVyLCBldmVudHNbaW5kZXhdWzFdLnR5cGUpKSB7XG4gICAgICAgIGhhbmRsZXJbZXZlbnRzW2luZGV4XVsxXS50eXBlXS5jYWxsKFxuICAgICAgICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICB7c2xpY2VTZXJpYWxpemU6IGV2ZW50c1tpbmRleF1bMl0uc2xpY2VTZXJpYWxpemV9LFxuICAgICAgICAgICAgY29udGV4dFxuICAgICAgICAgICksXG4gICAgICAgICAgZXZlbnRzW2luZGV4XVsxXVxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHRva2VucyBzdGlsbCBiZWluZyBvcGVuLlxuICAgIGlmIChjb250ZXh0LnRva2VuU3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgdGFpbCA9IGNvbnRleHQudG9rZW5TdGFja1tjb250ZXh0LnRva2VuU3RhY2subGVuZ3RoIC0gMV1cbiAgICAgIGNvbnN0IGhhbmRsZXIgPSB0YWlsWzFdIHx8IGRlZmF1bHRPbkVycm9yXG4gICAgICBoYW5kbGVyLmNhbGwoY29udGV4dCwgdW5kZWZpbmVkLCB0YWlsWzBdKVxuICAgIH1cblxuICAgIC8vIEZpZ3VyZSBvdXQgYHJvb3RgIHBvc2l0aW9uLlxuICAgIHRyZWUucG9zaXRpb24gPSB7XG4gICAgICBzdGFydDogcG9pbnQoXG4gICAgICAgIGV2ZW50cy5sZW5ndGggPiAwID8gZXZlbnRzWzBdWzFdLnN0YXJ0IDoge2xpbmU6IDEsIGNvbHVtbjogMSwgb2Zmc2V0OiAwfVxuICAgICAgKSxcbiAgICAgIGVuZDogcG9pbnQoXG4gICAgICAgIGV2ZW50cy5sZW5ndGggPiAwXG4gICAgICAgICAgPyBldmVudHNbZXZlbnRzLmxlbmd0aCAtIDJdWzFdLmVuZFxuICAgICAgICAgIDoge2xpbmU6IDEsIGNvbHVtbjogMSwgb2Zmc2V0OiAwfVxuICAgICAgKVxuICAgIH1cblxuICAgIC8vIENhbGwgdHJhbnNmb3Jtcy5cbiAgICBpbmRleCA9IC0xXG4gICAgd2hpbGUgKCsraW5kZXggPCBjb25maWcudHJhbnNmb3Jtcy5sZW5ndGgpIHtcbiAgICAgIHRyZWUgPSBjb25maWcudHJhbnNmb3Jtc1tpbmRleF0odHJlZSkgfHwgdHJlZVxuICAgIH1cblxuICAgIHJldHVybiB0cmVlXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxFdmVudD59IGV2ZW50c1xuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgZnVuY3Rpb24gcHJlcGFyZUxpc3QoZXZlbnRzLCBzdGFydCwgbGVuZ3RoKSB7XG4gICAgbGV0IGluZGV4ID0gc3RhcnQgLSAxXG4gICAgbGV0IGNvbnRhaW5lckJhbGFuY2UgPSAtMVxuICAgIGxldCBsaXN0U3ByZWFkID0gZmFsc2VcbiAgICAvKiogQHR5cGUge1Rva2VuIHwgdW5kZWZpbmVkfSAqL1xuICAgIGxldCBsaXN0SXRlbVxuICAgIC8qKiBAdHlwZSB7bnVtYmVyIHwgdW5kZWZpbmVkfSAqL1xuICAgIGxldCBsaW5lSW5kZXhcbiAgICAvKiogQHR5cGUge251bWJlciB8IHVuZGVmaW5lZH0gKi9cbiAgICBsZXQgZmlyc3RCbGFua0xpbmVJbmRleFxuICAgIC8qKiBAdHlwZSB7Ym9vbGVhbiB8IHVuZGVmaW5lZH0gKi9cbiAgICBsZXQgYXRNYXJrZXJcblxuICAgIHdoaWxlICgrK2luZGV4IDw9IGxlbmd0aCkge1xuICAgICAgY29uc3QgZXZlbnQgPSBldmVudHNbaW5kZXhdXG5cbiAgICAgIGlmIChcbiAgICAgICAgZXZlbnRbMV0udHlwZSA9PT0gdHlwZXMubGlzdFVub3JkZXJlZCB8fFxuICAgICAgICBldmVudFsxXS50eXBlID09PSB0eXBlcy5saXN0T3JkZXJlZCB8fFxuICAgICAgICBldmVudFsxXS50eXBlID09PSB0eXBlcy5ibG9ja1F1b3RlXG4gICAgICApIHtcbiAgICAgICAgaWYgKGV2ZW50WzBdID09PSAnZW50ZXInKSB7XG4gICAgICAgICAgY29udGFpbmVyQmFsYW5jZSsrXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGFpbmVyQmFsYW5jZS0tXG4gICAgICAgIH1cblxuICAgICAgICBhdE1hcmtlciA9IHVuZGVmaW5lZFxuICAgICAgfSBlbHNlIGlmIChldmVudFsxXS50eXBlID09PSB0eXBlcy5saW5lRW5kaW5nQmxhbmspIHtcbiAgICAgICAgaWYgKGV2ZW50WzBdID09PSAnZW50ZXInKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgbGlzdEl0ZW0gJiZcbiAgICAgICAgICAgICFhdE1hcmtlciAmJlxuICAgICAgICAgICAgIWNvbnRhaW5lckJhbGFuY2UgJiZcbiAgICAgICAgICAgICFmaXJzdEJsYW5rTGluZUluZGV4XG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBmaXJzdEJsYW5rTGluZUluZGV4ID0gaW5kZXhcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhdE1hcmtlciA9IHVuZGVmaW5lZFxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBldmVudFsxXS50eXBlID09PSB0eXBlcy5saW5lUHJlZml4IHx8XG4gICAgICAgIGV2ZW50WzFdLnR5cGUgPT09IHR5cGVzLmxpc3RJdGVtVmFsdWUgfHxcbiAgICAgICAgZXZlbnRbMV0udHlwZSA9PT0gdHlwZXMubGlzdEl0ZW1NYXJrZXIgfHxcbiAgICAgICAgZXZlbnRbMV0udHlwZSA9PT0gdHlwZXMubGlzdEl0ZW1QcmVmaXggfHxcbiAgICAgICAgZXZlbnRbMV0udHlwZSA9PT0gdHlwZXMubGlzdEl0ZW1QcmVmaXhXaGl0ZXNwYWNlXG4gICAgICApIHtcbiAgICAgICAgLy8gRW1wdHkuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdE1hcmtlciA9IHVuZGVmaW5lZFxuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgICghY29udGFpbmVyQmFsYW5jZSAmJlxuICAgICAgICAgIGV2ZW50WzBdID09PSAnZW50ZXInICYmXG4gICAgICAgICAgZXZlbnRbMV0udHlwZSA9PT0gdHlwZXMubGlzdEl0ZW1QcmVmaXgpIHx8XG4gICAgICAgIChjb250YWluZXJCYWxhbmNlID09PSAtMSAmJlxuICAgICAgICAgIGV2ZW50WzBdID09PSAnZXhpdCcgJiZcbiAgICAgICAgICAoZXZlbnRbMV0udHlwZSA9PT0gdHlwZXMubGlzdFVub3JkZXJlZCB8fFxuICAgICAgICAgICAgZXZlbnRbMV0udHlwZSA9PT0gdHlwZXMubGlzdE9yZGVyZWQpKVxuICAgICAgKSB7XG4gICAgICAgIGlmIChsaXN0SXRlbSkge1xuICAgICAgICAgIGxldCB0YWlsSW5kZXggPSBpbmRleFxuICAgICAgICAgIGxpbmVJbmRleCA9IHVuZGVmaW5lZFxuXG4gICAgICAgICAgd2hpbGUgKHRhaWxJbmRleC0tKSB7XG4gICAgICAgICAgICBjb25zdCB0YWlsRXZlbnQgPSBldmVudHNbdGFpbEluZGV4XVxuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHRhaWxFdmVudFsxXS50eXBlID09PSB0eXBlcy5saW5lRW5kaW5nIHx8XG4gICAgICAgICAgICAgIHRhaWxFdmVudFsxXS50eXBlID09PSB0eXBlcy5saW5lRW5kaW5nQmxhbmtcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBpZiAodGFpbEV2ZW50WzBdID09PSAnZXhpdCcpIGNvbnRpbnVlXG5cbiAgICAgICAgICAgICAgaWYgKGxpbmVJbmRleCkge1xuICAgICAgICAgICAgICAgIGV2ZW50c1tsaW5lSW5kZXhdWzFdLnR5cGUgPSB0eXBlcy5saW5lRW5kaW5nQmxhbmtcbiAgICAgICAgICAgICAgICBsaXN0U3ByZWFkID0gdHJ1ZVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGFpbEV2ZW50WzFdLnR5cGUgPSB0eXBlcy5saW5lRW5kaW5nXG4gICAgICAgICAgICAgIGxpbmVJbmRleCA9IHRhaWxJbmRleFxuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgdGFpbEV2ZW50WzFdLnR5cGUgPT09IHR5cGVzLmxpbmVQcmVmaXggfHxcbiAgICAgICAgICAgICAgdGFpbEV2ZW50WzFdLnR5cGUgPT09IHR5cGVzLmJsb2NrUXVvdGVQcmVmaXggfHxcbiAgICAgICAgICAgICAgdGFpbEV2ZW50WzFdLnR5cGUgPT09IHR5cGVzLmJsb2NrUXVvdGVQcmVmaXhXaGl0ZXNwYWNlIHx8XG4gICAgICAgICAgICAgIHRhaWxFdmVudFsxXS50eXBlID09PSB0eXBlcy5ibG9ja1F1b3RlTWFya2VyIHx8XG4gICAgICAgICAgICAgIHRhaWxFdmVudFsxXS50eXBlID09PSB0eXBlcy5saXN0SXRlbUluZGVudFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIC8vIEVtcHR5XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGZpcnN0QmxhbmtMaW5lSW5kZXggJiZcbiAgICAgICAgICAgICghbGluZUluZGV4IHx8IGZpcnN0QmxhbmtMaW5lSW5kZXggPCBsaW5lSW5kZXgpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBsaXN0SXRlbS5fc3ByZWFkID0gdHJ1ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEZpeCBwb3NpdGlvbi5cbiAgICAgICAgICBsaXN0SXRlbS5lbmQgPSBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICBsaW5lSW5kZXggPyBldmVudHNbbGluZUluZGV4XVsxXS5zdGFydCA6IGV2ZW50WzFdLmVuZFxuICAgICAgICAgIClcblxuICAgICAgICAgIGV2ZW50cy5zcGxpY2UobGluZUluZGV4IHx8IGluZGV4LCAwLCBbJ2V4aXQnLCBsaXN0SXRlbSwgZXZlbnRbMl1dKVxuICAgICAgICAgIGluZGV4KytcbiAgICAgICAgICBsZW5ndGgrK1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGxpc3QgaXRlbS5cbiAgICAgICAgaWYgKGV2ZW50WzFdLnR5cGUgPT09IHR5cGVzLmxpc3RJdGVtUHJlZml4KSB7XG4gICAgICAgICAgbGlzdEl0ZW0gPSB7XG4gICAgICAgICAgICB0eXBlOiAnbGlzdEl0ZW0nLFxuICAgICAgICAgICAgX3NwcmVhZDogZmFsc2UsXG4gICAgICAgICAgICBzdGFydDogT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRbMV0uc3RhcnQpLFxuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogd2XigJlsbCBhZGQgYGVuZGAgaW4gYSBzZWNvbmQuXG4gICAgICAgICAgICBlbmQ6IHVuZGVmaW5lZFxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBgbGlzdEl0ZW1gIGlzIG1vc3QgZGVmaW5pdGVseSBkZWZpbmVkLCBUUy4uLlxuICAgICAgICAgIGV2ZW50cy5zcGxpY2UoaW5kZXgsIDAsIFsnZW50ZXInLCBsaXN0SXRlbSwgZXZlbnRbMl1dKVxuICAgICAgICAgIGluZGV4KytcbiAgICAgICAgICBsZW5ndGgrK1xuICAgICAgICAgIGZpcnN0QmxhbmtMaW5lSW5kZXggPSB1bmRlZmluZWRcbiAgICAgICAgICBhdE1hcmtlciA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGV2ZW50c1tzdGFydF1bMV0uX3NwcmVhZCA9IGxpc3RTcHJlYWRcbiAgICByZXR1cm4gbGVuZ3RoXG4gIH1cblxuICAvKipcbiAgICogU2V0IGRhdGEuXG4gICAqXG4gICAqIEB0ZW1wbGF0ZSB7a2V5b2YgQ29tcGlsZURhdGF9IEtleVxuICAgKiAgIEZpZWxkIHR5cGUuXG4gICAqIEBwYXJhbSB7S2V5fSBrZXlcbiAgICogICBLZXkgb2YgZmllbGQuXG4gICAqIEBwYXJhbSB7Q29tcGlsZURhdGFbS2V5XX0gW3ZhbHVlXVxuICAgKiAgIE5ldyB2YWx1ZS5cbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqICAgTm90aGluZy5cbiAgICovXG4gIGZ1bmN0aW9uIHNldERhdGEoa2V5LCB2YWx1ZSkge1xuICAgIGRhdGFba2V5XSA9IHZhbHVlXG4gIH1cblxuICAvKipcbiAgICogR2V0IGRhdGEuXG4gICAqXG4gICAqIEB0ZW1wbGF0ZSB7a2V5b2YgQ29tcGlsZURhdGF9IEtleVxuICAgKiAgIEZpZWxkIHR5cGUuXG4gICAqIEBwYXJhbSB7S2V5fSBrZXlcbiAgICogICBLZXkgb2YgZmllbGQuXG4gICAqIEByZXR1cm5zIHtDb21waWxlRGF0YVtLZXldfVxuICAgKiAgIFZhbHVlLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0RGF0YShrZXkpIHtcbiAgICByZXR1cm4gZGF0YVtrZXldXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIG9wZW5lciBoYW5kbGUuXG4gICAqXG4gICAqIEBwYXJhbSB7KHRva2VuOiBUb2tlbikgPT4gTm9kZX0gY3JlYXRlXG4gICAqICAgQ3JlYXRlIGEgbm9kZS5cbiAgICogQHBhcmFtIHtIYW5kbGV9IFthbmRdXG4gICAqICAgT3B0aW9uYWwgZnVuY3Rpb24gdG8gYWxzbyBydW4uXG4gICAqIEByZXR1cm5zIHtIYW5kbGV9XG4gICAqICAgSGFuZGxlLlxuICAgKi9cbiAgZnVuY3Rpb24gb3BlbmVyKGNyZWF0ZSwgYW5kKSB7XG4gICAgcmV0dXJuIG9wZW5cblxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICAgKiBAcGFyYW0ge1Rva2VufSB0b2tlblxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9wZW4odG9rZW4pIHtcbiAgICAgIGVudGVyLmNhbGwodGhpcywgY3JlYXRlKHRva2VuKSwgdG9rZW4pXG4gICAgICBpZiAoYW5kKSBhbmQuY2FsbCh0aGlzLCB0b2tlbilcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGZ1bmN0aW9uIGJ1ZmZlcigpIHtcbiAgICB0aGlzLnN0YWNrLnB1c2goe3R5cGU6ICdmcmFnbWVudCcsIGNoaWxkcmVuOiBbXX0pXG4gIH1cblxuICAvKipcbiAgICogQHRlbXBsYXRlIHtOb2RlfSBLaW5kXG4gICAqICAgTm9kZSB0eXBlLlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqICAgQ29udGV4dC5cbiAgICogQHBhcmFtIHtLaW5kfSBub2RlXG4gICAqICAgTm9kZSB0byBlbnRlci5cbiAgICogQHBhcmFtIHtUb2tlbn0gdG9rZW5cbiAgICogICBDb3JyZXNwb25kaW5nIHRva2VuLlxuICAgKiBAcGFyYW0ge09uRW50ZXJFcnJvciB8IHVuZGVmaW5lZH0gW2Vycm9ySGFuZGxlcl1cbiAgICogICBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgdGhpcyB0b2tlbiBpcyBvcGVuLCBidXQgaXQgaXMgY2xvc2VkIGJ5IHNvbWV0aGluZyBlbHNlLlxuICAgKiBAcmV0dXJucyB7S2luZH1cbiAgICogICBUaGUgZ2l2ZW4gbm9kZS5cbiAgICovXG4gIGZ1bmN0aW9uIGVudGVyKG5vZGUsIHRva2VuLCBlcnJvckhhbmRsZXIpIHtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQocGFyZW50LCAnZXhwZWN0ZWQgYHBhcmVudGAnKVxuICAgIGFzc2VydCgnY2hpbGRyZW4nIGluIHBhcmVudCwgJ2V4cGVjdGVkIGBwYXJlbnRgJylcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBBc3N1bWUgYE5vZGVgIGNhbiBleGlzdCBhcyBhIGNoaWxkIG9mIGBwYXJlbnRgLlxuICAgIHBhcmVudC5jaGlsZHJlbi5wdXNoKG5vZGUpXG4gICAgdGhpcy5zdGFjay5wdXNoKG5vZGUpXG4gICAgdGhpcy50b2tlblN0YWNrLnB1c2goW3Rva2VuLCBlcnJvckhhbmRsZXJdKVxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGBlbmRgIHdpbGwgYmUgcGF0Y2hlZCBsYXRlci5cbiAgICBub2RlLnBvc2l0aW9uID0ge3N0YXJ0OiBwb2ludCh0b2tlbi5zdGFydCl9XG4gICAgcmV0dXJuIG5vZGVcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBjbG9zZXIgaGFuZGxlLlxuICAgKlxuICAgKiBAcGFyYW0ge0hhbmRsZX0gW2FuZF1cbiAgICogICBPcHRpb25hbCBmdW5jdGlvbiB0byBhbHNvIHJ1bi5cbiAgICogQHJldHVybnMge0hhbmRsZX1cbiAgICogICBIYW5kbGUuXG4gICAqL1xuICBmdW5jdGlvbiBjbG9zZXIoYW5kKSB7XG4gICAgcmV0dXJuIGNsb3NlXG5cbiAgICAvKipcbiAgICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAgICogQHBhcmFtIHtUb2tlbn0gdG9rZW5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9zZSh0b2tlbikge1xuICAgICAgaWYgKGFuZCkgYW5kLmNhbGwodGhpcywgdG9rZW4pXG4gICAgICBleGl0LmNhbGwodGhpcywgdG9rZW4pXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogICBDb250ZXh0LlxuICAgKiBAcGFyYW0ge1Rva2VufSB0b2tlblxuICAgKiAgIENvcnJlc3BvbmRpbmcgdG9rZW4uXG4gICAqIEBwYXJhbSB7T25FeGl0RXJyb3IgfCB1bmRlZmluZWR9IFtvbkV4aXRFcnJvcl1cbiAgICogICBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgYW5vdGhlciB0b2tlbiBpcyBvcGVuLlxuICAgKiBAcmV0dXJucyB7Tm9kZX1cbiAgICogICBUaGUgY2xvc2VkIG5vZGUuXG4gICAqL1xuICBmdW5jdGlvbiBleGl0KHRva2VuLCBvbkV4aXRFcnJvcikge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrLnBvcCgpXG4gICAgYXNzZXJ0KG5vZGUsICdleHBlY3RlZCBgbm9kZWAnKVxuICAgIGNvbnN0IG9wZW4gPSB0aGlzLnRva2VuU3RhY2sucG9wKClcblxuICAgIGlmICghb3Blbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnQ2Fubm90IGNsb3NlIGAnICtcbiAgICAgICAgICB0b2tlbi50eXBlICtcbiAgICAgICAgICAnYCAoJyArXG4gICAgICAgICAgc3RyaW5naWZ5UG9zaXRpb24oe3N0YXJ0OiB0b2tlbi5zdGFydCwgZW5kOiB0b2tlbi5lbmR9KSArXG4gICAgICAgICAgJyk6IGl04oCZcyBub3Qgb3BlbidcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKG9wZW5bMF0udHlwZSAhPT0gdG9rZW4udHlwZSkge1xuICAgICAgaWYgKG9uRXhpdEVycm9yKSB7XG4gICAgICAgIG9uRXhpdEVycm9yLmNhbGwodGhpcywgdG9rZW4sIG9wZW5bMF0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gb3BlblsxXSB8fCBkZWZhdWx0T25FcnJvclxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgdG9rZW4sIG9wZW5bMF0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgYXNzZXJ0KG5vZGUudHlwZSAhPT0gJ2ZyYWdtZW50JywgJ3VuZXhwZWN0ZWQgZnJhZ21lbnQgYGV4aXRgZWQnKVxuICAgIGFzc2VydChub2RlLnBvc2l0aW9uLCAnZXhwZWN0ZWQgYHBvc2l0aW9uYCB0byBiZSBkZWZpbmVkJylcbiAgICBub2RlLnBvc2l0aW9uLmVuZCA9IHBvaW50KHRva2VuLmVuZClcbiAgICByZXR1cm4gbm9kZVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGZ1bmN0aW9uIHJlc3VtZSgpIHtcbiAgICByZXR1cm4gdG9TdHJpbmcodGhpcy5zdGFjay5wb3AoKSlcbiAgfVxuXG4gIC8vXG4gIC8vIEhhbmRsZXJzLlxuICAvL1xuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBvbmVudGVybGlzdG9yZGVyZWQoKSB7XG4gICAgc2V0RGF0YSgnZXhwZWN0aW5nRmlyc3RMaXN0SXRlbVZhbHVlJywgdHJ1ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBvbmVudGVybGlzdGl0ZW12YWx1ZSh0b2tlbikge1xuICAgIGlmIChnZXREYXRhKCdleHBlY3RpbmdGaXJzdExpc3RJdGVtVmFsdWUnKSkge1xuICAgICAgY29uc3QgYW5jZXN0b3IgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMl1cbiAgICAgIGFzc2VydChhbmNlc3RvciwgJ2V4cGVjdGVkIG5vZGVzIG9uIHN0YWNrJylcbiAgICAgIGFzc2VydChhbmNlc3Rvci50eXBlID09PSAnbGlzdCcsICdleHBlY3RlZCBsaXN0IG9uIHN0YWNrJylcbiAgICAgIGFuY2VzdG9yLnN0YXJ0ID0gTnVtYmVyLnBhcnNlSW50KFxuICAgICAgICB0aGlzLnNsaWNlU2VyaWFsaXplKHRva2VuKSxcbiAgICAgICAgY29uc3RhbnRzLm51bWVyaWNCYXNlRGVjaW1hbFxuICAgICAgKVxuICAgICAgc2V0RGF0YSgnZXhwZWN0aW5nRmlyc3RMaXN0SXRlbVZhbHVlJylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gb25leGl0Y29kZWZlbmNlZGZlbmNlaW5mbygpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5yZXN1bWUoKVxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQobm9kZSwgJ2V4cGVjdGVkIG5vZGUgb24gc3RhY2snKVxuICAgIGFzc2VydChub2RlLnR5cGUgPT09ICdjb2RlJywgJ2V4cGVjdGVkIGNvZGUgb24gc3RhY2snKVxuICAgIG5vZGUubGFuZyA9IGRhdGFcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBvbmV4aXRjb2RlZmVuY2VkZmVuY2VtZXRhKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnJlc3VtZSgpXG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIGFzc2VydChub2RlLCAnZXhwZWN0ZWQgbm9kZSBvbiBzdGFjaycpXG4gICAgYXNzZXJ0KG5vZGUudHlwZSA9PT0gJ2NvZGUnLCAnZXhwZWN0ZWQgY29kZSBvbiBzdGFjaycpXG4gICAgbm9kZS5tZXRhID0gZGF0YVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZXhpdGNvZGVmZW5jZWRmZW5jZSgpIHtcbiAgICAvLyBFeGl0IGlmIHRoaXMgaXMgdGhlIGNsb3NpbmcgZmVuY2UuXG4gICAgaWYgKGdldERhdGEoJ2Zsb3dDb2RlSW5zaWRlJykpIHJldHVyblxuICAgIHRoaXMuYnVmZmVyKClcbiAgICBzZXREYXRhKCdmbG93Q29kZUluc2lkZScsIHRydWUpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gb25leGl0Y29kZWZlbmNlZCgpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5yZXN1bWUoKVxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQobm9kZSwgJ2V4cGVjdGVkIG5vZGUgb24gc3RhY2snKVxuICAgIGFzc2VydChub2RlLnR5cGUgPT09ICdjb2RlJywgJ2V4cGVjdGVkIGNvZGUgb24gc3RhY2snKVxuXG4gICAgbm9kZS52YWx1ZSA9IGRhdGEucmVwbGFjZSgvXihcXHI/XFxufFxccil8KFxccj9cXG58XFxyKSQvZywgJycpXG4gICAgc2V0RGF0YSgnZmxvd0NvZGVJbnNpZGUnKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZXhpdGNvZGVpbmRlbnRlZCgpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5yZXN1bWUoKVxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQobm9kZSwgJ2V4cGVjdGVkIG5vZGUgb24gc3RhY2snKVxuICAgIGFzc2VydChub2RlLnR5cGUgPT09ICdjb2RlJywgJ2V4cGVjdGVkIGNvZGUgb24gc3RhY2snKVxuXG4gICAgbm9kZS52YWx1ZSA9IGRhdGEucmVwbGFjZSgvKFxccj9cXG58XFxyKSQvZywgJycpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gb25leGl0ZGVmaW5pdGlvbmxhYmVsc3RyaW5nKHRva2VuKSB7XG4gICAgY29uc3QgbGFiZWwgPSB0aGlzLnJlc3VtZSgpXG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIGFzc2VydChub2RlLCAnZXhwZWN0ZWQgbm9kZSBvbiBzdGFjaycpXG4gICAgYXNzZXJ0KG5vZGUudHlwZSA9PT0gJ2RlZmluaXRpb24nLCAnZXhwZWN0ZWQgZGVmaW5pdGlvbiBvbiBzdGFjaycpXG5cbiAgICBub2RlLmxhYmVsID0gbGFiZWxcbiAgICBub2RlLmlkZW50aWZpZXIgPSBub3JtYWxpemVJZGVudGlmaWVyKFxuICAgICAgdGhpcy5zbGljZVNlcmlhbGl6ZSh0b2tlbilcbiAgICApLnRvTG93ZXJDYXNlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBvbmV4aXRkZWZpbml0aW9udGl0bGVzdHJpbmcoKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMucmVzdW1lKClcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgYXNzZXJ0KG5vZGUsICdleHBlY3RlZCBub2RlIG9uIHN0YWNrJylcbiAgICBhc3NlcnQobm9kZS50eXBlID09PSAnZGVmaW5pdGlvbicsICdleHBlY3RlZCBkZWZpbml0aW9uIG9uIHN0YWNrJylcblxuICAgIG5vZGUudGl0bGUgPSBkYXRhXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gb25leGl0ZGVmaW5pdGlvbmRlc3RpbmF0aW9uc3RyaW5nKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnJlc3VtZSgpXG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIGFzc2VydChub2RlLCAnZXhwZWN0ZWQgbm9kZSBvbiBzdGFjaycpXG4gICAgYXNzZXJ0KG5vZGUudHlwZSA9PT0gJ2RlZmluaXRpb24nLCAnZXhwZWN0ZWQgZGVmaW5pdGlvbiBvbiBzdGFjaycpXG5cbiAgICBub2RlLnVybCA9IGRhdGFcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBvbmV4aXRhdHhoZWFkaW5nc2VxdWVuY2UodG9rZW4pIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgYXNzZXJ0KG5vZGUsICdleHBlY3RlZCBub2RlIG9uIHN0YWNrJylcbiAgICBhc3NlcnQobm9kZS50eXBlID09PSAnaGVhZGluZycsICdleHBlY3RlZCBoZWFkaW5nIG9uIHN0YWNrJylcblxuICAgIGlmICghbm9kZS5kZXB0aCkge1xuICAgICAgY29uc3QgZGVwdGggPSB0aGlzLnNsaWNlU2VyaWFsaXplKHRva2VuKS5sZW5ndGhcblxuICAgICAgYXNzZXJ0KFxuICAgICAgICBkZXB0aCA9PT0gMSB8fFxuICAgICAgICAgIGRlcHRoID09PSAyIHx8XG4gICAgICAgICAgZGVwdGggPT09IDMgfHxcbiAgICAgICAgICBkZXB0aCA9PT0gNCB8fFxuICAgICAgICAgIGRlcHRoID09PSA1IHx8XG4gICAgICAgICAgZGVwdGggPT09IDYsXG4gICAgICAgICdleHBlY3RlZCBgZGVwdGhgIGJldHdlZW4gYDFgIGFuZCBgNmAnXG4gICAgICApXG5cbiAgICAgIG5vZGUuZGVwdGggPSBkZXB0aFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBvbmV4aXRzZXRleHRoZWFkaW5ndGV4dCgpIHtcbiAgICBzZXREYXRhKCdzZXRleHRIZWFkaW5nU2x1cnBMaW5lRW5kaW5nJywgdHJ1ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBvbmV4aXRzZXRleHRoZWFkaW5nbGluZXNlcXVlbmNlKHRva2VuKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIGFzc2VydChub2RlLCAnZXhwZWN0ZWQgbm9kZSBvbiBzdGFjaycpXG4gICAgYXNzZXJ0KG5vZGUudHlwZSA9PT0gJ2hlYWRpbmcnLCAnZXhwZWN0ZWQgaGVhZGluZyBvbiBzdGFjaycpXG5cbiAgICBub2RlLmRlcHRoID1cbiAgICAgIHRoaXMuc2xpY2VTZXJpYWxpemUodG9rZW4pLmNoYXJDb2RlQXQoMCkgPT09IGNvZGVzLmVxdWFsc1RvID8gMSA6IDJcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBvbmV4aXRzZXRleHRoZWFkaW5nKCkge1xuICAgIHNldERhdGEoJ3NldGV4dEhlYWRpbmdTbHVycExpbmVFbmRpbmcnKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG5cbiAgZnVuY3Rpb24gb25lbnRlcmRhdGEodG9rZW4pIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgYXNzZXJ0KG5vZGUsICdleHBlY3RlZCBub2RlIG9uIHN0YWNrJylcbiAgICBhc3NlcnQoJ2NoaWxkcmVuJyBpbiBub2RlLCAnZXhwZWN0ZWQgcGFyZW50IG9uIHN0YWNrJylcblxuICAgIGxldCB0YWlsID0gbm9kZS5jaGlsZHJlbltub2RlLmNoaWxkcmVuLmxlbmd0aCAtIDFdXG5cbiAgICBpZiAoIXRhaWwgfHwgdGFpbC50eXBlICE9PSAndGV4dCcpIHtcbiAgICAgIC8vIEFkZCBhIG5ldyB0ZXh0IG5vZGUuXG4gICAgICB0YWlsID0gdGV4dCgpXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiB3ZeKAmWxsIGFkZCBgZW5kYCBsYXRlci5cbiAgICAgIHRhaWwucG9zaXRpb24gPSB7c3RhcnQ6IHBvaW50KHRva2VuLnN0YXJ0KX1cbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IEFzc3VtZSBgcGFyZW50YCBhY2NlcHRzIGB0ZXh0YC5cbiAgICAgIG5vZGUuY2hpbGRyZW4ucHVzaCh0YWlsKVxuICAgIH1cblxuICAgIHRoaXMuc3RhY2sucHVzaCh0YWlsKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG5cbiAgZnVuY3Rpb24gb25leGl0ZGF0YSh0b2tlbikge1xuICAgIGNvbnN0IHRhaWwgPSB0aGlzLnN0YWNrLnBvcCgpXG4gICAgYXNzZXJ0KHRhaWwsICdleHBlY3RlZCBhIGBub2RlYCB0byBiZSBvbiB0aGUgc3RhY2snKVxuICAgIGFzc2VydCgndmFsdWUnIGluIHRhaWwsICdleHBlY3RlZCBhIGBsaXRlcmFsYCB0byBiZSBvbiB0aGUgc3RhY2snKVxuICAgIGFzc2VydCh0YWlsLnBvc2l0aW9uLCAnZXhwZWN0ZWQgYG5vZGVgIHRvIGhhdmUgYW4gb3BlbiBwb3NpdGlvbicpXG4gICAgdGFpbC52YWx1ZSArPSB0aGlzLnNsaWNlU2VyaWFsaXplKHRva2VuKVxuICAgIHRhaWwucG9zaXRpb24uZW5kID0gcG9pbnQodG9rZW4uZW5kKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG5cbiAgZnVuY3Rpb24gb25leGl0bGluZWVuZGluZyh0b2tlbikge1xuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQoY29udGV4dCwgJ2V4cGVjdGVkIGBub2RlYCcpXG5cbiAgICAvLyBJZiB3ZeKAmXJlIGF0IGEgaGFyZCBicmVhaywgaW5jbHVkZSB0aGUgbGluZSBlbmRpbmcgaW4gdGhlcmUuXG4gICAgaWYgKGdldERhdGEoJ2F0SGFyZEJyZWFrJykpIHtcbiAgICAgIGFzc2VydCgnY2hpbGRyZW4nIGluIGNvbnRleHQsICdleHBlY3RlZCBgcGFyZW50YCcpXG4gICAgICBjb25zdCB0YWlsID0gY29udGV4dC5jaGlsZHJlbltjb250ZXh0LmNoaWxkcmVuLmxlbmd0aCAtIDFdXG4gICAgICBhc3NlcnQodGFpbC5wb3NpdGlvbiwgJ2V4cGVjdGVkIHRhaWwgdG8gaGF2ZSBhIHN0YXJ0aW5nIHBvc2l0aW9uJylcbiAgICAgIHRhaWwucG9zaXRpb24uZW5kID0gcG9pbnQodG9rZW4uZW5kKVxuICAgICAgc2V0RGF0YSgnYXRIYXJkQnJlYWsnKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgIWdldERhdGEoJ3NldGV4dEhlYWRpbmdTbHVycExpbmVFbmRpbmcnKSAmJlxuICAgICAgY29uZmlnLmNhbkNvbnRhaW5Fb2xzLmluY2x1ZGVzKGNvbnRleHQudHlwZSlcbiAgICApIHtcbiAgICAgIG9uZW50ZXJkYXRhLmNhbGwodGhpcywgdG9rZW4pXG4gICAgICBvbmV4aXRkYXRhLmNhbGwodGhpcywgdG9rZW4pXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG5cbiAgZnVuY3Rpb24gb25leGl0aGFyZGJyZWFrKCkge1xuICAgIHNldERhdGEoJ2F0SGFyZEJyZWFrJywgdHJ1ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uZXhpdGh0bWxmbG93KCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnJlc3VtZSgpXG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIGFzc2VydChub2RlLCAnZXhwZWN0ZWQgbm9kZSBvbiBzdGFjaycpXG4gICAgYXNzZXJ0KG5vZGUudHlwZSA9PT0gJ2h0bWwnLCAnZXhwZWN0ZWQgaHRtbCBvbiBzdGFjaycpXG5cbiAgICBub2RlLnZhbHVlID0gZGF0YVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG5cbiAgZnVuY3Rpb24gb25leGl0aHRtbHRleHQoKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMucmVzdW1lKClcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgYXNzZXJ0KG5vZGUsICdleHBlY3RlZCBub2RlIG9uIHN0YWNrJylcbiAgICBhc3NlcnQobm9kZS50eXBlID09PSAnaHRtbCcsICdleHBlY3RlZCBodG1sIG9uIHN0YWNrJylcblxuICAgIG5vZGUudmFsdWUgPSBkYXRhXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cblxuICBmdW5jdGlvbiBvbmV4aXRjb2RldGV4dCgpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5yZXN1bWUoKVxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQobm9kZSwgJ2V4cGVjdGVkIG5vZGUgb24gc3RhY2snKVxuICAgIGFzc2VydChub2RlLnR5cGUgPT09ICdpbmxpbmVDb2RlJywgJ2V4cGVjdGVkIGlubGluZSBjb2RlIG9uIHN0YWNrJylcblxuICAgIG5vZGUudmFsdWUgPSBkYXRhXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cblxuICBmdW5jdGlvbiBvbmV4aXRsaW5rKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQobm9kZSwgJ2V4cGVjdGVkIG5vZGUgb24gc3RhY2snKVxuICAgIGFzc2VydChub2RlLnR5cGUgPT09ICdsaW5rJywgJ2V4cGVjdGVkIGxpbmsgb24gc3RhY2snKVxuXG4gICAgLy8gTm90ZTogdGhlcmUgYXJlIGFsc28gYGlkZW50aWZpZXJgIGFuZCBgbGFiZWxgIGZpZWxkcyBvbiB0aGlzIGxpbmsgbm9kZSFcbiAgICAvLyBUaGVzZSBhcmUgdXNlZCAvIGNsZWFuZWQgaGVyZS5cblxuICAgIC8vIFRvIGRvOiBjbGVhbi5cbiAgICBpZiAoZ2V0RGF0YSgnaW5SZWZlcmVuY2UnKSkge1xuICAgICAgLyoqIEB0eXBlIHtSZWZlcmVuY2VUeXBlfSAqL1xuICAgICAgY29uc3QgcmVmZXJlbmNlVHlwZSA9IGdldERhdGEoJ3JlZmVyZW5jZVR5cGUnKSB8fCAnc2hvcnRjdXQnXG5cbiAgICAgIG5vZGUudHlwZSArPSAnUmVmZXJlbmNlJ1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogbXV0YXRlLlxuICAgICAgbm9kZS5yZWZlcmVuY2VUeXBlID0gcmVmZXJlbmNlVHlwZVxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogbXV0YXRlLlxuICAgICAgZGVsZXRlIG5vZGUudXJsXG4gICAgICBkZWxldGUgbm9kZS50aXRsZVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBtdXRhdGUuXG4gICAgICBkZWxldGUgbm9kZS5pZGVudGlmaWVyXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBtdXRhdGUuXG4gICAgICBkZWxldGUgbm9kZS5sYWJlbFxuICAgIH1cblxuICAgIHNldERhdGEoJ3JlZmVyZW5jZVR5cGUnKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG5cbiAgZnVuY3Rpb24gb25leGl0aW1hZ2UoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIGFzc2VydChub2RlLCAnZXhwZWN0ZWQgbm9kZSBvbiBzdGFjaycpXG4gICAgYXNzZXJ0KG5vZGUudHlwZSA9PT0gJ2ltYWdlJywgJ2V4cGVjdGVkIGltYWdlIG9uIHN0YWNrJylcblxuICAgIC8vIE5vdGU6IHRoZXJlIGFyZSBhbHNvIGBpZGVudGlmaWVyYCBhbmQgYGxhYmVsYCBmaWVsZHMgb24gdGhpcyBsaW5rIG5vZGUhXG4gICAgLy8gVGhlc2UgYXJlIHVzZWQgLyBjbGVhbmVkIGhlcmUuXG5cbiAgICAvLyBUbyBkbzogY2xlYW4uXG4gICAgaWYgKGdldERhdGEoJ2luUmVmZXJlbmNlJykpIHtcbiAgICAgIC8qKiBAdHlwZSB7UmVmZXJlbmNlVHlwZX0gKi9cbiAgICAgIGNvbnN0IHJlZmVyZW5jZVR5cGUgPSBnZXREYXRhKCdyZWZlcmVuY2VUeXBlJykgfHwgJ3Nob3J0Y3V0J1xuXG4gICAgICBub2RlLnR5cGUgKz0gJ1JlZmVyZW5jZSdcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IG11dGF0ZS5cbiAgICAgIG5vZGUucmVmZXJlbmNlVHlwZSA9IHJlZmVyZW5jZVR5cGVcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IG11dGF0ZS5cbiAgICAgIGRlbGV0ZSBub2RlLnVybFxuICAgICAgZGVsZXRlIG5vZGUudGl0bGVcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogbXV0YXRlLlxuICAgICAgZGVsZXRlIG5vZGUuaWRlbnRpZmllclxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogbXV0YXRlLlxuICAgICAgZGVsZXRlIG5vZGUubGFiZWxcbiAgICB9XG5cbiAgICBzZXREYXRhKCdyZWZlcmVuY2VUeXBlJylcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uZXhpdGxhYmVsdGV4dCh0b2tlbikge1xuICAgIGNvbnN0IHN0cmluZyA9IHRoaXMuc2xpY2VTZXJpYWxpemUodG9rZW4pXG4gICAgY29uc3QgYW5jZXN0b3IgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMl1cbiAgICBhc3NlcnQoYW5jZXN0b3IsICdleHBlY3RlZCBhbmNlc3RvciBvbiBzdGFjaycpXG4gICAgYXNzZXJ0KFxuICAgICAgYW5jZXN0b3IudHlwZSA9PT0gJ2ltYWdlJyB8fCBhbmNlc3Rvci50eXBlID09PSAnbGluaycsXG4gICAgICAnZXhwZWN0ZWQgaW1hZ2Ugb3IgbGluayBvbiBzdGFjaydcbiAgICApXG5cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBzdGFzaCB0aGlzIG9uIHRoZSBub2RlLCBhcyBpdCBtaWdodCBiZWNvbWUgYSByZWZlcmVuY2VcbiAgICAvLyBsYXRlci5cbiAgICBhbmNlc3Rvci5sYWJlbCA9IGRlY29kZVN0cmluZyhzdHJpbmcpXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogc2FtZSBhcyBhYm92ZS5cbiAgICBhbmNlc3Rvci5pZGVudGlmaWVyID0gbm9ybWFsaXplSWRlbnRpZmllcihzdHJpbmcpLnRvTG93ZXJDYXNlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uZXhpdGxhYmVsKCkge1xuICAgIGNvbnN0IGZyYWdtZW50ID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgYXNzZXJ0KGZyYWdtZW50LCAnZXhwZWN0ZWQgbm9kZSBvbiBzdGFjaycpXG4gICAgYXNzZXJ0KGZyYWdtZW50LnR5cGUgPT09ICdmcmFnbWVudCcsICdleHBlY3RlZCBmcmFnbWVudCBvbiBzdGFjaycpXG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLnJlc3VtZSgpXG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIGFzc2VydChub2RlLCAnZXhwZWN0ZWQgbm9kZSBvbiBzdGFjaycpXG4gICAgYXNzZXJ0KFxuICAgICAgbm9kZS50eXBlID09PSAnaW1hZ2UnIHx8IG5vZGUudHlwZSA9PT0gJ2xpbmsnLFxuICAgICAgJ2V4cGVjdGVkIGltYWdlIG9yIGxpbmsgb24gc3RhY2snXG4gICAgKVxuXG4gICAgLy8gQXNzdW1lIGEgcmVmZXJlbmNlLlxuICAgIHNldERhdGEoJ2luUmVmZXJlbmNlJywgdHJ1ZSlcblxuICAgIGlmIChub2RlLnR5cGUgPT09ICdsaW5rJykge1xuICAgICAgLyoqIEB0eXBlIHtBcnJheTxTdGF0aWNQaHJhc2luZ0NvbnRlbnQ+fSAqL1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogQXNzdW1lIHN0YXRpYyBwaHJhc2luZyBjb250ZW50LlxuICAgICAgY29uc3QgY2hpbGRyZW4gPSBmcmFnbWVudC5jaGlsZHJlblxuXG4gICAgICBub2RlLmNoaWxkcmVuID0gY2hpbGRyZW5cbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5hbHQgPSB2YWx1ZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uZXhpdHJlc291cmNlZGVzdGluYXRpb25zdHJpbmcoKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMucmVzdW1lKClcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgYXNzZXJ0KG5vZGUsICdleHBlY3RlZCBub2RlIG9uIHN0YWNrJylcbiAgICBhc3NlcnQoXG4gICAgICBub2RlLnR5cGUgPT09ICdpbWFnZScgfHwgbm9kZS50eXBlID09PSAnbGluaycsXG4gICAgICAnZXhwZWN0ZWQgaW1hZ2Ugb3IgbGluayBvbiBzdGFjaydcbiAgICApXG4gICAgbm9kZS51cmwgPSBkYXRhXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cblxuICBmdW5jdGlvbiBvbmV4aXRyZXNvdXJjZXRpdGxlc3RyaW5nKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnJlc3VtZSgpXG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIGFzc2VydChub2RlLCAnZXhwZWN0ZWQgbm9kZSBvbiBzdGFjaycpXG4gICAgYXNzZXJ0KFxuICAgICAgbm9kZS50eXBlID09PSAnaW1hZ2UnIHx8IG5vZGUudHlwZSA9PT0gJ2xpbmsnLFxuICAgICAgJ2V4cGVjdGVkIGltYWdlIG9yIGxpbmsgb24gc3RhY2snXG4gICAgKVxuICAgIG5vZGUudGl0bGUgPSBkYXRhXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cblxuICBmdW5jdGlvbiBvbmV4aXRyZXNvdXJjZSgpIHtcbiAgICBzZXREYXRhKCdpblJlZmVyZW5jZScpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cblxuICBmdW5jdGlvbiBvbmVudGVycmVmZXJlbmNlKCkge1xuICAgIHNldERhdGEoJ3JlZmVyZW5jZVR5cGUnLCAnY29sbGFwc2VkJylcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uZXhpdHJlZmVyZW5jZXN0cmluZyh0b2tlbikge1xuICAgIGNvbnN0IGxhYmVsID0gdGhpcy5yZXN1bWUoKVxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQobm9kZSwgJ2V4cGVjdGVkIG5vZGUgb24gc3RhY2snKVxuICAgIGFzc2VydChcbiAgICAgIG5vZGUudHlwZSA9PT0gJ2ltYWdlJyB8fCBub2RlLnR5cGUgPT09ICdsaW5rJyxcbiAgICAgICdleHBlY3RlZCBpbWFnZSByZWZlcmVuY2Ugb3IgbGluayByZWZlcmVuY2Ugb24gc3RhY2snXG4gICAgKVxuXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogc3Rhc2ggdGhpcyBvbiB0aGUgbm9kZSwgYXMgaXQgbWlnaHQgYmVjb21lIGEgcmVmZXJlbmNlXG4gICAgLy8gbGF0ZXIuXG4gICAgbm9kZS5sYWJlbCA9IGxhYmVsXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogc2FtZSBhcyBhYm92ZS5cbiAgICBub2RlLmlkZW50aWZpZXIgPSBub3JtYWxpemVJZGVudGlmaWVyKFxuICAgICAgdGhpcy5zbGljZVNlcmlhbGl6ZSh0b2tlbilcbiAgICApLnRvTG93ZXJDYXNlKClcbiAgICBzZXREYXRhKCdyZWZlcmVuY2VUeXBlJywgJ2Z1bGwnKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG5cbiAgZnVuY3Rpb24gb25leGl0Y2hhcmFjdGVycmVmZXJlbmNlbWFya2VyKHRva2VuKSB7XG4gICAgYXNzZXJ0KFxuICAgICAgdG9rZW4udHlwZSA9PT0gJ2NoYXJhY3RlclJlZmVyZW5jZU1hcmtlck51bWVyaWMnIHx8XG4gICAgICAgIHRva2VuLnR5cGUgPT09ICdjaGFyYWN0ZXJSZWZlcmVuY2VNYXJrZXJIZXhhZGVjaW1hbCdcbiAgICApXG4gICAgc2V0RGF0YSgnY2hhcmFjdGVyUmVmZXJlbmNlVHlwZScsIHRva2VuLnR5cGUpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gb25leGl0Y2hhcmFjdGVycmVmZXJlbmNldmFsdWUodG9rZW4pIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5zbGljZVNlcmlhbGl6ZSh0b2tlbilcbiAgICBjb25zdCB0eXBlID0gZ2V0RGF0YSgnY2hhcmFjdGVyUmVmZXJlbmNlVHlwZScpXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgbGV0IHZhbHVlXG5cbiAgICBpZiAodHlwZSkge1xuICAgICAgdmFsdWUgPSBkZWNvZGVOdW1lcmljQ2hhcmFjdGVyUmVmZXJlbmNlKFxuICAgICAgICBkYXRhLFxuICAgICAgICB0eXBlID09PSB0eXBlcy5jaGFyYWN0ZXJSZWZlcmVuY2VNYXJrZXJOdW1lcmljXG4gICAgICAgICAgPyBjb25zdGFudHMubnVtZXJpY0Jhc2VEZWNpbWFsXG4gICAgICAgICAgOiBjb25zdGFudHMubnVtZXJpY0Jhc2VIZXhhZGVjaW1hbFxuICAgICAgKVxuICAgICAgc2V0RGF0YSgnY2hhcmFjdGVyUmVmZXJlbmNlVHlwZScpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGRlY29kZU5hbWVkQ2hhcmFjdGVyUmVmZXJlbmNlKGRhdGEpXG4gICAgICBhc3NlcnQocmVzdWx0ICE9PSBmYWxzZSwgJ2V4cGVjdGVkIHJlZmVyZW5jZSB0byBkZWNvZGUnKVxuICAgICAgdmFsdWUgPSByZXN1bHRcbiAgICB9XG5cbiAgICBjb25zdCB0YWlsID0gdGhpcy5zdGFjay5wb3AoKVxuICAgIGFzc2VydCh0YWlsLCAnZXhwZWN0ZWQgYG5vZGVgJylcbiAgICBhc3NlcnQodGFpbC5wb3NpdGlvbiwgJ2V4cGVjdGVkIGBub2RlLnBvc2l0aW9uYCcpXG4gICAgYXNzZXJ0KCd2YWx1ZScgaW4gdGFpbCwgJ2V4cGVjdGVkIGBub2RlLnZhbHVlYCcpXG4gICAgdGFpbC52YWx1ZSArPSB2YWx1ZVxuICAgIHRhaWwucG9zaXRpb24uZW5kID0gcG9pbnQodG9rZW4uZW5kKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZXhpdGF1dG9saW5rcHJvdG9jb2wodG9rZW4pIHtcbiAgICBvbmV4aXRkYXRhLmNhbGwodGhpcywgdG9rZW4pXG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIGFzc2VydChub2RlLCAnZXhwZWN0ZWQgbm9kZSBvbiBzdGFjaycpXG4gICAgYXNzZXJ0KG5vZGUudHlwZSA9PT0gJ2xpbmsnLCAnZXhwZWN0ZWQgbGluayBvbiBzdGFjaycpXG5cbiAgICBub2RlLnVybCA9IHRoaXMuc2xpY2VTZXJpYWxpemUodG9rZW4pXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gb25leGl0YXV0b2xpbmtlbWFpbCh0b2tlbikge1xuICAgIG9uZXhpdGRhdGEuY2FsbCh0aGlzLCB0b2tlbilcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgYXNzZXJ0KG5vZGUsICdleHBlY3RlZCBub2RlIG9uIHN0YWNrJylcbiAgICBhc3NlcnQobm9kZS50eXBlID09PSAnbGluaycsICdleHBlY3RlZCBsaW5rIG9uIHN0YWNrJylcblxuICAgIG5vZGUudXJsID0gJ21haWx0bzonICsgdGhpcy5zbGljZVNlcmlhbGl6ZSh0b2tlbilcbiAgfVxuXG4gIC8vXG4gIC8vIENyZWF0ZXJzLlxuICAvL1xuXG4gIC8qKiBAcmV0dXJucyB7QmxvY2txdW90ZX0gKi9cbiAgZnVuY3Rpb24gYmxvY2tRdW90ZSgpIHtcbiAgICByZXR1cm4ge3R5cGU6ICdibG9ja3F1b3RlJywgY2hpbGRyZW46IFtdfVxuICB9XG5cbiAgLyoqIEByZXR1cm5zIHtDb2RlfSAqL1xuICBmdW5jdGlvbiBjb2RlRmxvdygpIHtcbiAgICByZXR1cm4ge3R5cGU6ICdjb2RlJywgbGFuZzogbnVsbCwgbWV0YTogbnVsbCwgdmFsdWU6ICcnfVxuICB9XG5cbiAgLyoqIEByZXR1cm5zIHtJbmxpbmVDb2RlfSAqL1xuICBmdW5jdGlvbiBjb2RlVGV4dCgpIHtcbiAgICByZXR1cm4ge3R5cGU6ICdpbmxpbmVDb2RlJywgdmFsdWU6ICcnfVxuICB9XG5cbiAgLyoqIEByZXR1cm5zIHtEZWZpbml0aW9ufSAqL1xuICBmdW5jdGlvbiBkZWZpbml0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnZGVmaW5pdGlvbicsXG4gICAgICBpZGVudGlmaWVyOiAnJyxcbiAgICAgIGxhYmVsOiBudWxsLFxuICAgICAgdGl0bGU6IG51bGwsXG4gICAgICB1cmw6ICcnXG4gICAgfVxuICB9XG5cbiAgLyoqIEByZXR1cm5zIHtFbXBoYXNpc30gKi9cbiAgZnVuY3Rpb24gZW1waGFzaXMoKSB7XG4gICAgcmV0dXJuIHt0eXBlOiAnZW1waGFzaXMnLCBjaGlsZHJlbjogW119XG4gIH1cblxuICAvKiogQHJldHVybnMge0hlYWRpbmd9ICovXG4gIGZ1bmN0aW9uIGhlYWRpbmcoKSB7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBgZGVwdGhgIHdpbGwgYmUgc2V0IGxhdGVyLlxuICAgIHJldHVybiB7dHlwZTogJ2hlYWRpbmcnLCBkZXB0aDogdW5kZWZpbmVkLCBjaGlsZHJlbjogW119XG4gIH1cblxuICAvKiogQHJldHVybnMge0JyZWFrfSAqL1xuICBmdW5jdGlvbiBoYXJkQnJlYWsoKSB7XG4gICAgcmV0dXJuIHt0eXBlOiAnYnJlYWsnfVxuICB9XG5cbiAgLyoqIEByZXR1cm5zIHtIVE1MfSAqL1xuICBmdW5jdGlvbiBodG1sKCkge1xuICAgIHJldHVybiB7dHlwZTogJ2h0bWwnLCB2YWx1ZTogJyd9XG4gIH1cblxuICAvKiogQHJldHVybnMge0ltYWdlfSAqL1xuICBmdW5jdGlvbiBpbWFnZSgpIHtcbiAgICByZXR1cm4ge3R5cGU6ICdpbWFnZScsIHRpdGxlOiBudWxsLCB1cmw6ICcnLCBhbHQ6IG51bGx9XG4gIH1cblxuICAvKiogQHJldHVybnMge0xpbmt9ICovXG4gIGZ1bmN0aW9uIGxpbmsoKSB7XG4gICAgcmV0dXJuIHt0eXBlOiAnbGluaycsIHRpdGxlOiBudWxsLCB1cmw6ICcnLCBjaGlsZHJlbjogW119XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUb2tlbn0gdG9rZW5cbiAgICogQHJldHVybnMge0xpc3R9XG4gICAqL1xuICBmdW5jdGlvbiBsaXN0KHRva2VuKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdsaXN0JyxcbiAgICAgIG9yZGVyZWQ6IHRva2VuLnR5cGUgPT09ICdsaXN0T3JkZXJlZCcsXG4gICAgICBzdGFydDogbnVsbCxcbiAgICAgIHNwcmVhZDogdG9rZW4uX3NwcmVhZCxcbiAgICAgIGNoaWxkcmVuOiBbXVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1Rva2VufSB0b2tlblxuICAgKiBAcmV0dXJucyB7TGlzdEl0ZW19XG4gICAqL1xuICBmdW5jdGlvbiBsaXN0SXRlbSh0b2tlbikge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnbGlzdEl0ZW0nLFxuICAgICAgc3ByZWFkOiB0b2tlbi5fc3ByZWFkLFxuICAgICAgY2hlY2tlZDogbnVsbCxcbiAgICAgIGNoaWxkcmVuOiBbXVxuICAgIH1cbiAgfVxuXG4gIC8qKiBAcmV0dXJucyB7UGFyYWdyYXBofSAqL1xuICBmdW5jdGlvbiBwYXJhZ3JhcGgoKSB7XG4gICAgcmV0dXJuIHt0eXBlOiAncGFyYWdyYXBoJywgY2hpbGRyZW46IFtdfVxuICB9XG5cbiAgLyoqIEByZXR1cm5zIHtTdHJvbmd9ICovXG4gIGZ1bmN0aW9uIHN0cm9uZygpIHtcbiAgICByZXR1cm4ge3R5cGU6ICdzdHJvbmcnLCBjaGlsZHJlbjogW119XG4gIH1cblxuICAvKiogQHJldHVybnMge1RleHR9ICovXG4gIGZ1bmN0aW9uIHRleHQoKSB7XG4gICAgcmV0dXJuIHt0eXBlOiAndGV4dCcsIHZhbHVlOiAnJ31cbiAgfVxuXG4gIC8qKiBAcmV0dXJucyB7VGhlbWF0aWNCcmVha30gKi9cbiAgZnVuY3Rpb24gdGhlbWF0aWNCcmVhaygpIHtcbiAgICByZXR1cm4ge3R5cGU6ICd0aGVtYXRpY0JyZWFrJ31cbiAgfVxufVxuXG4vKipcbiAqIENvcHkgYSBwb2ludC1saWtlIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7UG9pbnR9IGRcbiAqICAgUG9pbnQtbGlrZSB2YWx1ZS5cbiAqIEByZXR1cm5zIHtQb2ludH1cbiAqICAgdW5pc3QgcG9pbnQuXG4gKi9cbmZ1bmN0aW9uIHBvaW50KGQpIHtcbiAgcmV0dXJuIHtsaW5lOiBkLmxpbmUsIGNvbHVtbjogZC5jb2x1bW4sIG9mZnNldDogZC5vZmZzZXR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtDb25maWd9IGNvbWJpbmVkXG4gKiBAcGFyYW0ge0FycmF5PEV4dGVuc2lvbiB8IEFycmF5PEV4dGVuc2lvbj4+fSBleHRlbnNpb25zXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gY29uZmlndXJlKGNvbWJpbmVkLCBleHRlbnNpb25zKSB7XG4gIGxldCBpbmRleCA9IC0xXG5cbiAgd2hpbGUgKCsraW5kZXggPCBleHRlbnNpb25zLmxlbmd0aCkge1xuICAgIGNvbnN0IHZhbHVlID0gZXh0ZW5zaW9uc1tpbmRleF1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgY29uZmlndXJlKGNvbWJpbmVkLCB2YWx1ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgZXh0ZW5zaW9uKGNvbWJpbmVkLCB2YWx1ZSlcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NvbmZpZ30gY29tYmluZWRcbiAqIEBwYXJhbSB7RXh0ZW5zaW9ufSBleHRlbnNpb25cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBleHRlbnNpb24oY29tYmluZWQsIGV4dGVuc2lvbikge1xuICAvKiogQHR5cGUge2tleW9mIEV4dGVuc2lvbn0gKi9cbiAgbGV0IGtleVxuXG4gIGZvciAoa2V5IGluIGV4dGVuc2lvbikge1xuICAgIGlmIChvd24uY2FsbChleHRlbnNpb24sIGtleSkpIHtcbiAgICAgIGlmIChrZXkgPT09ICdjYW5Db250YWluRW9scycpIHtcbiAgICAgICAgY29uc3QgcmlnaHQgPSBleHRlbnNpb25ba2V5XVxuICAgICAgICBpZiAocmlnaHQpIHtcbiAgICAgICAgICBjb21iaW5lZFtrZXldLnB1c2goLi4ucmlnaHQpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAndHJhbnNmb3JtcycpIHtcbiAgICAgICAgY29uc3QgcmlnaHQgPSBleHRlbnNpb25ba2V5XVxuICAgICAgICBpZiAocmlnaHQpIHtcbiAgICAgICAgICBjb21iaW5lZFtrZXldLnB1c2goLi4ucmlnaHQpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnZW50ZXInIHx8IGtleSA9PT0gJ2V4aXQnKSB7XG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gZXh0ZW5zaW9uW2tleV1cbiAgICAgICAgaWYgKHJpZ2h0KSB7XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihjb21iaW5lZFtrZXldLCByaWdodClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiogQHR5cGUge09uRW50ZXJFcnJvcn0gKi9cbmZ1bmN0aW9uIGRlZmF1bHRPbkVycm9yKGxlZnQsIHJpZ2h0KSB7XG4gIGlmIChsZWZ0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0Nhbm5vdCBjbG9zZSBgJyArXG4gICAgICAgIGxlZnQudHlwZSArXG4gICAgICAgICdgICgnICtcbiAgICAgICAgc3RyaW5naWZ5UG9zaXRpb24oe3N0YXJ0OiBsZWZ0LnN0YXJ0LCBlbmQ6IGxlZnQuZW5kfSkgK1xuICAgICAgICAnKTogYSBkaWZmZXJlbnQgdG9rZW4gKGAnICtcbiAgICAgICAgcmlnaHQudHlwZSArXG4gICAgICAgICdgLCAnICtcbiAgICAgICAgc3RyaW5naWZ5UG9zaXRpb24oe3N0YXJ0OiByaWdodC5zdGFydCwgZW5kOiByaWdodC5lbmR9KSArXG4gICAgICAgICcpIGlzIG9wZW4nXG4gICAgKVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdDYW5ub3QgY2xvc2UgZG9jdW1lbnQsIGEgdG9rZW4gKGAnICtcbiAgICAgICAgcmlnaHQudHlwZSArXG4gICAgICAgICdgLCAnICtcbiAgICAgICAgc3RyaW5naWZ5UG9zaXRpb24oe3N0YXJ0OiByaWdodC5zdGFydCwgZW5kOiByaWdodC5lbmR9KSArXG4gICAgICAgICcpIGlzIHN0aWxsIG9wZW4nXG4gICAgKVxuICB9XG59XG4iXSwibmFtZXMiOlsib2siLCJhc3NlcnQiLCJ0b1N0cmluZyIsInBhcnNlIiwicHJlcHJvY2VzcyIsInBvc3Rwcm9jZXNzIiwiZGVjb2RlTnVtZXJpY0NoYXJhY3RlclJlZmVyZW5jZSIsImRlY29kZVN0cmluZyIsIm5vcm1hbGl6ZUlkZW50aWZpZXIiLCJjb2RlcyIsImNvbnN0YW50cyIsInR5cGVzIiwiZGVjb2RlTmFtZWRDaGFyYWN0ZXJSZWZlcmVuY2UiLCJzdHJpbmdpZnlQb3NpdGlvbiIsIm93biIsImhhc093blByb3BlcnR5IiwiZnJvbU1hcmtkb3duIiwidmFsdWUiLCJlbmNvZGluZyIsIm9wdGlvbnMiLCJ1bmRlZmluZWQiLCJjb21waWxlciIsImRvY3VtZW50Iiwid3JpdGUiLCJjb25maWciLCJ0cmFuc2Zvcm1zIiwiY2FuQ29udGFpbkVvbHMiLCJlbnRlciIsImF1dG9saW5rIiwib3BlbmVyIiwibGluayIsImF1dG9saW5rUHJvdG9jb2wiLCJvbmVudGVyZGF0YSIsImF1dG9saW5rRW1haWwiLCJhdHhIZWFkaW5nIiwiaGVhZGluZyIsImJsb2NrUXVvdGUiLCJjaGFyYWN0ZXJFc2NhcGUiLCJjaGFyYWN0ZXJSZWZlcmVuY2UiLCJjb2RlRmVuY2VkIiwiY29kZUZsb3ciLCJjb2RlRmVuY2VkRmVuY2VJbmZvIiwiYnVmZmVyIiwiY29kZUZlbmNlZEZlbmNlTWV0YSIsImNvZGVJbmRlbnRlZCIsImNvZGVUZXh0IiwiY29kZVRleHREYXRhIiwiZGF0YSIsImNvZGVGbG93VmFsdWUiLCJkZWZpbml0aW9uIiwiZGVmaW5pdGlvbkRlc3RpbmF0aW9uU3RyaW5nIiwiZGVmaW5pdGlvbkxhYmVsU3RyaW5nIiwiZGVmaW5pdGlvblRpdGxlU3RyaW5nIiwiZW1waGFzaXMiLCJoYXJkQnJlYWtFc2NhcGUiLCJoYXJkQnJlYWsiLCJoYXJkQnJlYWtUcmFpbGluZyIsImh0bWxGbG93IiwiaHRtbCIsImh0bWxGbG93RGF0YSIsImh0bWxUZXh0IiwiaHRtbFRleHREYXRhIiwiaW1hZ2UiLCJsYWJlbCIsImxpc3RJdGVtIiwibGlzdEl0ZW1WYWx1ZSIsIm9uZW50ZXJsaXN0aXRlbXZhbHVlIiwibGlzdE9yZGVyZWQiLCJsaXN0Iiwib25lbnRlcmxpc3RvcmRlcmVkIiwibGlzdFVub3JkZXJlZCIsInBhcmFncmFwaCIsInJlZmVyZW5jZSIsIm9uZW50ZXJyZWZlcmVuY2UiLCJyZWZlcmVuY2VTdHJpbmciLCJyZXNvdXJjZURlc3RpbmF0aW9uU3RyaW5nIiwicmVzb3VyY2VUaXRsZVN0cmluZyIsInNldGV4dEhlYWRpbmciLCJzdHJvbmciLCJ0aGVtYXRpY0JyZWFrIiwiZXhpdCIsImNsb3NlciIsImF0eEhlYWRpbmdTZXF1ZW5jZSIsIm9uZXhpdGF0eGhlYWRpbmdzZXF1ZW5jZSIsIm9uZXhpdGF1dG9saW5rZW1haWwiLCJvbmV4aXRhdXRvbGlua3Byb3RvY29sIiwiY2hhcmFjdGVyRXNjYXBlVmFsdWUiLCJvbmV4aXRkYXRhIiwiY2hhcmFjdGVyUmVmZXJlbmNlTWFya2VySGV4YWRlY2ltYWwiLCJvbmV4aXRjaGFyYWN0ZXJyZWZlcmVuY2VtYXJrZXIiLCJjaGFyYWN0ZXJSZWZlcmVuY2VNYXJrZXJOdW1lcmljIiwiY2hhcmFjdGVyUmVmZXJlbmNlVmFsdWUiLCJvbmV4aXRjaGFyYWN0ZXJyZWZlcmVuY2V2YWx1ZSIsIm9uZXhpdGNvZGVmZW5jZWQiLCJjb2RlRmVuY2VkRmVuY2UiLCJvbmV4aXRjb2RlZmVuY2VkZmVuY2UiLCJvbmV4aXRjb2RlZmVuY2VkZmVuY2VpbmZvIiwib25leGl0Y29kZWZlbmNlZGZlbmNlbWV0YSIsIm9uZXhpdGNvZGVpbmRlbnRlZCIsIm9uZXhpdGNvZGV0ZXh0Iiwib25leGl0ZGVmaW5pdGlvbmRlc3RpbmF0aW9uc3RyaW5nIiwib25leGl0ZGVmaW5pdGlvbmxhYmVsc3RyaW5nIiwib25leGl0ZGVmaW5pdGlvbnRpdGxlc3RyaW5nIiwib25leGl0aGFyZGJyZWFrIiwib25leGl0aHRtbGZsb3ciLCJvbmV4aXRodG1sdGV4dCIsIm9uZXhpdGltYWdlIiwib25leGl0bGFiZWwiLCJsYWJlbFRleHQiLCJvbmV4aXRsYWJlbHRleHQiLCJsaW5lRW5kaW5nIiwib25leGl0bGluZWVuZGluZyIsIm9uZXhpdGxpbmsiLCJvbmV4aXRyZWZlcmVuY2VzdHJpbmciLCJvbmV4aXRyZXNvdXJjZWRlc3RpbmF0aW9uc3RyaW5nIiwib25leGl0cmVzb3VyY2V0aXRsZXN0cmluZyIsInJlc291cmNlIiwib25leGl0cmVzb3VyY2UiLCJvbmV4aXRzZXRleHRoZWFkaW5nIiwic2V0ZXh0SGVhZGluZ0xpbmVTZXF1ZW5jZSIsIm9uZXhpdHNldGV4dGhlYWRpbmdsaW5lc2VxdWVuY2UiLCJzZXRleHRIZWFkaW5nVGV4dCIsIm9uZXhpdHNldGV4dGhlYWRpbmd0ZXh0IiwiY29uZmlndXJlIiwibWRhc3RFeHRlbnNpb25zIiwiY29tcGlsZSIsImV2ZW50cyIsInRyZWUiLCJ0eXBlIiwiY2hpbGRyZW4iLCJjb250ZXh0Iiwic3RhY2siLCJ0b2tlblN0YWNrIiwicmVzdW1lIiwic2V0RGF0YSIsImdldERhdGEiLCJsaXN0U3RhY2siLCJpbmRleCIsImxlbmd0aCIsInB1c2giLCJ0YWlsIiwicG9wIiwicHJlcGFyZUxpc3QiLCJoYW5kbGVyIiwiY2FsbCIsIk9iamVjdCIsImFzc2lnbiIsInNsaWNlU2VyaWFsaXplIiwiZGVmYXVsdE9uRXJyb3IiLCJwb3NpdGlvbiIsInN0YXJ0IiwicG9pbnQiLCJsaW5lIiwiY29sdW1uIiwib2Zmc2V0IiwiZW5kIiwiY29udGFpbmVyQmFsYW5jZSIsImxpc3RTcHJlYWQiLCJsaW5lSW5kZXgiLCJmaXJzdEJsYW5rTGluZUluZGV4IiwiYXRNYXJrZXIiLCJldmVudCIsImxpbmVFbmRpbmdCbGFuayIsImxpbmVQcmVmaXgiLCJsaXN0SXRlbU1hcmtlciIsImxpc3RJdGVtUHJlZml4IiwibGlzdEl0ZW1QcmVmaXhXaGl0ZXNwYWNlIiwidGFpbEluZGV4IiwidGFpbEV2ZW50IiwiYmxvY2tRdW90ZVByZWZpeCIsImJsb2NrUXVvdGVQcmVmaXhXaGl0ZXNwYWNlIiwiYmxvY2tRdW90ZU1hcmtlciIsImxpc3RJdGVtSW5kZW50IiwiX3NwcmVhZCIsInNwbGljZSIsImtleSIsImNyZWF0ZSIsImFuZCIsIm9wZW4iLCJ0b2tlbiIsIm5vZGUiLCJlcnJvckhhbmRsZXIiLCJwYXJlbnQiLCJjbG9zZSIsIm9uRXhpdEVycm9yIiwiRXJyb3IiLCJhbmNlc3RvciIsIk51bWJlciIsInBhcnNlSW50IiwibnVtZXJpY0Jhc2VEZWNpbWFsIiwibGFuZyIsIm1ldGEiLCJyZXBsYWNlIiwiaWRlbnRpZmllciIsInRvTG93ZXJDYXNlIiwidGl0bGUiLCJ1cmwiLCJkZXB0aCIsImNoYXJDb2RlQXQiLCJlcXVhbHNUbyIsInRleHQiLCJpbmNsdWRlcyIsInJlZmVyZW5jZVR5cGUiLCJzdHJpbmciLCJmcmFnbWVudCIsImFsdCIsIm51bWVyaWNCYXNlSGV4YWRlY2ltYWwiLCJyZXN1bHQiLCJvcmRlcmVkIiwic3ByZWFkIiwiY2hlY2tlZCIsImQiLCJjb21iaW5lZCIsImV4dGVuc2lvbnMiLCJBcnJheSIsImlzQXJyYXkiLCJleHRlbnNpb24iLCJyaWdodCIsImxlZnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/mdast-util-from-markdown@1.3.1/node_modules/mdast-util-from-markdown/dev/lib/index.js\n");

/***/ })

};
;