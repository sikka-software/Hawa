"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_registry_default_example_resizable-vertical_tsx"],{

/***/ "(app-pages-browser)/../../node_modules/.pnpm/lucide-react@0.288.0_react@18.2.0/node_modules/lucide-react/dist/esm/createLucideIcon.js":
/*!*************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/lucide-react@0.288.0_react@18.2.0/node_modules/lucide-react/dist/esm/createLucideIcon.js ***!
  \*************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ createLucideIcon; },\n/* harmony export */   toKebabCase: function() { return /* binding */ toKebabCase; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../../node_modules/.pnpm/next@14.0.4_@opentelemetry+api@1.7.0_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _defaultAttributes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./defaultAttributes.js */ \"(app-pages-browser)/../../node_modules/.pnpm/lucide-react@0.288.0_react@18.2.0/node_modules/lucide-react/dist/esm/defaultAttributes.js\");\n/**\n * lucide-react v0.288.0 - ISC\n */\n\n\n\n\nconst toKebabCase = (string) => string.replace(/([a-z0-9])([A-Z])/g, \"$1-$2\").toLowerCase();\nconst createLucideIcon = (iconName, iconNode) => {\n  const Component = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(\n    ({ color = \"currentColor\", size = 24, strokeWidth = 2, absoluteStrokeWidth, children, ...rest }, ref) => (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\n      \"svg\",\n      {\n        ref,\n        ..._defaultAttributes_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n        width: size,\n        height: size,\n        stroke: color,\n        strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size) : strokeWidth,\n        className: `lucide lucide-${toKebabCase(iconName)}`,\n        ...rest\n      },\n      [\n        ...iconNode.map(([tag, attrs]) => (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(tag, attrs)),\n        ...(Array.isArray(children) ? children : [children]) || []\n      ]\n    )\n  );\n  Component.displayName = `${iconName}`;\n  return Component;\n};\n\n\n//# sourceMappingURL=createLucideIcon.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbHVjaWRlLXJlYWN0QDAuMjg4LjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vY3JlYXRlTHVjaWRlSWNvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTs7QUFFa0Q7QUFDSzs7QUFFdkQ7QUFDQTtBQUNBLG9CQUFvQixpREFBVTtBQUM5QixPQUFPLDRGQUE0RixVQUFVLG9EQUFhO0FBQzFIO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNkRBQWlCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHNCQUFzQjtBQUMxRDtBQUNBLE9BQU87QUFDUDtBQUNBLDBDQUEwQyxvREFBYTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixTQUFTO0FBQ3RDO0FBQ0E7O0FBRW9EO0FBQ3BEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbHVjaWRlLXJlYWN0QDAuMjg4LjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vY3JlYXRlTHVjaWRlSWNvbi5qcz8wMjY4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogbHVjaWRlLXJlYWN0IHYwLjI4OC4wIC0gSVNDXG4gKi9cblxuaW1wb3J0IHsgZm9yd2FyZFJlZiwgY3JlYXRlRWxlbWVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBkZWZhdWx0QXR0cmlidXRlcyBmcm9tICcuL2RlZmF1bHRBdHRyaWJ1dGVzLmpzJztcblxuY29uc3QgdG9LZWJhYkNhc2UgPSAoc3RyaW5nKSA9PiBzdHJpbmcucmVwbGFjZSgvKFthLXowLTldKShbQS1aXSkvZywgXCIkMS0kMlwiKS50b0xvd2VyQ2FzZSgpO1xuY29uc3QgY3JlYXRlTHVjaWRlSWNvbiA9IChpY29uTmFtZSwgaWNvbk5vZGUpID0+IHtcbiAgY29uc3QgQ29tcG9uZW50ID0gZm9yd2FyZFJlZihcbiAgICAoeyBjb2xvciA9IFwiY3VycmVudENvbG9yXCIsIHNpemUgPSAyNCwgc3Ryb2tlV2lkdGggPSAyLCBhYnNvbHV0ZVN0cm9rZVdpZHRoLCBjaGlsZHJlbiwgLi4ucmVzdCB9LCByZWYpID0+IGNyZWF0ZUVsZW1lbnQoXG4gICAgICBcInN2Z1wiLFxuICAgICAge1xuICAgICAgICByZWYsXG4gICAgICAgIC4uLmRlZmF1bHRBdHRyaWJ1dGVzLFxuICAgICAgICB3aWR0aDogc2l6ZSxcbiAgICAgICAgaGVpZ2h0OiBzaXplLFxuICAgICAgICBzdHJva2U6IGNvbG9yLFxuICAgICAgICBzdHJva2VXaWR0aDogYWJzb2x1dGVTdHJva2VXaWR0aCA/IE51bWJlcihzdHJva2VXaWR0aCkgKiAyNCAvIE51bWJlcihzaXplKSA6IHN0cm9rZVdpZHRoLFxuICAgICAgICBjbGFzc05hbWU6IGBsdWNpZGUgbHVjaWRlLSR7dG9LZWJhYkNhc2UoaWNvbk5hbWUpfWAsXG4gICAgICAgIC4uLnJlc3RcbiAgICAgIH0sXG4gICAgICBbXG4gICAgICAgIC4uLmljb25Ob2RlLm1hcCgoW3RhZywgYXR0cnNdKSA9PiBjcmVhdGVFbGVtZW50KHRhZywgYXR0cnMpKSxcbiAgICAgICAgLi4uKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pID8gY2hpbGRyZW4gOiBbY2hpbGRyZW5dKSB8fCBbXVxuICAgICAgXVxuICAgIClcbiAgKTtcbiAgQ29tcG9uZW50LmRpc3BsYXlOYW1lID0gYCR7aWNvbk5hbWV9YDtcbiAgcmV0dXJuIENvbXBvbmVudDtcbn07XG5cbmV4cG9ydCB7IGNyZWF0ZUx1Y2lkZUljb24gYXMgZGVmYXVsdCwgdG9LZWJhYkNhc2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyZWF0ZUx1Y2lkZUljb24uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/lucide-react@0.288.0_react@18.2.0/node_modules/lucide-react/dist/esm/createLucideIcon.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/lucide-react@0.288.0_react@18.2.0/node_modules/lucide-react/dist/esm/defaultAttributes.js":
/*!**************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/lucide-react@0.288.0_react@18.2.0/node_modules/lucide-react/dist/esm/defaultAttributes.js ***!
  \**************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ defaultAttributes; }\n/* harmony export */ });\n/**\n * lucide-react v0.288.0 - ISC\n */\n\nvar defaultAttributes = {\n  xmlns: \"http://www.w3.org/2000/svg\",\n  width: 24,\n  height: 24,\n  viewBox: \"0 0 24 24\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeWidth: 2,\n  strokeLinecap: \"round\",\n  strokeLinejoin: \"round\"\n};\n\n\n//# sourceMappingURL=defaultAttributes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbHVjaWRlLXJlYWN0QDAuMjg4LjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vZGVmYXVsdEF0dHJpYnV0ZXMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV3QztBQUN4QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2x1Y2lkZS1yZWFjdEAwLjI4OC4wX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL2RlZmF1bHRBdHRyaWJ1dGVzLmpzPzdiMTciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBsdWNpZGUtcmVhY3QgdjAuMjg4LjAgLSBJU0NcbiAqL1xuXG52YXIgZGVmYXVsdEF0dHJpYnV0ZXMgPSB7XG4gIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gIHdpZHRoOiAyNCxcbiAgaGVpZ2h0OiAyNCxcbiAgdmlld0JveDogXCIwIDAgMjQgMjRcIixcbiAgZmlsbDogXCJub25lXCIsXG4gIHN0cm9rZTogXCJjdXJyZW50Q29sb3JcIixcbiAgc3Ryb2tlV2lkdGg6IDIsXG4gIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIixcbiAgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIlxufTtcblxuZXhwb3J0IHsgZGVmYXVsdEF0dHJpYnV0ZXMgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmYXVsdEF0dHJpYnV0ZXMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/lucide-react@0.288.0_react@18.2.0/node_modules/lucide-react/dist/esm/defaultAttributes.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/lucide-react@0.288.0_react@18.2.0/node_modules/lucide-react/dist/esm/icons/grip-vertical.js":
/*!****************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/lucide-react@0.288.0_react@18.2.0/node_modules/lucide-react/dist/esm/icons/grip-vertical.js ***!
  \****************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ GripVertical; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/../../node_modules/.pnpm/lucide-react@0.288.0_react@18.2.0/node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * lucide-react v0.288.0 - ISC\n */\n\n\n\nconst GripVertical = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"GripVertical\", [\n  [\"circle\", { cx: \"9\", cy: \"12\", r: \"1\", key: \"1vctgf\" }],\n  [\"circle\", { cx: \"9\", cy: \"5\", r: \"1\", key: \"hp0tcf\" }],\n  [\"circle\", { cx: \"9\", cy: \"19\", r: \"1\", key: \"fkjjf6\" }],\n  [\"circle\", { cx: \"15\", cy: \"12\", r: \"1\", key: \"1tmaij\" }],\n  [\"circle\", { cx: \"15\", cy: \"5\", r: \"1\", key: \"19l28e\" }],\n  [\"circle\", { cx: \"15\", cy: \"19\", r: \"1\", key: \"f4zoj3\" }]\n]);\n\n\n//# sourceMappingURL=grip-vertical.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbHVjaWRlLXJlYWN0QDAuMjg4LjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvZ3JpcC12ZXJ0aWNhbC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTs7QUFFc0Q7O0FBRXRELHFCQUFxQixnRUFBZ0I7QUFDckMsZUFBZSwwQ0FBMEM7QUFDekQsZUFBZSx5Q0FBeUM7QUFDeEQsZUFBZSwwQ0FBMEM7QUFDekQsZUFBZSwyQ0FBMkM7QUFDMUQsZUFBZSwwQ0FBMEM7QUFDekQsZUFBZSwyQ0FBMkM7QUFDMUQ7O0FBRW1DO0FBQ25DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbHVjaWRlLXJlYWN0QDAuMjg4LjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvZ3JpcC12ZXJ0aWNhbC5qcz84Y2Q1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogbHVjaWRlLXJlYWN0IHYwLjI4OC4wIC0gSVNDXG4gKi9cblxuaW1wb3J0IGNyZWF0ZUx1Y2lkZUljb24gZnJvbSAnLi4vY3JlYXRlTHVjaWRlSWNvbi5qcyc7XG5cbmNvbnN0IEdyaXBWZXJ0aWNhbCA9IGNyZWF0ZUx1Y2lkZUljb24oXCJHcmlwVmVydGljYWxcIiwgW1xuICBbXCJjaXJjbGVcIiwgeyBjeDogXCI5XCIsIGN5OiBcIjEyXCIsIHI6IFwiMVwiLCBrZXk6IFwiMXZjdGdmXCIgfV0sXG4gIFtcImNpcmNsZVwiLCB7IGN4OiBcIjlcIiwgY3k6IFwiNVwiLCByOiBcIjFcIiwga2V5OiBcImhwMHRjZlwiIH1dLFxuICBbXCJjaXJjbGVcIiwgeyBjeDogXCI5XCIsIGN5OiBcIjE5XCIsIHI6IFwiMVwiLCBrZXk6IFwiZmtqamY2XCIgfV0sXG4gIFtcImNpcmNsZVwiLCB7IGN4OiBcIjE1XCIsIGN5OiBcIjEyXCIsIHI6IFwiMVwiLCBrZXk6IFwiMXRtYWlqXCIgfV0sXG4gIFtcImNpcmNsZVwiLCB7IGN4OiBcIjE1XCIsIGN5OiBcIjVcIiwgcjogXCIxXCIsIGtleTogXCIxOWwyOGVcIiB9XSxcbiAgW1wiY2lyY2xlXCIsIHsgY3g6IFwiMTVcIiwgY3k6IFwiMTlcIiwgcjogXCIxXCIsIGtleTogXCJmNHpvajNcIiB9XVxuXSk7XG5cbmV4cG9ydCB7IEdyaXBWZXJ0aWNhbCBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ncmlwLXZlcnRpY2FsLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/lucide-react@0.288.0_react@18.2.0/node_modules/lucide-react/dist/esm/icons/grip-vertical.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./registry/default/example/resizable-vertical.tsx":
/*!*********************************************************!*\
  !*** ./registry/default/example/resizable-vertical.tsx ***!
  \*********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ ResizableDemo; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/../../node_modules/.pnpm/next@14.0.4_@opentelemetry+api@1.7.0_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _registry_default_ui_resizable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/registry/default/ui/resizable */ \"(app-pages-browser)/./registry/default/ui/resizable.tsx\");\n\n\nfunction ResizableDemo() {\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_registry_default_ui_resizable__WEBPACK_IMPORTED_MODULE_1__.ResizablePanelGroup, {\n        direction: \"vertical\",\n        className: \"min-h-[200px] max-w-md rounded-lg border\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_registry_default_ui_resizable__WEBPACK_IMPORTED_MODULE_1__.ResizablePanel, {\n                defaultSize: 25,\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"flex h-full items-center justify-center p-6\",\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"font-semibold\",\n                        children: \"Header\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Zakher\\\\Desktop\\\\coding\\\\hawa\\\\apps\\\\www\\\\registry\\\\default\\\\example\\\\resizable-vertical.tsx\",\n                        lineNumber: 15,\n                        columnNumber: 11\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\Zakher\\\\Desktop\\\\coding\\\\hawa\\\\apps\\\\www\\\\registry\\\\default\\\\example\\\\resizable-vertical.tsx\",\n                    lineNumber: 14,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\Zakher\\\\Desktop\\\\coding\\\\hawa\\\\apps\\\\www\\\\registry\\\\default\\\\example\\\\resizable-vertical.tsx\",\n                lineNumber: 13,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_registry_default_ui_resizable__WEBPACK_IMPORTED_MODULE_1__.ResizableHandle, {}, void 0, false, {\n                fileName: \"C:\\\\Users\\\\Zakher\\\\Desktop\\\\coding\\\\hawa\\\\apps\\\\www\\\\registry\\\\default\\\\example\\\\resizable-vertical.tsx\",\n                lineNumber: 18,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_registry_default_ui_resizable__WEBPACK_IMPORTED_MODULE_1__.ResizablePanel, {\n                defaultSize: 75,\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"flex h-full items-center justify-center p-6\",\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"font-semibold\",\n                        children: \"Content\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Zakher\\\\Desktop\\\\coding\\\\hawa\\\\apps\\\\www\\\\registry\\\\default\\\\example\\\\resizable-vertical.tsx\",\n                        lineNumber: 21,\n                        columnNumber: 11\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\Zakher\\\\Desktop\\\\coding\\\\hawa\\\\apps\\\\www\\\\registry\\\\default\\\\example\\\\resizable-vertical.tsx\",\n                    lineNumber: 20,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\Zakher\\\\Desktop\\\\coding\\\\hawa\\\\apps\\\\www\\\\registry\\\\default\\\\example\\\\resizable-vertical.tsx\",\n                lineNumber: 19,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\Zakher\\\\Desktop\\\\coding\\\\hawa\\\\apps\\\\www\\\\registry\\\\default\\\\example\\\\resizable-vertical.tsx\",\n        lineNumber: 9,\n        columnNumber: 5\n    }, this);\n}\n_c = ResizableDemo;\nvar _c;\n$RefreshReg$(_c, \"ResizableDemo\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3JlZ2lzdHJ5L2RlZmF1bHQvZXhhbXBsZS9yZXNpemFibGUtdmVydGljYWwudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFJd0M7QUFFekIsU0FBU0c7SUFDdEIscUJBQ0UsOERBQUNELCtFQUFtQkE7UUFDbEJFLFdBQVU7UUFDVkMsV0FBVTs7MEJBRVYsOERBQUNKLDBFQUFjQTtnQkFBQ0ssYUFBYTswQkFDM0IsNEVBQUNDO29CQUFJRixXQUFVOzhCQUNiLDRFQUFDRzt3QkFBS0gsV0FBVTtrQ0FBZ0I7Ozs7Ozs7Ozs7Ozs7Ozs7MEJBR3BDLDhEQUFDTCwyRUFBZUE7Ozs7OzBCQUNoQiw4REFBQ0MsMEVBQWNBO2dCQUFDSyxhQUFhOzBCQUMzQiw0RUFBQ0M7b0JBQUlGLFdBQVU7OEJBQ2IsNEVBQUNHO3dCQUFLSCxXQUFVO2tDQUFnQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUsxQztLQW5Cd0JGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3JlZ2lzdHJ5L2RlZmF1bHQvZXhhbXBsZS9yZXNpemFibGUtdmVydGljYWwudHN4PzAxNzAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcclxuICBSZXNpemFibGVIYW5kbGUsXHJcbiAgUmVzaXphYmxlUGFuZWwsXHJcbiAgUmVzaXphYmxlUGFuZWxHcm91cCxcclxufSBmcm9tIFwiQC9yZWdpc3RyeS9kZWZhdWx0L3VpL3Jlc2l6YWJsZVwiXHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBSZXNpemFibGVEZW1vKCkge1xyXG4gIHJldHVybiAoXHJcbiAgICA8UmVzaXphYmxlUGFuZWxHcm91cFxyXG4gICAgICBkaXJlY3Rpb249XCJ2ZXJ0aWNhbFwiXHJcbiAgICAgIGNsYXNzTmFtZT1cIm1pbi1oLVsyMDBweF0gbWF4LXctbWQgcm91bmRlZC1sZyBib3JkZXJcIlxyXG4gICAgPlxyXG4gICAgICA8UmVzaXphYmxlUGFuZWwgZGVmYXVsdFNpemU9ezI1fT5cclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaC1mdWxsIGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBwLTZcIj5cclxuICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZvbnQtc2VtaWJvbGRcIj5IZWFkZXI8L3NwYW4+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgIDwvUmVzaXphYmxlUGFuZWw+XHJcbiAgICAgIDxSZXNpemFibGVIYW5kbGUgLz5cclxuICAgICAgPFJlc2l6YWJsZVBhbmVsIGRlZmF1bHRTaXplPXs3NX0+XHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGgtZnVsbCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgcC02XCI+XHJcbiAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJmb250LXNlbWlib2xkXCI+Q29udGVudDwvc3Bhbj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgPC9SZXNpemFibGVQYW5lbD5cclxuICAgIDwvUmVzaXphYmxlUGFuZWxHcm91cD5cclxuICApXHJcbn1cclxuIl0sIm5hbWVzIjpbIlJlc2l6YWJsZUhhbmRsZSIsIlJlc2l6YWJsZVBhbmVsIiwiUmVzaXphYmxlUGFuZWxHcm91cCIsIlJlc2l6YWJsZURlbW8iLCJkaXJlY3Rpb24iLCJjbGFzc05hbWUiLCJkZWZhdWx0U2l6ZSIsImRpdiIsInNwYW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./registry/default/example/resizable-vertical.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./registry/default/ui/resizable.tsx":
/*!*******************************************!*\
  !*** ./registry/default/ui/resizable.tsx ***!
  \*******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ResizableHandle: function() { return /* binding */ ResizableHandle; },\n/* harmony export */   ResizablePanel: function() { return /* binding */ ResizablePanel; },\n/* harmony export */   ResizablePanelGroup: function() { return /* binding */ ResizablePanelGroup; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/../../node_modules/.pnpm/next@14.0.4_@opentelemetry+api@1.7.0_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _barrel_optimize_names_GripVertical_lucide_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! __barrel_optimize__?names=GripVertical!=!lucide-react */ \"(app-pages-browser)/../../node_modules/.pnpm/lucide-react@0.288.0_react@18.2.0/node_modules/lucide-react/dist/esm/icons/grip-vertical.js\");\n/* harmony import */ var react_resizable_panels__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-resizable-panels */ \"(app-pages-browser)/../../node_modules/.pnpm/react-resizable-panels@0.0.55_react-dom@18.2.0_react@18.2.0/node_modules/react-resizable-panels/dist/react-resizable-panels.browser.development.esm.js\");\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/utils */ \"(app-pages-browser)/./lib/utils.ts\");\n/* __next_internal_client_entry_do_not_use__ ResizablePanelGroup,ResizablePanel,ResizableHandle auto */ \n\n\n\nconst ResizablePanelGroup = (param)=>{\n    let { className, ...props } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_resizable_panels__WEBPACK_IMPORTED_MODULE_1__.PanelGroup, {\n        className: (0,_lib_utils__WEBPACK_IMPORTED_MODULE_2__.cn)(\"flex h-full w-full data-[panel-group-direction=vertical]:flex-col\", className),\n        ...props\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\Zakher\\\\Desktop\\\\coding\\\\hawa\\\\apps\\\\www\\\\registry\\\\default\\\\ui\\\\resizable.tsx\",\n        lineNumber: 12,\n        columnNumber: 3\n    }, undefined);\n};\n_c = ResizablePanelGroup;\nconst ResizablePanel = react_resizable_panels__WEBPACK_IMPORTED_MODULE_1__.Panel;\nconst ResizableHandle = (param)=>{\n    let { withHandle, className, ...props } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_resizable_panels__WEBPACK_IMPORTED_MODULE_1__.PanelResizeHandle, {\n        className: (0,_lib_utils__WEBPACK_IMPORTED_MODULE_2__.cn)(\"relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:-translate-y-1/2 data-[panel-group-direction=vertical]:after:translate-x-0 [&[data-panel-group-direction=vertical]>div]:rotate-90\", className),\n        ...props,\n        children: withHandle && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"z-10 flex h-4 w-3 items-center justify-center rounded-sm border bg-border\",\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_GripVertical_lucide_react__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                className: \"h-2.5 w-2.5\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\Zakher\\\\Desktop\\\\coding\\\\hawa\\\\apps\\\\www\\\\registry\\\\default\\\\ui\\\\resizable.tsx\",\n                lineNumber: 39,\n                columnNumber: 9\n            }, undefined)\n        }, void 0, false, {\n            fileName: \"C:\\\\Users\\\\Zakher\\\\Desktop\\\\coding\\\\hawa\\\\apps\\\\www\\\\registry\\\\default\\\\ui\\\\resizable.tsx\",\n            lineNumber: 38,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\Zakher\\\\Desktop\\\\coding\\\\hawa\\\\apps\\\\www\\\\registry\\\\default\\\\ui\\\\resizable.tsx\",\n        lineNumber: 30,\n        columnNumber: 3\n    }, undefined);\n};\n_c1 = ResizableHandle;\n\nvar _c, _c1;\n$RefreshReg$(_c, \"ResizablePanelGroup\");\n$RefreshReg$(_c1, \"ResizableHandle\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3JlZ2lzdHJ5L2RlZmF1bHQvdWkvcmVzaXphYmxlLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUUyQztBQUNpQjtBQUU1QjtBQUVoQyxNQUFNRyxzQkFBc0I7UUFBQyxFQUMzQkMsU0FBUyxFQUNULEdBQUdDLE9BQ3dEO3lCQUMzRCw4REFBQ0osOERBQTZCO1FBQzVCRyxXQUFXRiw4Q0FBRUEsQ0FDWCxxRUFDQUU7UUFFRCxHQUFHQyxLQUFLOzs7Ozs7O0tBVFBGO0FBYU4sTUFBTUksaUJBQWlCTix5REFBd0I7QUFFL0MsTUFBTVEsa0JBQWtCO1FBQUMsRUFDdkJDLFVBQVUsRUFDVk4sU0FBUyxFQUNULEdBQUdDLE9BR0o7eUJBQ0MsOERBQUNKLHFFQUFvQztRQUNuQ0csV0FBV0YsOENBQUVBLENBQ1gsMm9CQUNBRTtRQUVELEdBQUdDLEtBQUs7a0JBRVJLLDRCQUNDLDhEQUFDRTtZQUFJUixXQUFVO3NCQUNiLDRFQUFDSix3RkFBWUE7Z0JBQUNJLFdBQVU7Ozs7Ozs7Ozs7Ozs7Ozs7O01BaEIxQks7QUFzQnlEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3JlZ2lzdHJ5L2RlZmF1bHQvdWkvcmVzaXphYmxlLnRzeD9kYmVlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiXHJcblxyXG5pbXBvcnQgeyBHcmlwVmVydGljYWwgfSBmcm9tIFwibHVjaWRlLXJlYWN0XCJcclxuaW1wb3J0ICogYXMgUmVzaXphYmxlUHJpbWl0aXZlIGZyb20gXCJyZWFjdC1yZXNpemFibGUtcGFuZWxzXCJcclxuXHJcbmltcG9ydCB7IGNuIH0gZnJvbSBcIkAvbGliL3V0aWxzXCJcclxuXHJcbmNvbnN0IFJlc2l6YWJsZVBhbmVsR3JvdXAgPSAoe1xyXG4gIGNsYXNzTmFtZSxcclxuICAuLi5wcm9wc1xyXG59OiBSZWFjdC5Db21wb25lbnRQcm9wczx0eXBlb2YgUmVzaXphYmxlUHJpbWl0aXZlLlBhbmVsR3JvdXA+KSA9PiAoXHJcbiAgPFJlc2l6YWJsZVByaW1pdGl2ZS5QYW5lbEdyb3VwXHJcbiAgICBjbGFzc05hbWU9e2NuKFxyXG4gICAgICBcImZsZXggaC1mdWxsIHctZnVsbCBkYXRhLVtwYW5lbC1ncm91cC1kaXJlY3Rpb249dmVydGljYWxdOmZsZXgtY29sXCIsXHJcbiAgICAgIGNsYXNzTmFtZVxyXG4gICAgKX1cclxuICAgIHsuLi5wcm9wc31cclxuICAvPlxyXG4pXHJcblxyXG5jb25zdCBSZXNpemFibGVQYW5lbCA9IFJlc2l6YWJsZVByaW1pdGl2ZS5QYW5lbFxyXG5cclxuY29uc3QgUmVzaXphYmxlSGFuZGxlID0gKHtcclxuICB3aXRoSGFuZGxlLFxyXG4gIGNsYXNzTmFtZSxcclxuICAuLi5wcm9wc1xyXG59OiBSZWFjdC5Db21wb25lbnRQcm9wczx0eXBlb2YgUmVzaXphYmxlUHJpbWl0aXZlLlBhbmVsUmVzaXplSGFuZGxlPiAmIHtcclxuICB3aXRoSGFuZGxlPzogYm9vbGVhblxyXG59KSA9PiAoXHJcbiAgPFJlc2l6YWJsZVByaW1pdGl2ZS5QYW5lbFJlc2l6ZUhhbmRsZVxyXG4gICAgY2xhc3NOYW1lPXtjbihcclxuICAgICAgXCJyZWxhdGl2ZSBmbGV4IHctcHggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIGJnLWJvcmRlciBhZnRlcjphYnNvbHV0ZSBhZnRlcjppbnNldC15LTAgYWZ0ZXI6bGVmdC0xLzIgYWZ0ZXI6dy0xIGFmdGVyOi10cmFuc2xhdGUteC0xLzIgZm9jdXMtdmlzaWJsZTpvdXRsaW5lLW5vbmUgZm9jdXMtdmlzaWJsZTpyaW5nLTEgZm9jdXMtdmlzaWJsZTpyaW5nLXJpbmcgZm9jdXMtdmlzaWJsZTpyaW5nLW9mZnNldC0xIGRhdGEtW3BhbmVsLWdyb3VwLWRpcmVjdGlvbj12ZXJ0aWNhbF06aC1weCBkYXRhLVtwYW5lbC1ncm91cC1kaXJlY3Rpb249dmVydGljYWxdOnctZnVsbCBkYXRhLVtwYW5lbC1ncm91cC1kaXJlY3Rpb249dmVydGljYWxdOmFmdGVyOmxlZnQtMCBkYXRhLVtwYW5lbC1ncm91cC1kaXJlY3Rpb249dmVydGljYWxdOmFmdGVyOmgtMSBkYXRhLVtwYW5lbC1ncm91cC1kaXJlY3Rpb249dmVydGljYWxdOmFmdGVyOnctZnVsbCBkYXRhLVtwYW5lbC1ncm91cC1kaXJlY3Rpb249dmVydGljYWxdOmFmdGVyOi10cmFuc2xhdGUteS0xLzIgZGF0YS1bcGFuZWwtZ3JvdXAtZGlyZWN0aW9uPXZlcnRpY2FsXTphZnRlcjp0cmFuc2xhdGUteC0wIFsmW2RhdGEtcGFuZWwtZ3JvdXAtZGlyZWN0aW9uPXZlcnRpY2FsXT5kaXZdOnJvdGF0ZS05MFwiLFxyXG4gICAgICBjbGFzc05hbWVcclxuICAgICl9XHJcbiAgICB7Li4ucHJvcHN9XHJcbiAgPlxyXG4gICAge3dpdGhIYW5kbGUgJiYgKFxyXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInotMTAgZmxleCBoLTQgdy0zIGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciByb3VuZGVkLXNtIGJvcmRlciBiZy1ib3JkZXJcIj5cclxuICAgICAgICA8R3JpcFZlcnRpY2FsIGNsYXNzTmFtZT1cImgtMi41IHctMi41XCIgLz5cclxuICAgICAgPC9kaXY+XHJcbiAgICApfVxyXG4gIDwvUmVzaXphYmxlUHJpbWl0aXZlLlBhbmVsUmVzaXplSGFuZGxlPlxyXG4pXHJcblxyXG5leHBvcnQgeyBSZXNpemFibGVQYW5lbEdyb3VwLCBSZXNpemFibGVQYW5lbCwgUmVzaXphYmxlSGFuZGxlIH1cclxuIl0sIm5hbWVzIjpbIkdyaXBWZXJ0aWNhbCIsIlJlc2l6YWJsZVByaW1pdGl2ZSIsImNuIiwiUmVzaXphYmxlUGFuZWxHcm91cCIsImNsYXNzTmFtZSIsInByb3BzIiwiUGFuZWxHcm91cCIsIlJlc2l6YWJsZVBhbmVsIiwiUGFuZWwiLCJSZXNpemFibGVIYW5kbGUiLCJ3aXRoSGFuZGxlIiwiUGFuZWxSZXNpemVIYW5kbGUiLCJkaXYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./registry/default/ui/resizable.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/react-resizable-panels@0.0.55_react-dom@18.2.0_react@18.2.0/node_modules/react-resizable-panels/dist/react-resizable-panels.browser.development.esm.js":
/*!***************************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/react-resizable-panels@0.0.55_react-dom@18.2.0_react@18.2.0/node_modules/react-resizable-panels/dist/react-resizable-panels.browser.development.esm.js ***!
  \***************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Panel: function() { return /* binding */ Panel; },\n/* harmony export */   PanelGroup: function() { return /* binding */ PanelGroup; },\n/* harmony export */   PanelResizeHandle: function() { return /* binding */ PanelResizeHandle; },\n/* harmony export */   getAvailableGroupSizePixels: function() { return /* binding */ getAvailableGroupSizePixels; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../../node_modules/.pnpm/next@14.0.4_@opentelemetry+api@1.7.0_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\n// This module exists to work around Webpack issue https://github.com/webpack/webpack/issues/14814\n\n// eslint-disable-next-line no-restricted-imports\n\nconst {\n  createElement,\n  createContext,\n  forwardRef,\n  useCallback,\n  useContext,\n  useEffect,\n  useImperativeHandle,\n  useLayoutEffect,\n  useMemo,\n  useRef,\n  useState\n} = react__WEBPACK_IMPORTED_MODULE_0__;\n\n// `toString()` prevents bundlers from trying to `import { useId } from 'react'`\nconst useId = react__WEBPACK_IMPORTED_MODULE_0__[\"useId\".toString()];\n\nconst useIsomorphicLayoutEffect = useLayoutEffect ;\n\nconst wrappedUseId = typeof useId === \"function\" ? useId : () => null;\nlet counter = 0;\nfunction useUniqueId(idFromParams = null) {\n  const idFromUseId = wrappedUseId();\n  const idRef = useRef(idFromParams || idFromUseId || null);\n  if (idRef.current === null) {\n    idRef.current = \"\" + counter++;\n  }\n  return idRef.current;\n}\n\nconst PanelGroupContext = createContext(null);\nPanelGroupContext.displayName = \"PanelGroupContext\";\n\nfunction PanelWithForwardedRef({\n  children = null,\n  className: classNameFromProps = \"\",\n  collapsedSize = 0,\n  collapsible = false,\n  defaultSize = null,\n  forwardedRef,\n  id: idFromProps = null,\n  maxSize = null,\n  minSize,\n  onCollapse = null,\n  onResize = null,\n  order = null,\n  style: styleFromProps = {},\n  tagName: Type = \"div\"\n}) {\n  const context = useContext(PanelGroupContext);\n  if (context === null) {\n    throw Error(`Panel components must be rendered within a PanelGroup container`);\n  }\n  const panelId = useUniqueId(idFromProps);\n  const {\n    collapsePanel,\n    expandPanel,\n    getPanelSize,\n    getPanelStyle,\n    registerPanel,\n    resizePanel,\n    units,\n    unregisterPanel\n  } = context;\n  if (minSize == null) {\n    if (units === \"percentages\") {\n      // Mimics legacy default value for percentage based panel groups\n      minSize = 10;\n    } else {\n      // There is no meaningful minimum pixel default we can provide\n      minSize = 0;\n    }\n  }\n\n  // Use a ref to guard against users passing inline props\n  const callbacksRef = useRef({\n    onCollapse,\n    onResize\n  });\n  useEffect(() => {\n    callbacksRef.current.onCollapse = onCollapse;\n    callbacksRef.current.onResize = onResize;\n  });\n  const style = getPanelStyle(panelId, defaultSize);\n  const committedValuesRef = useRef({\n    size: parseSizeFromStyle(style)\n  });\n  const panelDataRef = useRef({\n    callbacksRef,\n    collapsedSize,\n    collapsible,\n    defaultSize,\n    id: panelId,\n    idWasAutoGenerated: idFromProps == null,\n    maxSize,\n    minSize,\n    order\n  });\n  useIsomorphicLayoutEffect(() => {\n    committedValuesRef.current.size = parseSizeFromStyle(style);\n    panelDataRef.current.callbacksRef = callbacksRef;\n    panelDataRef.current.collapsedSize = collapsedSize;\n    panelDataRef.current.collapsible = collapsible;\n    panelDataRef.current.defaultSize = defaultSize;\n    panelDataRef.current.id = panelId;\n    panelDataRef.current.idWasAutoGenerated = idFromProps == null;\n    panelDataRef.current.maxSize = maxSize;\n    panelDataRef.current.minSize = minSize;\n    panelDataRef.current.order = order;\n  });\n  useIsomorphicLayoutEffect(() => {\n    registerPanel(panelId, panelDataRef);\n    return () => {\n      unregisterPanel(panelId);\n    };\n  }, [order, panelId, registerPanel, unregisterPanel]);\n  useImperativeHandle(forwardedRef, () => ({\n    collapse: () => collapsePanel(panelId),\n    expand: () => expandPanel(panelId),\n    getCollapsed() {\n      return committedValuesRef.current.size === 0;\n    },\n    getId() {\n      return panelId;\n    },\n    getSize(units) {\n      return getPanelSize(panelId, units);\n    },\n    resize: (percentage, units) => resizePanel(panelId, percentage, units)\n  }), [collapsePanel, expandPanel, getPanelSize, panelId, resizePanel]);\n  return createElement(Type, {\n    children,\n    className: classNameFromProps,\n    \"data-panel\": \"\",\n    \"data-panel-collapsible\": collapsible || undefined,\n    \"data-panel-id\": panelId,\n    \"data-panel-size\": parseFloat(\"\" + style.flexGrow).toFixed(1),\n    id: `data-panel-id-${panelId}`,\n    style: {\n      ...style,\n      ...styleFromProps\n    }\n  });\n}\nconst Panel = forwardRef((props, ref) => createElement(PanelWithForwardedRef, {\n  ...props,\n  forwardedRef: ref\n}));\nPanelWithForwardedRef.displayName = \"Panel\";\nPanel.displayName = \"forwardRef(Panel)\";\n\n// HACK\nfunction parseSizeFromStyle(style) {\n  const {\n    flexGrow\n  } = style;\n  if (typeof flexGrow === \"string\") {\n    return parseFloat(flexGrow);\n  } else {\n    return flexGrow;\n  }\n}\n\nconst PRECISION = 10;\n\nfunction adjustByDelta(event, committedValues, idBefore, idAfter, deltaPixels, prevSizes, panelSizeBeforeCollapse, initialDragState) {\n  const {\n    id: groupId,\n    panels,\n    units\n  } = committedValues;\n  const groupSizePixels = units === \"pixels\" ? getAvailableGroupSizePixels(groupId) : NaN;\n  const {\n    sizes: initialSizes\n  } = initialDragState || {};\n\n  // If we're resizing by mouse or touch, use the initial sizes as a base.\n  // This has the benefit of causing force-collapsed panels to spring back open if drag is reversed.\n  const baseSizes = initialSizes || prevSizes;\n  const panelsArray = panelsMapToSortedArray(panels);\n  const nextSizes = baseSizes.concat();\n  let deltaApplied = 0;\n\n  // A resizing panel affects the panels before or after it.\n  //\n  // A negative delta means the panel immediately after the resizer should grow/expand by decreasing its offset.\n  // Other panels may also need to shrink/contract (and shift) to make room, depending on the min weights.\n  //\n  // A positive delta means the panel immediately before the resizer should \"expand\".\n  // This is accomplished by shrinking/contracting (and shifting) one or more of the panels after the resizer.\n\n  // Max-bounds check the panel being expanded first.\n  {\n    const pivotId = deltaPixels < 0 ? idAfter : idBefore;\n    const index = panelsArray.findIndex(panel => panel.current.id === pivotId);\n    const panel = panelsArray[index];\n    const baseSize = baseSizes[index];\n    const nextSize = safeResizePanel(units, groupSizePixels, panel, baseSize, baseSize + Math.abs(deltaPixels), event);\n    if (baseSize === nextSize) {\n      // If there's no room for the pivot panel to grow, we can ignore this drag update.\n      return baseSizes;\n    } else {\n      if (nextSize === 0 && baseSize > 0) {\n        panelSizeBeforeCollapse.set(pivotId, baseSize);\n      }\n      deltaPixels = deltaPixels < 0 ? baseSize - nextSize : nextSize - baseSize;\n    }\n  }\n  let pivotId = deltaPixels < 0 ? idBefore : idAfter;\n  let index = panelsArray.findIndex(panel => panel.current.id === pivotId);\n  while (true) {\n    const panel = panelsArray[index];\n    const baseSize = baseSizes[index];\n    const deltaRemaining = Math.abs(deltaPixels) - Math.abs(deltaApplied);\n    const nextSize = safeResizePanel(units, groupSizePixels, panel, baseSize, baseSize - deltaRemaining, event);\n    if (baseSize !== nextSize) {\n      if (nextSize === 0 && baseSize > 0) {\n        panelSizeBeforeCollapse.set(panel.current.id, baseSize);\n      }\n      deltaApplied += baseSize - nextSize;\n      nextSizes[index] = nextSize;\n      if (deltaApplied.toPrecision(PRECISION).localeCompare(Math.abs(deltaPixels).toPrecision(PRECISION), undefined, {\n        numeric: true\n      }) >= 0) {\n        break;\n      }\n    }\n    if (deltaPixels < 0) {\n      if (--index < 0) {\n        break;\n      }\n    } else {\n      if (++index >= panelsArray.length) {\n        break;\n      }\n    }\n  }\n\n  // If we were unable to resize any of the panels panels, return the previous state.\n  // This will essentially bailout and ignore the \"mousemove\" event.\n  if (deltaApplied === 0) {\n    return baseSizes;\n  }\n\n  // Adjust the pivot panel before, but only by the amount that surrounding panels were able to shrink/contract.\n  pivotId = deltaPixels < 0 ? idAfter : idBefore;\n  index = panelsArray.findIndex(panel => panel.current.id === pivotId);\n  nextSizes[index] = baseSizes[index] + deltaApplied;\n  return nextSizes;\n}\nfunction callPanelCallbacks(panelsArray, sizes, panelIdToLastNotifiedSizeMap) {\n  sizes.forEach((size, index) => {\n    const panelRef = panelsArray[index];\n    if (!panelRef) {\n      // Handle initial mount (when panels are registered too late to be in the panels array)\n      // The subsequent render+effects will handle the resize notification\n      return;\n    }\n    const {\n      callbacksRef,\n      collapsedSize,\n      collapsible,\n      id\n    } = panelRef.current;\n    const lastNotifiedSize = panelIdToLastNotifiedSizeMap[id];\n    if (lastNotifiedSize !== size) {\n      panelIdToLastNotifiedSizeMap[id] = size;\n      const {\n        onCollapse,\n        onResize\n      } = callbacksRef.current;\n      if (onResize) {\n        onResize(size, lastNotifiedSize);\n      }\n      if (collapsible && onCollapse) {\n        if ((lastNotifiedSize == null || lastNotifiedSize === collapsedSize) && size !== collapsedSize) {\n          onCollapse(false);\n        } else if (lastNotifiedSize !== collapsedSize && size === collapsedSize) {\n          onCollapse(true);\n        }\n      }\n    }\n  });\n}\nfunction calculateDefaultLayout({\n  groupId,\n  panels,\n  units\n}) {\n  const groupSizePixels = units === \"pixels\" ? getAvailableGroupSizePixels(groupId) : NaN;\n  const panelsArray = panelsMapToSortedArray(panels);\n  const sizes = Array(panelsArray.length);\n  let numPanelsWithSizes = 0;\n  let remainingSize = 100;\n\n  // Assigning default sizes requires a couple of passes:\n  // First, all panels with defaultSize should be set as-is\n  for (let index = 0; index < panelsArray.length; index++) {\n    const panel = panelsArray[index];\n    const {\n      defaultSize\n    } = panel.current;\n    if (defaultSize != null) {\n      numPanelsWithSizes++;\n      sizes[index] = units === \"pixels\" ? defaultSize / groupSizePixels * 100 : defaultSize;\n      remainingSize -= sizes[index];\n    }\n  }\n\n  // Remaining total size should be distributed evenly between panels\n  // This may require two passes, depending on min/max constraints\n  for (let index = 0; index < panelsArray.length; index++) {\n    const panel = panelsArray[index];\n    let {\n      defaultSize,\n      id,\n      maxSize,\n      minSize\n    } = panel.current;\n    if (defaultSize != null) {\n      continue;\n    }\n    if (units === \"pixels\") {\n      minSize = minSize / groupSizePixels * 100;\n      if (maxSize != null) {\n        maxSize = maxSize / groupSizePixels * 100;\n      }\n    }\n    const remainingPanels = panelsArray.length - numPanelsWithSizes;\n    const size = Math.min(maxSize != null ? maxSize : 100, Math.max(minSize, remainingSize / remainingPanels));\n    sizes[index] = size;\n    numPanelsWithSizes++;\n    remainingSize -= size;\n  }\n\n  // If there is additional, left over space, assign it to any panel(s) that permits it\n  // (It's not worth taking multiple additional passes to evenly distribute)\n  if (remainingSize !== 0) {\n    for (let index = 0; index < panelsArray.length; index++) {\n      const panel = panelsArray[index];\n      let {\n        maxSize,\n        minSize\n      } = panel.current;\n      if (units === \"pixels\") {\n        minSize = minSize / groupSizePixels * 100;\n        if (maxSize != null) {\n          maxSize = maxSize / groupSizePixels * 100;\n        }\n      }\n      const size = Math.min(maxSize != null ? maxSize : 100, Math.max(minSize, sizes[index] + remainingSize));\n      if (size !== sizes[index]) {\n        remainingSize -= size - sizes[index];\n        sizes[index] = size;\n\n        // Fuzzy comparison to account for imprecise floating point math\n        if (Math.abs(remainingSize).toFixed(3) === \"0.000\") {\n          break;\n        }\n      }\n    }\n  }\n\n  // Finally, if there is still left-over size, log an error\n  if (Math.abs(remainingSize).toFixed(3) !== \"0.000\") {\n    {\n      console.error(`Invalid panel group configuration; default panel sizes should total 100% but was ${(100 - remainingSize).toFixed(1)}%. This can cause the cursor to become misaligned while dragging.`);\n    }\n  }\n  return sizes;\n}\nfunction getBeforeAndAfterIds(id, panelsArray) {\n  if (panelsArray.length < 2) {\n    return [null, null];\n  }\n  const index = panelsArray.findIndex(panel => panel.current.id === id);\n  if (index < 0) {\n    return [null, null];\n  }\n  const isLastPanel = index === panelsArray.length - 1;\n  const idBefore = isLastPanel ? panelsArray[index - 1].current.id : id;\n  const idAfter = isLastPanel ? id : panelsArray[index + 1].current.id;\n  return [idBefore, idAfter];\n}\nfunction getAvailableGroupSizePixels(groupId) {\n  const panelGroupElement = getPanelGroup(groupId);\n  if (panelGroupElement == null) {\n    return NaN;\n  }\n  const direction = panelGroupElement.getAttribute(\"data-panel-group-direction\");\n  const resizeHandles = getResizeHandlesForGroup(groupId);\n  if (direction === \"horizontal\") {\n    return panelGroupElement.offsetWidth - resizeHandles.reduce((accumulated, handle) => {\n      return accumulated + handle.offsetWidth;\n    }, 0);\n  } else {\n    return panelGroupElement.offsetHeight - resizeHandles.reduce((accumulated, handle) => {\n      return accumulated + handle.offsetHeight;\n    }, 0);\n  }\n}\n\n// This method returns a number between 1 and 100 representing\n// the % of the group's overall space this panel should occupy.\nfunction getFlexGrow(panels, id, sizes) {\n  if (panels.size === 1) {\n    return \"100\";\n  }\n  const panelsArray = panelsMapToSortedArray(panels);\n  const index = panelsArray.findIndex(panel => panel.current.id === id);\n  const size = sizes[index];\n  if (size == null) {\n    return \"0\";\n  }\n  return size.toPrecision(PRECISION);\n}\nfunction getPanel(id) {\n  const element = document.querySelector(`[data-panel-id=\"${id}\"]`);\n  if (element) {\n    return element;\n  }\n  return null;\n}\nfunction getPanelGroup(id) {\n  const element = document.querySelector(`[data-panel-group-id=\"${id}\"]`);\n  if (element) {\n    return element;\n  }\n  return null;\n}\nfunction getResizeHandle(id) {\n  const element = document.querySelector(`[data-panel-resize-handle-id=\"${id}\"]`);\n  if (element) {\n    return element;\n  }\n  return null;\n}\nfunction getResizeHandleIndex(id) {\n  const handles = getResizeHandles();\n  const index = handles.findIndex(handle => handle.getAttribute(\"data-panel-resize-handle-id\") === id);\n  return index ?? null;\n}\nfunction getResizeHandles() {\n  return Array.from(document.querySelectorAll(`[data-panel-resize-handle-id]`));\n}\nfunction getResizeHandlesForGroup(groupId) {\n  return Array.from(document.querySelectorAll(`[data-panel-resize-handle-id][data-panel-group-id=\"${groupId}\"]`));\n}\nfunction getResizeHandlePanelIds(groupId, handleId, panelsArray) {\n  const handle = getResizeHandle(handleId);\n  const handles = getResizeHandlesForGroup(groupId);\n  const index = handle ? handles.indexOf(handle) : -1;\n  const idBefore = panelsArray[index]?.current?.id ?? null;\n  const idAfter = panelsArray[index + 1]?.current?.id ?? null;\n  return [idBefore, idAfter];\n}\nfunction panelsMapToSortedArray(panels) {\n  return Array.from(panels.values()).sort((panelA, panelB) => {\n    const orderA = panelA.current.order;\n    const orderB = panelB.current.order;\n    if (orderA == null && orderB == null) {\n      return 0;\n    } else if (orderA == null) {\n      return -1;\n    } else if (orderB == null) {\n      return 1;\n    } else {\n      return orderA - orderB;\n    }\n  });\n}\nfunction safeResizePanel(units, groupSizePixels, panel, prevSize, nextSize, event = null) {\n  let {\n    collapsedSize,\n    collapsible,\n    maxSize,\n    minSize\n  } = panel.current;\n  if (units === \"pixels\") {\n    collapsedSize = collapsedSize / groupSizePixels * 100;\n    if (maxSize != null) {\n      maxSize = maxSize / groupSizePixels * 100;\n    }\n    minSize = minSize / groupSizePixels * 100;\n  }\n  if (collapsible) {\n    if (prevSize > collapsedSize) {\n      // Mimic VS COde behavior; collapse a panel if it's smaller than half of its min-size\n      if (nextSize <= minSize / 2 + collapsedSize) {\n        return collapsedSize;\n      }\n    } else {\n      const isKeyboardEvent = event?.type?.startsWith(\"key\");\n      if (!isKeyboardEvent) {\n        // Keyboard events should expand a collapsed panel to the min size,\n        // but mouse events should wait until the panel has reached its min size\n        // to avoid a visual flickering when dragging between collapsed and min size.\n        if (nextSize < minSize) {\n          return collapsedSize;\n        }\n      }\n    }\n  }\n  return Math.min(maxSize != null ? maxSize : 100, Math.max(minSize, nextSize));\n}\nfunction validatePanelProps(units, panelData) {\n  const {\n    collapsible,\n    defaultSize,\n    maxSize,\n    minSize\n  } = panelData.current;\n\n  // Basic props validation\n  if (minSize < 0 || units === \"percentages\" && minSize > 100) {\n    {\n      console.error(`Invalid Panel minSize provided, ${minSize}`);\n    }\n    panelData.current.minSize = 0;\n  }\n  if (maxSize != null) {\n    if (maxSize < 0 || units === \"percentages\" && maxSize > 100) {\n      {\n        console.error(`Invalid Panel maxSize provided, ${maxSize}`);\n      }\n      panelData.current.maxSize = null;\n    }\n  }\n  if (defaultSize !== null) {\n    if (defaultSize < 0 || units === \"percentages\" && defaultSize > 100) {\n      {\n        console.error(`Invalid Panel defaultSize provided, ${defaultSize}`);\n      }\n      panelData.current.defaultSize = null;\n    } else if (defaultSize < minSize && !collapsible) {\n      {\n        console.error(`Panel minSize (${minSize}) cannot be greater than defaultSize (${defaultSize})`);\n      }\n      panelData.current.defaultSize = minSize;\n    } else if (maxSize != null && defaultSize > maxSize) {\n      {\n        console.error(`Panel maxSize (${maxSize}) cannot be less than defaultSize (${defaultSize})`);\n      }\n      panelData.current.defaultSize = maxSize;\n    }\n  }\n}\nfunction validatePanelGroupLayout({\n  groupId,\n  panels,\n  nextSizes,\n  prevSizes,\n  units\n}) {\n  // Clone because this method modifies\n  nextSizes = [...nextSizes];\n  const panelsArray = panelsMapToSortedArray(panels);\n  const groupSizePixels = units === \"pixels\" ? getAvailableGroupSizePixels(groupId) : NaN;\n  let remainingSize = 0;\n\n  // First, check all of the proposed sizes against the min/max constraints\n  for (let index = 0; index < panelsArray.length; index++) {\n    const panel = panelsArray[index];\n    const prevSize = prevSizes[index];\n    const nextSize = nextSizes[index];\n    const safeNextSize = safeResizePanel(units, groupSizePixels, panel, prevSize, nextSize);\n    if (nextSize != safeNextSize) {\n      remainingSize += nextSize - safeNextSize;\n      nextSizes[index] = safeNextSize;\n      {\n        console.error(`Invalid size (${nextSize}) specified for Panel \"${panel.current.id}\" given the panel's min/max size constraints`);\n      }\n    }\n  }\n\n  // If there is additional, left over space, assign it to any panel(s) that permits it\n  // (It's not worth taking multiple additional passes to evenly distribute)\n  if (remainingSize.toFixed(3) !== \"0.000\") {\n    for (let index = 0; index < panelsArray.length; index++) {\n      const panel = panelsArray[index];\n      let {\n        maxSize,\n        minSize\n      } = panel.current;\n      if (units === \"pixels\") {\n        minSize = minSize / groupSizePixels * 100;\n        if (maxSize != null) {\n          maxSize = maxSize / groupSizePixels * 100;\n        }\n      }\n      const size = Math.min(maxSize != null ? maxSize : 100, Math.max(minSize, nextSizes[index] + remainingSize));\n      if (size !== nextSizes[index]) {\n        remainingSize -= size - nextSizes[index];\n        nextSizes[index] = size;\n\n        // Fuzzy comparison to account for imprecise floating point math\n        if (Math.abs(remainingSize).toFixed(3) === \"0.000\") {\n          break;\n        }\n      }\n    }\n  }\n\n  // If we still have remainder, the requested layout wasn't valid and we should warn about it\n  if (remainingSize.toFixed(3) !== \"0.000\") {\n    {\n      console.error(`\"Invalid panel group configuration; default panel sizes should total 100% but was ${100 - remainingSize}%`);\n    }\n  }\n  return nextSizes;\n}\n\nfunction assert(expectedCondition, message = \"Assertion failed!\") {\n  if (!expectedCondition) {\n    console.error(message);\n    throw Error(message);\n  }\n}\n\n// https://www.w3.org/WAI/ARIA/apg/patterns/windowsplitter/\n\nfunction useWindowSplitterPanelGroupBehavior({\n  committedValuesRef,\n  groupId,\n  panels,\n  setSizes,\n  sizes,\n  panelSizeBeforeCollapse\n}) {\n  useEffect(() => {\n    const {\n      direction,\n      panels\n    } = committedValuesRef.current;\n    const groupElement = getPanelGroup(groupId);\n    assert(groupElement != null, `No group found for id \"${groupId}\"`);\n    const {\n      height,\n      width\n    } = groupElement.getBoundingClientRect();\n    const handles = getResizeHandlesForGroup(groupId);\n    const cleanupFunctions = handles.map(handle => {\n      const handleId = handle.getAttribute(\"data-panel-resize-handle-id\");\n      const panelsArray = panelsMapToSortedArray(panels);\n      const [idBefore, idAfter] = getResizeHandlePanelIds(groupId, handleId, panelsArray);\n      if (idBefore == null || idAfter == null) {\n        return () => {};\n      }\n      let currentMinSize = 0;\n      let currentMaxSize = 100;\n      let totalMinSize = 0;\n      let totalMaxSize = 0;\n\n      // A panel's effective min/max sizes also need to account for other panel's sizes.\n      panelsArray.forEach(panelData => {\n        const {\n          id,\n          maxSize,\n          minSize\n        } = panelData.current;\n        if (id === idBefore) {\n          currentMinSize = minSize;\n          currentMaxSize = maxSize != null ? maxSize : 100;\n        } else {\n          totalMinSize += minSize;\n          totalMaxSize += maxSize != null ? maxSize : 100;\n        }\n      });\n      const ariaValueMax = Math.min(currentMaxSize, 100 - totalMinSize);\n      const ariaValueMin = Math.max(currentMinSize, (panelsArray.length - 1) * 100 - totalMaxSize);\n      const flexGrow = getFlexGrow(panels, idBefore, sizes);\n      handle.setAttribute(\"aria-valuemax\", \"\" + Math.round(ariaValueMax));\n      handle.setAttribute(\"aria-valuemin\", \"\" + Math.round(ariaValueMin));\n      handle.setAttribute(\"aria-valuenow\", \"\" + Math.round(parseInt(flexGrow)));\n      const onKeyDown = event => {\n        if (event.defaultPrevented) {\n          return;\n        }\n        switch (event.key) {\n          case \"Enter\":\n            {\n              event.preventDefault();\n              const index = panelsArray.findIndex(panel => panel.current.id === idBefore);\n              if (index >= 0) {\n                const panelData = panelsArray[index];\n                const size = sizes[index];\n                if (size != null) {\n                  let delta = 0;\n                  if (size.toPrecision(PRECISION) <= panelData.current.minSize.toPrecision(PRECISION)) {\n                    delta = direction === \"horizontal\" ? width : height;\n                  } else {\n                    delta = -(direction === \"horizontal\" ? width : height);\n                  }\n                  const nextSizes = adjustByDelta(event, committedValuesRef.current, idBefore, idAfter, delta, sizes, panelSizeBeforeCollapse.current, null);\n                  if (sizes !== nextSizes) {\n                    setSizes(nextSizes);\n                  }\n                }\n              }\n              break;\n            }\n        }\n      };\n      handle.addEventListener(\"keydown\", onKeyDown);\n      const panelBefore = getPanel(idBefore);\n      if (panelBefore != null) {\n        handle.setAttribute(\"aria-controls\", panelBefore.id);\n      }\n      return () => {\n        handle.removeAttribute(\"aria-valuemax\");\n        handle.removeAttribute(\"aria-valuemin\");\n        handle.removeAttribute(\"aria-valuenow\");\n        handle.removeEventListener(\"keydown\", onKeyDown);\n        if (panelBefore != null) {\n          handle.removeAttribute(\"aria-controls\");\n        }\n      };\n    });\n    return () => {\n      cleanupFunctions.forEach(cleanupFunction => cleanupFunction());\n    };\n  }, [committedValuesRef, groupId, panels, panelSizeBeforeCollapse, setSizes, sizes]);\n}\nfunction useWindowSplitterResizeHandlerBehavior({\n  disabled,\n  handleId,\n  resizeHandler\n}) {\n  useEffect(() => {\n    if (disabled || resizeHandler == null) {\n      return;\n    }\n    const handleElement = getResizeHandle(handleId);\n    if (handleElement == null) {\n      return;\n    }\n    const onKeyDown = event => {\n      if (event.defaultPrevented) {\n        return;\n      }\n      switch (event.key) {\n        case \"ArrowDown\":\n        case \"ArrowLeft\":\n        case \"ArrowRight\":\n        case \"ArrowUp\":\n        case \"End\":\n        case \"Home\":\n          {\n            event.preventDefault();\n            resizeHandler(event);\n            break;\n          }\n        case \"F6\":\n          {\n            event.preventDefault();\n            const handles = getResizeHandles();\n            const index = getResizeHandleIndex(handleId);\n            assert(index !== null);\n            const nextIndex = event.shiftKey ? index > 0 ? index - 1 : handles.length - 1 : index + 1 < handles.length ? index + 1 : 0;\n            const nextHandle = handles[nextIndex];\n            nextHandle.focus();\n            break;\n          }\n      }\n    };\n    handleElement.addEventListener(\"keydown\", onKeyDown);\n    return () => {\n      handleElement.removeEventListener(\"keydown\", onKeyDown);\n    };\n  }, [disabled, handleId, resizeHandler]);\n}\n\nfunction areEqual(arrayA, arrayB) {\n  if (arrayA.length !== arrayB.length) {\n    return false;\n  }\n  for (let index = 0; index < arrayA.length; index++) {\n    if (arrayA[index] !== arrayB[index]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction getDragOffset(event, handleId, direction, initialOffset = 0, initialHandleElementRect = null) {\n  const isHorizontal = direction === \"horizontal\";\n  let pointerOffset = 0;\n  if (isMouseEvent(event)) {\n    pointerOffset = isHorizontal ? event.clientX : event.clientY;\n  } else if (isTouchEvent(event)) {\n    const firstTouch = event.touches[0];\n    pointerOffset = isHorizontal ? firstTouch.screenX : firstTouch.screenY;\n  } else {\n    return 0;\n  }\n  const handleElement = getResizeHandle(handleId);\n  const rect = initialHandleElementRect || handleElement.getBoundingClientRect();\n  const elementOffset = isHorizontal ? rect.left : rect.top;\n  return pointerOffset - elementOffset - initialOffset;\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/movementX\nfunction getMovement(event, groupId, handleId, panelsArray, direction, prevSizes, initialDragState) {\n  const {\n    dragOffset = 0,\n    dragHandleRect,\n    sizes: initialSizes\n  } = initialDragState || {};\n\n  // If we're resizing by mouse or touch, use the initial sizes as a base.\n  // This has the benefit of causing force-collapsed panels to spring back open if drag is reversed.\n  const baseSizes = initialSizes || prevSizes;\n  if (isKeyDown(event)) {\n    const isHorizontal = direction === \"horizontal\";\n    const groupElement = getPanelGroup(groupId);\n    const rect = groupElement.getBoundingClientRect();\n    const groupSizeInPixels = isHorizontal ? rect.width : rect.height;\n    const denominator = event.shiftKey ? 10 : 100;\n    const delta = groupSizeInPixels / denominator;\n    let movement = 0;\n    switch (event.key) {\n      case \"ArrowDown\":\n        movement = isHorizontal ? 0 : delta;\n        break;\n      case \"ArrowLeft\":\n        movement = isHorizontal ? -delta : 0;\n        break;\n      case \"ArrowRight\":\n        movement = isHorizontal ? delta : 0;\n        break;\n      case \"ArrowUp\":\n        movement = isHorizontal ? 0 : -delta;\n        break;\n      case \"End\":\n        movement = groupSizeInPixels;\n        break;\n      case \"Home\":\n        movement = -groupSizeInPixels;\n        break;\n    }\n\n    // If the Panel being resized is collapsible,\n    // we need to special case resizing around the minSize boundary.\n    // If contracting, Panels should shrink to their minSize and then snap to fully collapsed.\n    // If expanding from collapsed, they should snap back to their minSize.\n    const [idBefore, idAfter] = getResizeHandlePanelIds(groupId, handleId, panelsArray);\n    const targetPanelId = movement < 0 ? idBefore : idAfter;\n    const targetPanelIndex = panelsArray.findIndex(panel => panel.current.id === targetPanelId);\n    const targetPanel = panelsArray[targetPanelIndex];\n    if (targetPanel.current.collapsible) {\n      const baseSize = baseSizes[targetPanelIndex];\n      if (baseSize === 0 || baseSize.toPrecision(PRECISION) === targetPanel.current.minSize.toPrecision(PRECISION)) {\n        movement = movement < 0 ? -targetPanel.current.minSize * groupSizeInPixels : targetPanel.current.minSize * groupSizeInPixels;\n      }\n    }\n    return movement;\n  } else {\n    return getDragOffset(event, handleId, direction, dragOffset, dragHandleRect);\n  }\n}\nfunction isKeyDown(event) {\n  return event.type === \"keydown\";\n}\nfunction isMouseEvent(event) {\n  return event.type.startsWith(\"mouse\");\n}\nfunction isTouchEvent(event) {\n  return event.type.startsWith(\"touch\");\n}\n\nlet currentState = null;\nlet element = null;\nfunction getCursorStyle(state) {\n  switch (state) {\n    case \"horizontal\":\n      return \"ew-resize\";\n    case \"horizontal-max\":\n      return \"w-resize\";\n    case \"horizontal-min\":\n      return \"e-resize\";\n    case \"vertical\":\n      return \"ns-resize\";\n    case \"vertical-max\":\n      return \"n-resize\";\n    case \"vertical-min\":\n      return \"s-resize\";\n  }\n}\nfunction resetGlobalCursorStyle() {\n  if (element !== null) {\n    document.head.removeChild(element);\n    currentState = null;\n    element = null;\n  }\n}\nfunction setGlobalCursorStyle(state) {\n  if (currentState === state) {\n    return;\n  }\n  currentState = state;\n  const style = getCursorStyle(state);\n  if (element === null) {\n    element = document.createElement(\"style\");\n    document.head.appendChild(element);\n  }\n  element.innerHTML = `*{cursor: ${style}!important;}`;\n}\n\nfunction debounce(callback, durationMs = 10) {\n  let timeoutId = null;\n  let callable = (...args) => {\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId);\n    }\n    timeoutId = setTimeout(() => {\n      callback(...args);\n    }, durationMs);\n  };\n  return callable;\n}\n\n// Note that Panel ids might be user-provided (stable) or useId generated (non-deterministic)\n// so they should not be used as part of the serialization key.\n// Using an attribute like minSize instead should work well enough.\n// Pre-sorting by minSize allows remembering layouts even if panels are re-ordered/dragged.\nfunction getSerializationKey(panels) {\n  return panels.map(panel => {\n    const {\n      minSize,\n      order\n    } = panel.current;\n    return order ? `${order}:${minSize}` : `${minSize}`;\n  }).sort((a, b) => a.localeCompare(b)).join(\",\");\n}\nfunction loadSerializedPanelGroupState(autoSaveId, storage) {\n  try {\n    const serialized = storage.getItem(`PanelGroup:sizes:${autoSaveId}`);\n    if (serialized) {\n      const parsed = JSON.parse(serialized);\n      if (typeof parsed === \"object\" && parsed != null) {\n        return parsed;\n      }\n    }\n  } catch (error) {}\n  return null;\n}\nfunction loadPanelLayout(autoSaveId, panels, storage) {\n  const state = loadSerializedPanelGroupState(autoSaveId, storage);\n  if (state) {\n    const key = getSerializationKey(panels);\n    return state[key] ?? null;\n  }\n  return null;\n}\nfunction savePanelGroupLayout(autoSaveId, panels, sizes, storage) {\n  const key = getSerializationKey(panels);\n  const state = loadSerializedPanelGroupState(autoSaveId, storage) || {};\n  state[key] = sizes;\n  try {\n    storage.setItem(`PanelGroup:sizes:${autoSaveId}`, JSON.stringify(state));\n  } catch (error) {\n    console.error(error);\n  }\n}\n\nconst debounceMap = {};\n\n// PanelGroup might be rendering in a server-side environment where localStorage is not available\n// or on a browser with cookies/storage disabled.\n// In either case, this function avoids accessing localStorage until needed,\n// and avoids throwing user-visible errors.\nfunction initializeDefaultStorage(storageObject) {\n  try {\n    if (typeof localStorage !== \"undefined\") {\n      // Bypass this check for future calls\n      storageObject.getItem = name => {\n        return localStorage.getItem(name);\n      };\n      storageObject.setItem = (name, value) => {\n        localStorage.setItem(name, value);\n      };\n    } else {\n      throw new Error(\"localStorage not supported in this environment\");\n    }\n  } catch (error) {\n    console.error(error);\n    storageObject.getItem = () => null;\n    storageObject.setItem = () => {};\n  }\n}\nconst defaultStorage = {\n  getItem: name => {\n    initializeDefaultStorage(defaultStorage);\n    return defaultStorage.getItem(name);\n  },\n  setItem: (name, value) => {\n    initializeDefaultStorage(defaultStorage);\n    defaultStorage.setItem(name, value);\n  }\n};\n\n// Initial drag state serves a few purposes:\n// * dragOffset:\n//   Resize is calculated by the distance between the current pointer event and the resize handle being \"dragged\"\n//   This value accounts for the initial offset when the touch/click starts, so the handle doesn't appear to \"jump\"\n// * dragHandleRect, sizes:\n//   When resizing is done via mouse/touch event– some initial state is stored\n//   so that any panels that contract will also expand if drag direction is reversed.\nfunction PanelGroupWithForwardedRef({\n  autoSaveId,\n  children = null,\n  className: classNameFromProps = \"\",\n  direction,\n  disablePointerEventsDuringResize = false,\n  forwardedRef,\n  id: idFromProps = null,\n  onLayout,\n  storage = defaultStorage,\n  style: styleFromProps = {},\n  tagName: Type = \"div\",\n  units = \"percentages\"\n}) {\n  const groupId = useUniqueId(idFromProps);\n  const [activeHandleId, setActiveHandleId] = useState(null);\n  const [panels, setPanels] = useState(new Map());\n\n  // When resizing is done via mouse/touch event–\n  // We store the initial Panel sizes in this ref, and apply move deltas to them instead of to the current sizes.\n  // This has the benefit of causing force-collapsed panels to spring back open if drag is reversed.\n  const initialDragStateRef = useRef(null);\n  const devWarningsRef = useRef({\n    didLogDefaultSizeWarning: false,\n    didLogIdAndOrderWarning: false,\n    didLogInvalidLayoutWarning: false,\n    prevPanelIds: []\n  });\n\n  // Use a ref to guard against users passing inline props\n  const callbacksRef = useRef({\n    onLayout\n  });\n  useEffect(() => {\n    callbacksRef.current.onLayout = onLayout;\n  });\n  const panelIdToLastNotifiedSizeMapRef = useRef({});\n\n  // 0-1 values representing the relative size of each panel.\n  const [sizes, setSizes] = useState([]);\n\n  // Used to support imperative collapse/expand API.\n  const panelSizeBeforeCollapse = useRef(new Map());\n  const prevDeltaRef = useRef(0);\n\n  // Store committed values to avoid unnecessarily re-running memoization/effects functions.\n  const committedValuesRef = useRef({\n    direction,\n    id: groupId,\n    panels,\n    sizes,\n    units\n  });\n  useImperativeHandle(forwardedRef, () => ({\n    getId: () => groupId,\n    getLayout: unitsFromParams => {\n      const {\n        sizes,\n        units: unitsFromProps\n      } = committedValuesRef.current;\n      const units = unitsFromParams ?? unitsFromProps;\n      if (units === \"pixels\") {\n        const groupSizePixels = getAvailableGroupSizePixels(groupId);\n        return sizes.map(size => size / 100 * groupSizePixels);\n      } else {\n        return sizes;\n      }\n    },\n    setLayout: (sizes, unitsFromParams) => {\n      const {\n        id: groupId,\n        panels,\n        sizes: prevSizes,\n        units\n      } = committedValuesRef.current;\n      if ((unitsFromParams || units) === \"pixels\") {\n        const groupSizePixels = getAvailableGroupSizePixels(groupId);\n        sizes = sizes.map(size => size / groupSizePixels * 100);\n      }\n      const panelIdToLastNotifiedSizeMap = panelIdToLastNotifiedSizeMapRef.current;\n      const panelsArray = panelsMapToSortedArray(panels);\n      const nextSizes = validatePanelGroupLayout({\n        groupId,\n        panels,\n        nextSizes: sizes,\n        prevSizes,\n        units\n      });\n      if (!areEqual(prevSizes, nextSizes)) {\n        setSizes(nextSizes);\n        callPanelCallbacks(panelsArray, nextSizes, panelIdToLastNotifiedSizeMap);\n      }\n    }\n  }), [groupId]);\n  useIsomorphicLayoutEffect(() => {\n    committedValuesRef.current.direction = direction;\n    committedValuesRef.current.id = groupId;\n    committedValuesRef.current.panels = panels;\n    committedValuesRef.current.sizes = sizes;\n    committedValuesRef.current.units = units;\n  });\n  useWindowSplitterPanelGroupBehavior({\n    committedValuesRef,\n    groupId,\n    panels,\n    setSizes,\n    sizes,\n    panelSizeBeforeCollapse\n  });\n\n  // Notify external code when sizes have changed.\n  useEffect(() => {\n    const {\n      onLayout\n    } = callbacksRef.current;\n    const {\n      panels,\n      sizes\n    } = committedValuesRef.current;\n\n    // Don't commit layout until all panels have registered and re-rendered with their actual sizes.\n    if (sizes.length > 0) {\n      if (onLayout) {\n        onLayout(sizes);\n      }\n      const panelIdToLastNotifiedSizeMap = panelIdToLastNotifiedSizeMapRef.current;\n\n      // When possible, we notify before the next render so that rendering work can be batched together.\n      // Some cases are difficult to detect though,\n      // for example– panels that are conditionally rendered can affect the size of neighboring panels.\n      // In this case, the best we can do is notify on commit.\n      // The callPanelCallbacks() uses its own memoization to avoid notifying panels twice in these cases.\n      const panelsArray = panelsMapToSortedArray(panels);\n      callPanelCallbacks(panelsArray, sizes, panelIdToLastNotifiedSizeMap);\n    }\n  }, [sizes]);\n\n  // Once all panels have registered themselves,\n  // Compute the initial sizes based on default weights.\n  // This assumes that panels register during initial mount (no conditional rendering)!\n  useIsomorphicLayoutEffect(() => {\n    const {\n      id: groupId,\n      sizes,\n      units\n    } = committedValuesRef.current;\n    if (sizes.length === panels.size) {\n      // Only compute (or restore) default sizes once per panel configuration.\n      return;\n    }\n\n    // If this panel has been configured to persist sizing information,\n    // default size should be restored from local storage if possible.\n    let defaultSizes = null;\n    if (autoSaveId) {\n      const panelsArray = panelsMapToSortedArray(panels);\n      defaultSizes = loadPanelLayout(autoSaveId, panelsArray, storage);\n    }\n    if (defaultSizes != null) {\n      // Validate saved sizes in case something has changed since last render\n      // e.g. for pixel groups, this could be the size of the window\n      const validatedSizes = validatePanelGroupLayout({\n        groupId,\n        panels,\n        nextSizes: defaultSizes,\n        prevSizes: defaultSizes,\n        units\n      });\n      setSizes(validatedSizes);\n    } else {\n      const sizes = calculateDefaultLayout({\n        groupId,\n        panels,\n        units\n      });\n      setSizes(sizes);\n    }\n  }, [autoSaveId, panels, storage]);\n  useEffect(() => {\n    // If this panel has been configured to persist sizing information, save sizes to local storage.\n    if (autoSaveId) {\n      if (sizes.length === 0 || sizes.length !== panels.size) {\n        return;\n      }\n      const panelsArray = panelsMapToSortedArray(panels);\n\n      // Limit the frequency of localStorage updates.\n      if (!debounceMap[autoSaveId]) {\n        debounceMap[autoSaveId] = debounce(savePanelGroupLayout, 100);\n      }\n      debounceMap[autoSaveId](autoSaveId, panelsArray, sizes, storage);\n    }\n    {\n      const {\n        didLogIdAndOrderWarning,\n        prevPanelIds\n      } = devWarningsRef.current;\n      if (!didLogIdAndOrderWarning) {\n        const {\n          panels\n        } = committedValuesRef.current;\n        const panelIds = Array.from(panels.keys());\n        devWarningsRef.current.prevPanelIds = panelIds;\n        const panelsHaveChanged = prevPanelIds.length > 0 && !areEqual(prevPanelIds, panelIds);\n        if (panelsHaveChanged) {\n          if (Array.from(panels.values()).find(panel => panel.current.idWasAutoGenerated || panel.current.order == null)) {\n            devWarningsRef.current.didLogIdAndOrderWarning = true;\n            console.warn(`WARNING: Panel id and order props recommended when panels are dynamically rendered`);\n          }\n        }\n      }\n    }\n  }, [autoSaveId, panels, sizes, storage]);\n  useIsomorphicLayoutEffect(() => {\n    // Pixel panel constraints need to be reassessed after a group resize\n    // We can avoid the ResizeObserver overhead for relative layouts\n    if (units === \"pixels\") {\n      const resizeObserver = new ResizeObserver(() => {\n        const {\n          panels,\n          sizes: prevSizes\n        } = committedValuesRef.current;\n        const nextSizes = validatePanelGroupLayout({\n          groupId,\n          panels,\n          nextSizes: prevSizes,\n          prevSizes,\n          units\n        });\n        if (!areEqual(prevSizes, nextSizes)) {\n          setSizes(nextSizes);\n        }\n      });\n      resizeObserver.observe(getPanelGroup(groupId));\n      return () => {\n        resizeObserver.disconnect();\n      };\n    }\n  }, [groupId, units]);\n  const getPanelSize = useCallback((id, unitsFromParams) => {\n    const {\n      panels,\n      units: unitsFromProps\n    } = committedValuesRef.current;\n    const panelsArray = panelsMapToSortedArray(panels);\n    const index = panelsArray.findIndex(panel => panel.current.id === id);\n    const size = sizes[index];\n    const units = unitsFromParams ?? unitsFromProps;\n    if (units === \"pixels\") {\n      const groupSizePixels = getAvailableGroupSizePixels(groupId);\n      return size / 100 * groupSizePixels;\n    } else {\n      return size;\n    }\n  }, [groupId, sizes]);\n  const getPanelStyle = useCallback((id, defaultSize) => {\n    const {\n      panels\n    } = committedValuesRef.current;\n\n    // Before mounting, Panels will not yet have registered themselves.\n    // This includes server rendering.\n    // At this point the best we can do is render everything with the same size.\n    if (panels.size === 0) {\n      {\n        if (!devWarningsRef.current.didLogDefaultSizeWarning) ;\n      }\n      return {\n        flexBasis: 0,\n        flexGrow: defaultSize != null ? defaultSize : undefined,\n        flexShrink: 1,\n        // Without this, Panel sizes may be unintentionally overridden by their content.\n        overflow: \"hidden\"\n      };\n    }\n    const flexGrow = getFlexGrow(panels, id, sizes);\n    return {\n      flexBasis: 0,\n      flexGrow,\n      flexShrink: 1,\n      // Without this, Panel sizes may be unintentionally overridden by their content.\n      overflow: \"hidden\",\n      // Disable pointer events inside of a panel during resize.\n      // This avoid edge cases like nested iframes.\n      pointerEvents: disablePointerEventsDuringResize && activeHandleId !== null ? \"none\" : undefined\n    };\n  }, [activeHandleId, disablePointerEventsDuringResize, sizes]);\n  const registerPanel = useCallback((id, panelRef) => {\n    const {\n      units\n    } = committedValuesRef.current;\n    validatePanelProps(units, panelRef);\n    setPanels(prevPanels => {\n      if (prevPanels.has(id)) {\n        return prevPanels;\n      }\n      const nextPanels = new Map(prevPanels);\n      nextPanels.set(id, panelRef);\n      return nextPanels;\n    });\n  }, []);\n  const registerResizeHandle = useCallback(handleId => {\n    const resizeHandler = event => {\n      event.preventDefault();\n      const {\n        direction,\n        panels,\n        sizes: prevSizes\n      } = committedValuesRef.current;\n      const panelsArray = panelsMapToSortedArray(panels);\n      const [idBefore, idAfter] = getResizeHandlePanelIds(groupId, handleId, panelsArray);\n      if (idBefore == null || idAfter == null) {\n        return;\n      }\n      let movement = getMovement(event, groupId, handleId, panelsArray, direction, prevSizes, initialDragStateRef.current);\n      if (movement === 0) {\n        return;\n      }\n      const groupElement = getPanelGroup(groupId);\n      const rect = groupElement.getBoundingClientRect();\n      const isHorizontal = direction === \"horizontal\";\n\n      // Support RTL layouts\n      if (document.dir === \"rtl\" && isHorizontal) {\n        movement = -movement;\n      }\n      const size = isHorizontal ? rect.width : rect.height;\n      const delta = movement / size * 100;\n\n      // If a validateLayout method has been provided\n      // it's important to use it before updating the mouse cursor\n      const nextSizes = adjustByDelta(event, committedValuesRef.current, idBefore, idAfter, delta, prevSizes, panelSizeBeforeCollapse.current, initialDragStateRef.current);\n      const sizesChanged = !areEqual(prevSizes, nextSizes);\n\n      // Don't update cursor for resizes triggered by keyboard interactions.\n      if (isMouseEvent(event) || isTouchEvent(event)) {\n        // Watch for multiple subsequent deltas; this might occur for tiny cursor movements.\n        // In this case, Panel sizes might not change–\n        // but updating cursor in this scenario would cause a flicker.\n        if (prevDeltaRef.current != delta) {\n          if (!sizesChanged) {\n            // If the pointer has moved too far to resize the panel any further,\n            // update the cursor style for a visual clue.\n            // This mimics VS Code behavior.\n\n            if (isHorizontal) {\n              setGlobalCursorStyle(movement < 0 ? \"horizontal-min\" : \"horizontal-max\");\n            } else {\n              setGlobalCursorStyle(movement < 0 ? \"vertical-min\" : \"vertical-max\");\n            }\n          } else {\n            // Reset the cursor style to the the normal resize cursor.\n            setGlobalCursorStyle(isHorizontal ? \"horizontal\" : \"vertical\");\n          }\n        }\n      }\n      if (sizesChanged) {\n        const panelIdToLastNotifiedSizeMap = panelIdToLastNotifiedSizeMapRef.current;\n\n        // It's okay to bypass in this case because we already validated above\n        setSizes(nextSizes);\n\n        // If resize change handlers have been declared, this is the time to call them.\n        // Trigger user callbacks after updating state, so that user code can override the sizes.\n        callPanelCallbacks(panelsArray, nextSizes, panelIdToLastNotifiedSizeMap);\n      }\n      prevDeltaRef.current = delta;\n    };\n    return resizeHandler;\n  }, [groupId]);\n  const unregisterPanel = useCallback(id => {\n    setPanels(prevPanels => {\n      if (!prevPanels.has(id)) {\n        return prevPanels;\n      }\n      const nextPanels = new Map(prevPanels);\n      nextPanels.delete(id);\n      return nextPanels;\n    });\n  }, []);\n  const collapsePanel = useCallback(id => {\n    const {\n      panels,\n      sizes: prevSizes\n    } = committedValuesRef.current;\n    const panel = panels.get(id);\n    if (panel == null) {\n      return;\n    }\n    const {\n      collapsedSize,\n      collapsible\n    } = panel.current;\n    if (!collapsible) {\n      return;\n    }\n    const panelsArray = panelsMapToSortedArray(panels);\n    const index = panelsArray.indexOf(panel);\n    if (index < 0) {\n      return;\n    }\n    const currentSize = prevSizes[index];\n    if (currentSize === collapsedSize) {\n      // Panel is already collapsed.\n      return;\n    }\n    panelSizeBeforeCollapse.current.set(id, currentSize);\n    const [idBefore, idAfter] = getBeforeAndAfterIds(id, panelsArray);\n    if (idBefore == null || idAfter == null) {\n      return;\n    }\n    const isLastPanel = index === panelsArray.length - 1;\n    const delta = isLastPanel ? currentSize : collapsedSize - currentSize;\n    const nextSizes = adjustByDelta(null, committedValuesRef.current, idBefore, idAfter, delta, prevSizes, panelSizeBeforeCollapse.current, null);\n    if (prevSizes !== nextSizes) {\n      const panelIdToLastNotifiedSizeMap = panelIdToLastNotifiedSizeMapRef.current;\n      setSizes(nextSizes);\n\n      // If resize change handlers have been declared, this is the time to call them.\n      // Trigger user callbacks after updating state, so that user code can override the sizes.\n      callPanelCallbacks(panelsArray, nextSizes, panelIdToLastNotifiedSizeMap);\n    }\n  }, []);\n  const expandPanel = useCallback(id => {\n    const {\n      panels,\n      sizes: prevSizes\n    } = committedValuesRef.current;\n    const panel = panels.get(id);\n    if (panel == null) {\n      return;\n    }\n    const {\n      collapsedSize,\n      minSize\n    } = panel.current;\n    const sizeBeforeCollapse = panelSizeBeforeCollapse.current.get(id) || minSize;\n    if (!sizeBeforeCollapse) {\n      return;\n    }\n    const panelsArray = panelsMapToSortedArray(panels);\n    const index = panelsArray.indexOf(panel);\n    if (index < 0) {\n      return;\n    }\n    const currentSize = prevSizes[index];\n    if (currentSize !== collapsedSize) {\n      // Panel is already expanded.\n      return;\n    }\n    const [idBefore, idAfter] = getBeforeAndAfterIds(id, panelsArray);\n    if (idBefore == null || idAfter == null) {\n      return;\n    }\n    const isLastPanel = index === panelsArray.length - 1;\n    const delta = isLastPanel ? collapsedSize - sizeBeforeCollapse : sizeBeforeCollapse;\n    const nextSizes = adjustByDelta(null, committedValuesRef.current, idBefore, idAfter, delta, prevSizes, panelSizeBeforeCollapse.current, null);\n    if (prevSizes !== nextSizes) {\n      const panelIdToLastNotifiedSizeMap = panelIdToLastNotifiedSizeMapRef.current;\n      setSizes(nextSizes);\n\n      // If resize change handlers have been declared, this is the time to call them.\n      // Trigger user callbacks after updating state, so that user code can override the sizes.\n      callPanelCallbacks(panelsArray, nextSizes, panelIdToLastNotifiedSizeMap);\n    }\n  }, []);\n  const resizePanel = useCallback((id, nextSize, unitsFromParams) => {\n    const {\n      id: groupId,\n      panels,\n      sizes: prevSizes,\n      units\n    } = committedValuesRef.current;\n    if ((unitsFromParams || units) === \"pixels\") {\n      const groupSizePixels = getAvailableGroupSizePixels(groupId);\n      nextSize = nextSize / groupSizePixels * 100;\n    }\n    const panel = panels.get(id);\n    if (panel == null) {\n      return;\n    }\n    let {\n      collapsedSize,\n      collapsible,\n      maxSize,\n      minSize\n    } = panel.current;\n    if (units === \"pixels\") {\n      const groupSizePixels = getAvailableGroupSizePixels(groupId);\n      minSize = minSize / groupSizePixels * 100;\n      if (maxSize != null) {\n        maxSize = maxSize / groupSizePixels * 100;\n      }\n    }\n    const panelsArray = panelsMapToSortedArray(panels);\n    const index = panelsArray.indexOf(panel);\n    if (index < 0) {\n      return;\n    }\n    const currentSize = prevSizes[index];\n    if (currentSize === nextSize) {\n      return;\n    }\n    if (collapsible && nextSize === collapsedSize) ; else {\n      const unsafeNextSize = nextSize;\n      nextSize = Math.min(maxSize != null ? maxSize : 100, Math.max(minSize, nextSize));\n      {\n        if (unsafeNextSize !== nextSize) {\n          console.error(`Invalid size (${unsafeNextSize}) specified for Panel \"${panel.current.id}\" given the panel's min/max size constraints`);\n        }\n      }\n    }\n    const [idBefore, idAfter] = getBeforeAndAfterIds(id, panelsArray);\n    if (idBefore == null || idAfter == null) {\n      return;\n    }\n    const isLastPanel = index === panelsArray.length - 1;\n    const delta = isLastPanel ? currentSize - nextSize : nextSize - currentSize;\n    const nextSizes = adjustByDelta(null, committedValuesRef.current, idBefore, idAfter, delta, prevSizes, panelSizeBeforeCollapse.current, null);\n    if (prevSizes !== nextSizes) {\n      const panelIdToLastNotifiedSizeMap = panelIdToLastNotifiedSizeMapRef.current;\n      setSizes(nextSizes);\n\n      // If resize change handlers have been declared, this is the time to call them.\n      // Trigger user callbacks after updating state, so that user code can override the sizes.\n      callPanelCallbacks(panelsArray, nextSizes, panelIdToLastNotifiedSizeMap);\n    }\n  }, []);\n  const context = useMemo(() => ({\n    activeHandleId,\n    collapsePanel,\n    direction,\n    expandPanel,\n    getPanelSize,\n    getPanelStyle,\n    groupId,\n    registerPanel,\n    registerResizeHandle,\n    resizePanel,\n    startDragging: (id, event) => {\n      setActiveHandleId(id);\n      if (isMouseEvent(event) || isTouchEvent(event)) {\n        const handleElement = getResizeHandle(id);\n        initialDragStateRef.current = {\n          dragHandleRect: handleElement.getBoundingClientRect(),\n          dragOffset: getDragOffset(event, id, direction),\n          sizes: committedValuesRef.current.sizes\n        };\n      }\n    },\n    stopDragging: () => {\n      resetGlobalCursorStyle();\n      setActiveHandleId(null);\n      initialDragStateRef.current = null;\n    },\n    units,\n    unregisterPanel\n  }), [activeHandleId, collapsePanel, direction, expandPanel, getPanelSize, getPanelStyle, groupId, registerPanel, registerResizeHandle, resizePanel, units, unregisterPanel]);\n  const style = {\n    display: \"flex\",\n    flexDirection: direction === \"horizontal\" ? \"row\" : \"column\",\n    height: \"100%\",\n    overflow: \"hidden\",\n    width: \"100%\"\n  };\n  return createElement(PanelGroupContext.Provider, {\n    children: createElement(Type, {\n      children,\n      className: classNameFromProps,\n      \"data-panel-group\": \"\",\n      \"data-panel-group-direction\": direction,\n      \"data-panel-group-id\": groupId,\n      \"data-panel-group-units\": units,\n      style: {\n        ...style,\n        ...styleFromProps\n      }\n    }),\n    value: context\n  });\n}\nconst PanelGroup = forwardRef((props, ref) => createElement(PanelGroupWithForwardedRef, {\n  ...props,\n  forwardedRef: ref\n}));\nPanelGroupWithForwardedRef.displayName = \"PanelGroup\";\nPanelGroup.displayName = \"forwardRef(PanelGroup)\";\n\nfunction PanelResizeHandle({\n  children = null,\n  className: classNameFromProps = \"\",\n  disabled = false,\n  id: idFromProps = null,\n  onDragging,\n  style: styleFromProps = {},\n  tagName: Type = \"div\"\n}) {\n  const divElementRef = useRef(null);\n\n  // Use a ref to guard against users passing inline props\n  const callbacksRef = useRef({\n    onDragging\n  });\n  useEffect(() => {\n    callbacksRef.current.onDragging = onDragging;\n  });\n  const panelGroupContext = useContext(PanelGroupContext);\n  if (panelGroupContext === null) {\n    throw Error(`PanelResizeHandle components must be rendered within a PanelGroup container`);\n  }\n  const {\n    activeHandleId,\n    direction,\n    groupId,\n    registerResizeHandle,\n    startDragging,\n    stopDragging\n  } = panelGroupContext;\n  const resizeHandleId = useUniqueId(idFromProps);\n  const isDragging = activeHandleId === resizeHandleId;\n  const [isFocused, setIsFocused] = useState(false);\n  const [resizeHandler, setResizeHandler] = useState(null);\n  const stopDraggingAndBlur = useCallback(() => {\n    // Clicking on the drag handle shouldn't leave it focused;\n    // That would cause the PanelGroup to think it was still active.\n    const div = divElementRef.current;\n    div.blur();\n    stopDragging();\n    const {\n      onDragging\n    } = callbacksRef.current;\n    if (onDragging) {\n      onDragging(false);\n    }\n  }, [stopDragging]);\n  useEffect(() => {\n    if (disabled) {\n      setResizeHandler(null);\n    } else {\n      const resizeHandler = registerResizeHandle(resizeHandleId);\n      setResizeHandler(() => resizeHandler);\n    }\n  }, [disabled, resizeHandleId, registerResizeHandle]);\n  useEffect(() => {\n    if (disabled || resizeHandler == null || !isDragging) {\n      return;\n    }\n    const onMove = event => {\n      resizeHandler(event);\n    };\n    const onMouseLeave = event => {\n      resizeHandler(event);\n    };\n    const divElement = divElementRef.current;\n    const targetDocument = divElement.ownerDocument;\n    targetDocument.body.addEventListener(\"contextmenu\", stopDraggingAndBlur);\n    targetDocument.body.addEventListener(\"mousemove\", onMove);\n    targetDocument.body.addEventListener(\"touchmove\", onMove);\n    targetDocument.body.addEventListener(\"mouseleave\", onMouseLeave);\n    window.addEventListener(\"mouseup\", stopDraggingAndBlur);\n    window.addEventListener(\"touchend\", stopDraggingAndBlur);\n    return () => {\n      targetDocument.body.removeEventListener(\"contextmenu\", stopDraggingAndBlur);\n      targetDocument.body.removeEventListener(\"mousemove\", onMove);\n      targetDocument.body.removeEventListener(\"touchmove\", onMove);\n      targetDocument.body.removeEventListener(\"mouseleave\", onMouseLeave);\n      window.removeEventListener(\"mouseup\", stopDraggingAndBlur);\n      window.removeEventListener(\"touchend\", stopDraggingAndBlur);\n    };\n  }, [direction, disabled, isDragging, resizeHandler, stopDraggingAndBlur]);\n  useWindowSplitterResizeHandlerBehavior({\n    disabled,\n    handleId: resizeHandleId,\n    resizeHandler\n  });\n  const style = {\n    cursor: getCursorStyle(direction),\n    touchAction: \"none\",\n    userSelect: \"none\"\n  };\n  return createElement(Type, {\n    children,\n    className: classNameFromProps,\n    \"data-resize-handle-active\": isDragging ? \"pointer\" : isFocused ? \"keyboard\" : undefined,\n    \"data-panel-group-direction\": direction,\n    \"data-panel-group-id\": groupId,\n    \"data-panel-resize-handle-enabled\": !disabled,\n    \"data-panel-resize-handle-id\": resizeHandleId,\n    onBlur: () => setIsFocused(false),\n    onFocus: () => setIsFocused(true),\n    onMouseDown: event => {\n      startDragging(resizeHandleId, event.nativeEvent);\n      const {\n        onDragging\n      } = callbacksRef.current;\n      if (onDragging) {\n        onDragging(true);\n      }\n    },\n    onMouseUp: stopDraggingAndBlur,\n    onTouchCancel: stopDraggingAndBlur,\n    onTouchEnd: stopDraggingAndBlur,\n    onTouchStart: event => {\n      startDragging(resizeHandleId, event.nativeEvent);\n      const {\n        onDragging\n      } = callbacksRef.current;\n      if (onDragging) {\n        onDragging(true);\n      }\n    },\n    ref: divElementRef,\n    role: \"separator\",\n    style: {\n      ...style,\n      ...styleFromProps\n    },\n    tabIndex: 0\n  });\n}\nPanelResizeHandle.displayName = \"PanelResizeHandle\";\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtcmVzaXphYmxlLXBhbmVsc0AwLjAuNTVfcmVhY3QtZG9tQDE4LjIuMF9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL3JlYWN0LXJlc2l6YWJsZS1wYW5lbHMvZGlzdC9yZWFjdC1yZXNpemFibGUtcGFuZWxzLmJyb3dzZXIuZGV2ZWxvcG1lbnQuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUErQjs7QUFFL0I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLGtDQUFLOztBQUVULDJEQUEyRCxRQUFRO0FBQ25FLGNBQWMsa0NBQUs7O0FBRW5COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsNEJBQTRCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQiw0QkFBNEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNEJBQTRCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxnREFBZ0QsaUNBQWlDO0FBQ3pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxHQUFHO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxHQUFHO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxHQUFHO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvR0FBb0csUUFBUTtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsUUFBUTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsUUFBUTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxZQUFZO0FBQ3pFO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSx3Q0FBd0MsUUFBUSx3Q0FBd0MsWUFBWTtBQUNwRztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esd0NBQXdDLFFBQVEscUNBQXFDLFlBQVk7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLDRCQUE0QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFNBQVMseUJBQXlCLGlCQUFpQjtBQUMxRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDRCQUE0QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsZ0RBQWdELG9CQUFvQjtBQUM3SDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSwyREFBMkQsUUFBUTtBQUNuRTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixVQUFVLE1BQU0sWUFBWTtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sc0JBQXNCLE1BQU0sR0FBRyxRQUFRLE9BQU8sUUFBUTtBQUN0RCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELFdBQVc7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxXQUFXO0FBQ25ELElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSCxtREFBbUQ7O0FBRW5EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGVBQWUseUJBQXlCLGlCQUFpQjtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUU2RSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlYWN0LXJlc2l6YWJsZS1wYW5lbHNAMC4wLjU1X3JlYWN0LWRvbUAxOC4yLjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9yZWFjdC1yZXNpemFibGUtcGFuZWxzL2Rpc3QvcmVhY3QtcmVzaXphYmxlLXBhbmVscy5icm93c2VyLmRldmVsb3BtZW50LmVzbS5qcz80NmFjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLy8gVGhpcyBtb2R1bGUgZXhpc3RzIHRvIHdvcmsgYXJvdW5kIFdlYnBhY2sgaXNzdWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2svd2VicGFjay9pc3N1ZXMvMTQ4MTRcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtaW1wb3J0c1xuXG5jb25zdCB7XG4gIGNyZWF0ZUVsZW1lbnQsXG4gIGNyZWF0ZUNvbnRleHQsXG4gIGZvcndhcmRSZWYsXG4gIHVzZUNhbGxiYWNrLFxuICB1c2VDb250ZXh0LFxuICB1c2VFZmZlY3QsXG4gIHVzZUltcGVyYXRpdmVIYW5kbGUsXG4gIHVzZUxheW91dEVmZmVjdCxcbiAgdXNlTWVtbyxcbiAgdXNlUmVmLFxuICB1c2VTdGF0ZVxufSA9IFJlYWN0O1xuXG4vLyBgdG9TdHJpbmcoKWAgcHJldmVudHMgYnVuZGxlcnMgZnJvbSB0cnlpbmcgdG8gYGltcG9ydCB7IHVzZUlkIH0gZnJvbSAncmVhY3QnYFxuY29uc3QgdXNlSWQgPSBSZWFjdFtcInVzZUlkXCIudG9TdHJpbmcoKV07XG5cbmNvbnN0IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSB1c2VMYXlvdXRFZmZlY3QgO1xuXG5jb25zdCB3cmFwcGVkVXNlSWQgPSB0eXBlb2YgdXNlSWQgPT09IFwiZnVuY3Rpb25cIiA/IHVzZUlkIDogKCkgPT4gbnVsbDtcbmxldCBjb3VudGVyID0gMDtcbmZ1bmN0aW9uIHVzZVVuaXF1ZUlkKGlkRnJvbVBhcmFtcyA9IG51bGwpIHtcbiAgY29uc3QgaWRGcm9tVXNlSWQgPSB3cmFwcGVkVXNlSWQoKTtcbiAgY29uc3QgaWRSZWYgPSB1c2VSZWYoaWRGcm9tUGFyYW1zIHx8IGlkRnJvbVVzZUlkIHx8IG51bGwpO1xuICBpZiAoaWRSZWYuY3VycmVudCA9PT0gbnVsbCkge1xuICAgIGlkUmVmLmN1cnJlbnQgPSBcIlwiICsgY291bnRlcisrO1xuICB9XG4gIHJldHVybiBpZFJlZi5jdXJyZW50O1xufVxuXG5jb25zdCBQYW5lbEdyb3VwQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCk7XG5QYW5lbEdyb3VwQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiUGFuZWxHcm91cENvbnRleHRcIjtcblxuZnVuY3Rpb24gUGFuZWxXaXRoRm9yd2FyZGVkUmVmKHtcbiAgY2hpbGRyZW4gPSBudWxsLFxuICBjbGFzc05hbWU6IGNsYXNzTmFtZUZyb21Qcm9wcyA9IFwiXCIsXG4gIGNvbGxhcHNlZFNpemUgPSAwLFxuICBjb2xsYXBzaWJsZSA9IGZhbHNlLFxuICBkZWZhdWx0U2l6ZSA9IG51bGwsXG4gIGZvcndhcmRlZFJlZixcbiAgaWQ6IGlkRnJvbVByb3BzID0gbnVsbCxcbiAgbWF4U2l6ZSA9IG51bGwsXG4gIG1pblNpemUsXG4gIG9uQ29sbGFwc2UgPSBudWxsLFxuICBvblJlc2l6ZSA9IG51bGwsXG4gIG9yZGVyID0gbnVsbCxcbiAgc3R5bGU6IHN0eWxlRnJvbVByb3BzID0ge30sXG4gIHRhZ05hbWU6IFR5cGUgPSBcImRpdlwiXG59KSB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KFBhbmVsR3JvdXBDb250ZXh0KTtcbiAgaWYgKGNvbnRleHQgPT09IG51bGwpIHtcbiAgICB0aHJvdyBFcnJvcihgUGFuZWwgY29tcG9uZW50cyBtdXN0IGJlIHJlbmRlcmVkIHdpdGhpbiBhIFBhbmVsR3JvdXAgY29udGFpbmVyYCk7XG4gIH1cbiAgY29uc3QgcGFuZWxJZCA9IHVzZVVuaXF1ZUlkKGlkRnJvbVByb3BzKTtcbiAgY29uc3Qge1xuICAgIGNvbGxhcHNlUGFuZWwsXG4gICAgZXhwYW5kUGFuZWwsXG4gICAgZ2V0UGFuZWxTaXplLFxuICAgIGdldFBhbmVsU3R5bGUsXG4gICAgcmVnaXN0ZXJQYW5lbCxcbiAgICByZXNpemVQYW5lbCxcbiAgICB1bml0cyxcbiAgICB1bnJlZ2lzdGVyUGFuZWxcbiAgfSA9IGNvbnRleHQ7XG4gIGlmIChtaW5TaXplID09IG51bGwpIHtcbiAgICBpZiAodW5pdHMgPT09IFwicGVyY2VudGFnZXNcIikge1xuICAgICAgLy8gTWltaWNzIGxlZ2FjeSBkZWZhdWx0IHZhbHVlIGZvciBwZXJjZW50YWdlIGJhc2VkIHBhbmVsIGdyb3Vwc1xuICAgICAgbWluU2l6ZSA9IDEwO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGVyZSBpcyBubyBtZWFuaW5nZnVsIG1pbmltdW0gcGl4ZWwgZGVmYXVsdCB3ZSBjYW4gcHJvdmlkZVxuICAgICAgbWluU2l6ZSA9IDA7XG4gICAgfVxuICB9XG5cbiAgLy8gVXNlIGEgcmVmIHRvIGd1YXJkIGFnYWluc3QgdXNlcnMgcGFzc2luZyBpbmxpbmUgcHJvcHNcbiAgY29uc3QgY2FsbGJhY2tzUmVmID0gdXNlUmVmKHtcbiAgICBvbkNvbGxhcHNlLFxuICAgIG9uUmVzaXplXG4gIH0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNhbGxiYWNrc1JlZi5jdXJyZW50Lm9uQ29sbGFwc2UgPSBvbkNvbGxhcHNlO1xuICAgIGNhbGxiYWNrc1JlZi5jdXJyZW50Lm9uUmVzaXplID0gb25SZXNpemU7XG4gIH0pO1xuICBjb25zdCBzdHlsZSA9IGdldFBhbmVsU3R5bGUocGFuZWxJZCwgZGVmYXVsdFNpemUpO1xuICBjb25zdCBjb21taXR0ZWRWYWx1ZXNSZWYgPSB1c2VSZWYoe1xuICAgIHNpemU6IHBhcnNlU2l6ZUZyb21TdHlsZShzdHlsZSlcbiAgfSk7XG4gIGNvbnN0IHBhbmVsRGF0YVJlZiA9IHVzZVJlZih7XG4gICAgY2FsbGJhY2tzUmVmLFxuICAgIGNvbGxhcHNlZFNpemUsXG4gICAgY29sbGFwc2libGUsXG4gICAgZGVmYXVsdFNpemUsXG4gICAgaWQ6IHBhbmVsSWQsXG4gICAgaWRXYXNBdXRvR2VuZXJhdGVkOiBpZEZyb21Qcm9wcyA9PSBudWxsLFxuICAgIG1heFNpemUsXG4gICAgbWluU2l6ZSxcbiAgICBvcmRlclxuICB9KTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgY29tbWl0dGVkVmFsdWVzUmVmLmN1cnJlbnQuc2l6ZSA9IHBhcnNlU2l6ZUZyb21TdHlsZShzdHlsZSk7XG4gICAgcGFuZWxEYXRhUmVmLmN1cnJlbnQuY2FsbGJhY2tzUmVmID0gY2FsbGJhY2tzUmVmO1xuICAgIHBhbmVsRGF0YVJlZi5jdXJyZW50LmNvbGxhcHNlZFNpemUgPSBjb2xsYXBzZWRTaXplO1xuICAgIHBhbmVsRGF0YVJlZi5jdXJyZW50LmNvbGxhcHNpYmxlID0gY29sbGFwc2libGU7XG4gICAgcGFuZWxEYXRhUmVmLmN1cnJlbnQuZGVmYXVsdFNpemUgPSBkZWZhdWx0U2l6ZTtcbiAgICBwYW5lbERhdGFSZWYuY3VycmVudC5pZCA9IHBhbmVsSWQ7XG4gICAgcGFuZWxEYXRhUmVmLmN1cnJlbnQuaWRXYXNBdXRvR2VuZXJhdGVkID0gaWRGcm9tUHJvcHMgPT0gbnVsbDtcbiAgICBwYW5lbERhdGFSZWYuY3VycmVudC5tYXhTaXplID0gbWF4U2l6ZTtcbiAgICBwYW5lbERhdGFSZWYuY3VycmVudC5taW5TaXplID0gbWluU2l6ZTtcbiAgICBwYW5lbERhdGFSZWYuY3VycmVudC5vcmRlciA9IG9yZGVyO1xuICB9KTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgcmVnaXN0ZXJQYW5lbChwYW5lbElkLCBwYW5lbERhdGFSZWYpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB1bnJlZ2lzdGVyUGFuZWwocGFuZWxJZCk7XG4gICAgfTtcbiAgfSwgW29yZGVyLCBwYW5lbElkLCByZWdpc3RlclBhbmVsLCB1bnJlZ2lzdGVyUGFuZWxdKTtcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZShmb3J3YXJkZWRSZWYsICgpID0+ICh7XG4gICAgY29sbGFwc2U6ICgpID0+IGNvbGxhcHNlUGFuZWwocGFuZWxJZCksXG4gICAgZXhwYW5kOiAoKSA9PiBleHBhbmRQYW5lbChwYW5lbElkKSxcbiAgICBnZXRDb2xsYXBzZWQoKSB7XG4gICAgICByZXR1cm4gY29tbWl0dGVkVmFsdWVzUmVmLmN1cnJlbnQuc2l6ZSA9PT0gMDtcbiAgICB9LFxuICAgIGdldElkKCkge1xuICAgICAgcmV0dXJuIHBhbmVsSWQ7XG4gICAgfSxcbiAgICBnZXRTaXplKHVuaXRzKSB7XG4gICAgICByZXR1cm4gZ2V0UGFuZWxTaXplKHBhbmVsSWQsIHVuaXRzKTtcbiAgICB9LFxuICAgIHJlc2l6ZTogKHBlcmNlbnRhZ2UsIHVuaXRzKSA9PiByZXNpemVQYW5lbChwYW5lbElkLCBwZXJjZW50YWdlLCB1bml0cylcbiAgfSksIFtjb2xsYXBzZVBhbmVsLCBleHBhbmRQYW5lbCwgZ2V0UGFuZWxTaXplLCBwYW5lbElkLCByZXNpemVQYW5lbF0pO1xuICByZXR1cm4gY3JlYXRlRWxlbWVudChUeXBlLCB7XG4gICAgY2hpbGRyZW4sXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWVGcm9tUHJvcHMsXG4gICAgXCJkYXRhLXBhbmVsXCI6IFwiXCIsXG4gICAgXCJkYXRhLXBhbmVsLWNvbGxhcHNpYmxlXCI6IGNvbGxhcHNpYmxlIHx8IHVuZGVmaW5lZCxcbiAgICBcImRhdGEtcGFuZWwtaWRcIjogcGFuZWxJZCxcbiAgICBcImRhdGEtcGFuZWwtc2l6ZVwiOiBwYXJzZUZsb2F0KFwiXCIgKyBzdHlsZS5mbGV4R3JvdykudG9GaXhlZCgxKSxcbiAgICBpZDogYGRhdGEtcGFuZWwtaWQtJHtwYW5lbElkfWAsXG4gICAgc3R5bGU6IHtcbiAgICAgIC4uLnN0eWxlLFxuICAgICAgLi4uc3R5bGVGcm9tUHJvcHNcbiAgICB9XG4gIH0pO1xufVxuY29uc3QgUGFuZWwgPSBmb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiBjcmVhdGVFbGVtZW50KFBhbmVsV2l0aEZvcndhcmRlZFJlZiwge1xuICAuLi5wcm9wcyxcbiAgZm9yd2FyZGVkUmVmOiByZWZcbn0pKTtcblBhbmVsV2l0aEZvcndhcmRlZFJlZi5kaXNwbGF5TmFtZSA9IFwiUGFuZWxcIjtcblBhbmVsLmRpc3BsYXlOYW1lID0gXCJmb3J3YXJkUmVmKFBhbmVsKVwiO1xuXG4vLyBIQUNLXG5mdW5jdGlvbiBwYXJzZVNpemVGcm9tU3R5bGUoc3R5bGUpIHtcbiAgY29uc3Qge1xuICAgIGZsZXhHcm93XG4gIH0gPSBzdHlsZTtcbiAgaWYgKHR5cGVvZiBmbGV4R3JvdyA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KGZsZXhHcm93KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmxleEdyb3c7XG4gIH1cbn1cblxuY29uc3QgUFJFQ0lTSU9OID0gMTA7XG5cbmZ1bmN0aW9uIGFkanVzdEJ5RGVsdGEoZXZlbnQsIGNvbW1pdHRlZFZhbHVlcywgaWRCZWZvcmUsIGlkQWZ0ZXIsIGRlbHRhUGl4ZWxzLCBwcmV2U2l6ZXMsIHBhbmVsU2l6ZUJlZm9yZUNvbGxhcHNlLCBpbml0aWFsRHJhZ1N0YXRlKSB7XG4gIGNvbnN0IHtcbiAgICBpZDogZ3JvdXBJZCxcbiAgICBwYW5lbHMsXG4gICAgdW5pdHNcbiAgfSA9IGNvbW1pdHRlZFZhbHVlcztcbiAgY29uc3QgZ3JvdXBTaXplUGl4ZWxzID0gdW5pdHMgPT09IFwicGl4ZWxzXCIgPyBnZXRBdmFpbGFibGVHcm91cFNpemVQaXhlbHMoZ3JvdXBJZCkgOiBOYU47XG4gIGNvbnN0IHtcbiAgICBzaXplczogaW5pdGlhbFNpemVzXG4gIH0gPSBpbml0aWFsRHJhZ1N0YXRlIHx8IHt9O1xuXG4gIC8vIElmIHdlJ3JlIHJlc2l6aW5nIGJ5IG1vdXNlIG9yIHRvdWNoLCB1c2UgdGhlIGluaXRpYWwgc2l6ZXMgYXMgYSBiYXNlLlxuICAvLyBUaGlzIGhhcyB0aGUgYmVuZWZpdCBvZiBjYXVzaW5nIGZvcmNlLWNvbGxhcHNlZCBwYW5lbHMgdG8gc3ByaW5nIGJhY2sgb3BlbiBpZiBkcmFnIGlzIHJldmVyc2VkLlxuICBjb25zdCBiYXNlU2l6ZXMgPSBpbml0aWFsU2l6ZXMgfHwgcHJldlNpemVzO1xuICBjb25zdCBwYW5lbHNBcnJheSA9IHBhbmVsc01hcFRvU29ydGVkQXJyYXkocGFuZWxzKTtcbiAgY29uc3QgbmV4dFNpemVzID0gYmFzZVNpemVzLmNvbmNhdCgpO1xuICBsZXQgZGVsdGFBcHBsaWVkID0gMDtcblxuICAvLyBBIHJlc2l6aW5nIHBhbmVsIGFmZmVjdHMgdGhlIHBhbmVscyBiZWZvcmUgb3IgYWZ0ZXIgaXQuXG4gIC8vXG4gIC8vIEEgbmVnYXRpdmUgZGVsdGEgbWVhbnMgdGhlIHBhbmVsIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSByZXNpemVyIHNob3VsZCBncm93L2V4cGFuZCBieSBkZWNyZWFzaW5nIGl0cyBvZmZzZXQuXG4gIC8vIE90aGVyIHBhbmVscyBtYXkgYWxzbyBuZWVkIHRvIHNocmluay9jb250cmFjdCAoYW5kIHNoaWZ0KSB0byBtYWtlIHJvb20sIGRlcGVuZGluZyBvbiB0aGUgbWluIHdlaWdodHMuXG4gIC8vXG4gIC8vIEEgcG9zaXRpdmUgZGVsdGEgbWVhbnMgdGhlIHBhbmVsIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgcmVzaXplciBzaG91bGQgXCJleHBhbmRcIi5cbiAgLy8gVGhpcyBpcyBhY2NvbXBsaXNoZWQgYnkgc2hyaW5raW5nL2NvbnRyYWN0aW5nIChhbmQgc2hpZnRpbmcpIG9uZSBvciBtb3JlIG9mIHRoZSBwYW5lbHMgYWZ0ZXIgdGhlIHJlc2l6ZXIuXG5cbiAgLy8gTWF4LWJvdW5kcyBjaGVjayB0aGUgcGFuZWwgYmVpbmcgZXhwYW5kZWQgZmlyc3QuXG4gIHtcbiAgICBjb25zdCBwaXZvdElkID0gZGVsdGFQaXhlbHMgPCAwID8gaWRBZnRlciA6IGlkQmVmb3JlO1xuICAgIGNvbnN0IGluZGV4ID0gcGFuZWxzQXJyYXkuZmluZEluZGV4KHBhbmVsID0+IHBhbmVsLmN1cnJlbnQuaWQgPT09IHBpdm90SWQpO1xuICAgIGNvbnN0IHBhbmVsID0gcGFuZWxzQXJyYXlbaW5kZXhdO1xuICAgIGNvbnN0IGJhc2VTaXplID0gYmFzZVNpemVzW2luZGV4XTtcbiAgICBjb25zdCBuZXh0U2l6ZSA9IHNhZmVSZXNpemVQYW5lbCh1bml0cywgZ3JvdXBTaXplUGl4ZWxzLCBwYW5lbCwgYmFzZVNpemUsIGJhc2VTaXplICsgTWF0aC5hYnMoZGVsdGFQaXhlbHMpLCBldmVudCk7XG4gICAgaWYgKGJhc2VTaXplID09PSBuZXh0U2l6ZSkge1xuICAgICAgLy8gSWYgdGhlcmUncyBubyByb29tIGZvciB0aGUgcGl2b3QgcGFuZWwgdG8gZ3Jvdywgd2UgY2FuIGlnbm9yZSB0aGlzIGRyYWcgdXBkYXRlLlxuICAgICAgcmV0dXJuIGJhc2VTaXplcztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG5leHRTaXplID09PSAwICYmIGJhc2VTaXplID4gMCkge1xuICAgICAgICBwYW5lbFNpemVCZWZvcmVDb2xsYXBzZS5zZXQocGl2b3RJZCwgYmFzZVNpemUpO1xuICAgICAgfVxuICAgICAgZGVsdGFQaXhlbHMgPSBkZWx0YVBpeGVscyA8IDAgPyBiYXNlU2l6ZSAtIG5leHRTaXplIDogbmV4dFNpemUgLSBiYXNlU2l6ZTtcbiAgICB9XG4gIH1cbiAgbGV0IHBpdm90SWQgPSBkZWx0YVBpeGVscyA8IDAgPyBpZEJlZm9yZSA6IGlkQWZ0ZXI7XG4gIGxldCBpbmRleCA9IHBhbmVsc0FycmF5LmZpbmRJbmRleChwYW5lbCA9PiBwYW5lbC5jdXJyZW50LmlkID09PSBwaXZvdElkKTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCBwYW5lbCA9IHBhbmVsc0FycmF5W2luZGV4XTtcbiAgICBjb25zdCBiYXNlU2l6ZSA9IGJhc2VTaXplc1tpbmRleF07XG4gICAgY29uc3QgZGVsdGFSZW1haW5pbmcgPSBNYXRoLmFicyhkZWx0YVBpeGVscykgLSBNYXRoLmFicyhkZWx0YUFwcGxpZWQpO1xuICAgIGNvbnN0IG5leHRTaXplID0gc2FmZVJlc2l6ZVBhbmVsKHVuaXRzLCBncm91cFNpemVQaXhlbHMsIHBhbmVsLCBiYXNlU2l6ZSwgYmFzZVNpemUgLSBkZWx0YVJlbWFpbmluZywgZXZlbnQpO1xuICAgIGlmIChiYXNlU2l6ZSAhPT0gbmV4dFNpemUpIHtcbiAgICAgIGlmIChuZXh0U2l6ZSA9PT0gMCAmJiBiYXNlU2l6ZSA+IDApIHtcbiAgICAgICAgcGFuZWxTaXplQmVmb3JlQ29sbGFwc2Uuc2V0KHBhbmVsLmN1cnJlbnQuaWQsIGJhc2VTaXplKTtcbiAgICAgIH1cbiAgICAgIGRlbHRhQXBwbGllZCArPSBiYXNlU2l6ZSAtIG5leHRTaXplO1xuICAgICAgbmV4dFNpemVzW2luZGV4XSA9IG5leHRTaXplO1xuICAgICAgaWYgKGRlbHRhQXBwbGllZC50b1ByZWNpc2lvbihQUkVDSVNJT04pLmxvY2FsZUNvbXBhcmUoTWF0aC5hYnMoZGVsdGFQaXhlbHMpLnRvUHJlY2lzaW9uKFBSRUNJU0lPTiksIHVuZGVmaW5lZCwge1xuICAgICAgICBudW1lcmljOiB0cnVlXG4gICAgICB9KSA+PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGVsdGFQaXhlbHMgPCAwKSB7XG4gICAgICBpZiAoLS1pbmRleCA8IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICgrK2luZGV4ID49IHBhbmVsc0FycmF5Lmxlbmd0aCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBJZiB3ZSB3ZXJlIHVuYWJsZSB0byByZXNpemUgYW55IG9mIHRoZSBwYW5lbHMgcGFuZWxzLCByZXR1cm4gdGhlIHByZXZpb3VzIHN0YXRlLlxuICAvLyBUaGlzIHdpbGwgZXNzZW50aWFsbHkgYmFpbG91dCBhbmQgaWdub3JlIHRoZSBcIm1vdXNlbW92ZVwiIGV2ZW50LlxuICBpZiAoZGVsdGFBcHBsaWVkID09PSAwKSB7XG4gICAgcmV0dXJuIGJhc2VTaXplcztcbiAgfVxuXG4gIC8vIEFkanVzdCB0aGUgcGl2b3QgcGFuZWwgYmVmb3JlLCBidXQgb25seSBieSB0aGUgYW1vdW50IHRoYXQgc3Vycm91bmRpbmcgcGFuZWxzIHdlcmUgYWJsZSB0byBzaHJpbmsvY29udHJhY3QuXG4gIHBpdm90SWQgPSBkZWx0YVBpeGVscyA8IDAgPyBpZEFmdGVyIDogaWRCZWZvcmU7XG4gIGluZGV4ID0gcGFuZWxzQXJyYXkuZmluZEluZGV4KHBhbmVsID0+IHBhbmVsLmN1cnJlbnQuaWQgPT09IHBpdm90SWQpO1xuICBuZXh0U2l6ZXNbaW5kZXhdID0gYmFzZVNpemVzW2luZGV4XSArIGRlbHRhQXBwbGllZDtcbiAgcmV0dXJuIG5leHRTaXplcztcbn1cbmZ1bmN0aW9uIGNhbGxQYW5lbENhbGxiYWNrcyhwYW5lbHNBcnJheSwgc2l6ZXMsIHBhbmVsSWRUb0xhc3ROb3RpZmllZFNpemVNYXApIHtcbiAgc2l6ZXMuZm9yRWFjaCgoc2l6ZSwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBwYW5lbFJlZiA9IHBhbmVsc0FycmF5W2luZGV4XTtcbiAgICBpZiAoIXBhbmVsUmVmKSB7XG4gICAgICAvLyBIYW5kbGUgaW5pdGlhbCBtb3VudCAod2hlbiBwYW5lbHMgYXJlIHJlZ2lzdGVyZWQgdG9vIGxhdGUgdG8gYmUgaW4gdGhlIHBhbmVscyBhcnJheSlcbiAgICAgIC8vIFRoZSBzdWJzZXF1ZW50IHJlbmRlcitlZmZlY3RzIHdpbGwgaGFuZGxlIHRoZSByZXNpemUgbm90aWZpY2F0aW9uXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGNhbGxiYWNrc1JlZixcbiAgICAgIGNvbGxhcHNlZFNpemUsXG4gICAgICBjb2xsYXBzaWJsZSxcbiAgICAgIGlkXG4gICAgfSA9IHBhbmVsUmVmLmN1cnJlbnQ7XG4gICAgY29uc3QgbGFzdE5vdGlmaWVkU2l6ZSA9IHBhbmVsSWRUb0xhc3ROb3RpZmllZFNpemVNYXBbaWRdO1xuICAgIGlmIChsYXN0Tm90aWZpZWRTaXplICE9PSBzaXplKSB7XG4gICAgICBwYW5lbElkVG9MYXN0Tm90aWZpZWRTaXplTWFwW2lkXSA9IHNpemU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG9uQ29sbGFwc2UsXG4gICAgICAgIG9uUmVzaXplXG4gICAgICB9ID0gY2FsbGJhY2tzUmVmLmN1cnJlbnQ7XG4gICAgICBpZiAob25SZXNpemUpIHtcbiAgICAgICAgb25SZXNpemUoc2l6ZSwgbGFzdE5vdGlmaWVkU2l6ZSk7XG4gICAgICB9XG4gICAgICBpZiAoY29sbGFwc2libGUgJiYgb25Db2xsYXBzZSkge1xuICAgICAgICBpZiAoKGxhc3ROb3RpZmllZFNpemUgPT0gbnVsbCB8fCBsYXN0Tm90aWZpZWRTaXplID09PSBjb2xsYXBzZWRTaXplKSAmJiBzaXplICE9PSBjb2xsYXBzZWRTaXplKSB7XG4gICAgICAgICAgb25Db2xsYXBzZShmYWxzZSk7XG4gICAgICAgIH0gZWxzZSBpZiAobGFzdE5vdGlmaWVkU2l6ZSAhPT0gY29sbGFwc2VkU2l6ZSAmJiBzaXplID09PSBjb2xsYXBzZWRTaXplKSB7XG4gICAgICAgICAgb25Db2xsYXBzZSh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVEZWZhdWx0TGF5b3V0KHtcbiAgZ3JvdXBJZCxcbiAgcGFuZWxzLFxuICB1bml0c1xufSkge1xuICBjb25zdCBncm91cFNpemVQaXhlbHMgPSB1bml0cyA9PT0gXCJwaXhlbHNcIiA/IGdldEF2YWlsYWJsZUdyb3VwU2l6ZVBpeGVscyhncm91cElkKSA6IE5hTjtcbiAgY29uc3QgcGFuZWxzQXJyYXkgPSBwYW5lbHNNYXBUb1NvcnRlZEFycmF5KHBhbmVscyk7XG4gIGNvbnN0IHNpemVzID0gQXJyYXkocGFuZWxzQXJyYXkubGVuZ3RoKTtcbiAgbGV0IG51bVBhbmVsc1dpdGhTaXplcyA9IDA7XG4gIGxldCByZW1haW5pbmdTaXplID0gMTAwO1xuXG4gIC8vIEFzc2lnbmluZyBkZWZhdWx0IHNpemVzIHJlcXVpcmVzIGEgY291cGxlIG9mIHBhc3NlczpcbiAgLy8gRmlyc3QsIGFsbCBwYW5lbHMgd2l0aCBkZWZhdWx0U2l6ZSBzaG91bGQgYmUgc2V0IGFzLWlzXG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBwYW5lbHNBcnJheS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBjb25zdCBwYW5lbCA9IHBhbmVsc0FycmF5W2luZGV4XTtcbiAgICBjb25zdCB7XG4gICAgICBkZWZhdWx0U2l6ZVxuICAgIH0gPSBwYW5lbC5jdXJyZW50O1xuICAgIGlmIChkZWZhdWx0U2l6ZSAhPSBudWxsKSB7XG4gICAgICBudW1QYW5lbHNXaXRoU2l6ZXMrKztcbiAgICAgIHNpemVzW2luZGV4XSA9IHVuaXRzID09PSBcInBpeGVsc1wiID8gZGVmYXVsdFNpemUgLyBncm91cFNpemVQaXhlbHMgKiAxMDAgOiBkZWZhdWx0U2l6ZTtcbiAgICAgIHJlbWFpbmluZ1NpemUgLT0gc2l6ZXNbaW5kZXhdO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlbWFpbmluZyB0b3RhbCBzaXplIHNob3VsZCBiZSBkaXN0cmlidXRlZCBldmVubHkgYmV0d2VlbiBwYW5lbHNcbiAgLy8gVGhpcyBtYXkgcmVxdWlyZSB0d28gcGFzc2VzLCBkZXBlbmRpbmcgb24gbWluL21heCBjb25zdHJhaW50c1xuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcGFuZWxzQXJyYXkubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgY29uc3QgcGFuZWwgPSBwYW5lbHNBcnJheVtpbmRleF07XG4gICAgbGV0IHtcbiAgICAgIGRlZmF1bHRTaXplLFxuICAgICAgaWQsXG4gICAgICBtYXhTaXplLFxuICAgICAgbWluU2l6ZVxuICAgIH0gPSBwYW5lbC5jdXJyZW50O1xuICAgIGlmIChkZWZhdWx0U2l6ZSAhPSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHVuaXRzID09PSBcInBpeGVsc1wiKSB7XG4gICAgICBtaW5TaXplID0gbWluU2l6ZSAvIGdyb3VwU2l6ZVBpeGVscyAqIDEwMDtcbiAgICAgIGlmIChtYXhTaXplICE9IG51bGwpIHtcbiAgICAgICAgbWF4U2l6ZSA9IG1heFNpemUgLyBncm91cFNpemVQaXhlbHMgKiAxMDA7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlbWFpbmluZ1BhbmVscyA9IHBhbmVsc0FycmF5Lmxlbmd0aCAtIG51bVBhbmVsc1dpdGhTaXplcztcbiAgICBjb25zdCBzaXplID0gTWF0aC5taW4obWF4U2l6ZSAhPSBudWxsID8gbWF4U2l6ZSA6IDEwMCwgTWF0aC5tYXgobWluU2l6ZSwgcmVtYWluaW5nU2l6ZSAvIHJlbWFpbmluZ1BhbmVscykpO1xuICAgIHNpemVzW2luZGV4XSA9IHNpemU7XG4gICAgbnVtUGFuZWxzV2l0aFNpemVzKys7XG4gICAgcmVtYWluaW5nU2l6ZSAtPSBzaXplO1xuICB9XG5cbiAgLy8gSWYgdGhlcmUgaXMgYWRkaXRpb25hbCwgbGVmdCBvdmVyIHNwYWNlLCBhc3NpZ24gaXQgdG8gYW55IHBhbmVsKHMpIHRoYXQgcGVybWl0cyBpdFxuICAvLyAoSXQncyBub3Qgd29ydGggdGFraW5nIG11bHRpcGxlIGFkZGl0aW9uYWwgcGFzc2VzIHRvIGV2ZW5seSBkaXN0cmlidXRlKVxuICBpZiAocmVtYWluaW5nU2l6ZSAhPT0gMCkge1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBwYW5lbHNBcnJheS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGNvbnN0IHBhbmVsID0gcGFuZWxzQXJyYXlbaW5kZXhdO1xuICAgICAgbGV0IHtcbiAgICAgICAgbWF4U2l6ZSxcbiAgICAgICAgbWluU2l6ZVxuICAgICAgfSA9IHBhbmVsLmN1cnJlbnQ7XG4gICAgICBpZiAodW5pdHMgPT09IFwicGl4ZWxzXCIpIHtcbiAgICAgICAgbWluU2l6ZSA9IG1pblNpemUgLyBncm91cFNpemVQaXhlbHMgKiAxMDA7XG4gICAgICAgIGlmIChtYXhTaXplICE9IG51bGwpIHtcbiAgICAgICAgICBtYXhTaXplID0gbWF4U2l6ZSAvIGdyb3VwU2l6ZVBpeGVscyAqIDEwMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qgc2l6ZSA9IE1hdGgubWluKG1heFNpemUgIT0gbnVsbCA/IG1heFNpemUgOiAxMDAsIE1hdGgubWF4KG1pblNpemUsIHNpemVzW2luZGV4XSArIHJlbWFpbmluZ1NpemUpKTtcbiAgICAgIGlmIChzaXplICE9PSBzaXplc1tpbmRleF0pIHtcbiAgICAgICAgcmVtYWluaW5nU2l6ZSAtPSBzaXplIC0gc2l6ZXNbaW5kZXhdO1xuICAgICAgICBzaXplc1tpbmRleF0gPSBzaXplO1xuXG4gICAgICAgIC8vIEZ1enp5IGNvbXBhcmlzb24gdG8gYWNjb3VudCBmb3IgaW1wcmVjaXNlIGZsb2F0aW5nIHBvaW50IG1hdGhcbiAgICAgICAgaWYgKE1hdGguYWJzKHJlbWFpbmluZ1NpemUpLnRvRml4ZWQoMykgPT09IFwiMC4wMDBcIikge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gRmluYWxseSwgaWYgdGhlcmUgaXMgc3RpbGwgbGVmdC1vdmVyIHNpemUsIGxvZyBhbiBlcnJvclxuICBpZiAoTWF0aC5hYnMocmVtYWluaW5nU2l6ZSkudG9GaXhlZCgzKSAhPT0gXCIwLjAwMFwiKSB7XG4gICAge1xuICAgICAgY29uc29sZS5lcnJvcihgSW52YWxpZCBwYW5lbCBncm91cCBjb25maWd1cmF0aW9uOyBkZWZhdWx0IHBhbmVsIHNpemVzIHNob3VsZCB0b3RhbCAxMDAlIGJ1dCB3YXMgJHsoMTAwIC0gcmVtYWluaW5nU2l6ZSkudG9GaXhlZCgxKX0lLiBUaGlzIGNhbiBjYXVzZSB0aGUgY3Vyc29yIHRvIGJlY29tZSBtaXNhbGlnbmVkIHdoaWxlIGRyYWdnaW5nLmApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2l6ZXM7XG59XG5mdW5jdGlvbiBnZXRCZWZvcmVBbmRBZnRlcklkcyhpZCwgcGFuZWxzQXJyYXkpIHtcbiAgaWYgKHBhbmVsc0FycmF5Lmxlbmd0aCA8IDIpIHtcbiAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICB9XG4gIGNvbnN0IGluZGV4ID0gcGFuZWxzQXJyYXkuZmluZEluZGV4KHBhbmVsID0+IHBhbmVsLmN1cnJlbnQuaWQgPT09IGlkKTtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gIH1cbiAgY29uc3QgaXNMYXN0UGFuZWwgPSBpbmRleCA9PT0gcGFuZWxzQXJyYXkubGVuZ3RoIC0gMTtcbiAgY29uc3QgaWRCZWZvcmUgPSBpc0xhc3RQYW5lbCA/IHBhbmVsc0FycmF5W2luZGV4IC0gMV0uY3VycmVudC5pZCA6IGlkO1xuICBjb25zdCBpZEFmdGVyID0gaXNMYXN0UGFuZWwgPyBpZCA6IHBhbmVsc0FycmF5W2luZGV4ICsgMV0uY3VycmVudC5pZDtcbiAgcmV0dXJuIFtpZEJlZm9yZSwgaWRBZnRlcl07XG59XG5mdW5jdGlvbiBnZXRBdmFpbGFibGVHcm91cFNpemVQaXhlbHMoZ3JvdXBJZCkge1xuICBjb25zdCBwYW5lbEdyb3VwRWxlbWVudCA9IGdldFBhbmVsR3JvdXAoZ3JvdXBJZCk7XG4gIGlmIChwYW5lbEdyb3VwRWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIE5hTjtcbiAgfVxuICBjb25zdCBkaXJlY3Rpb24gPSBwYW5lbEdyb3VwRWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBhbmVsLWdyb3VwLWRpcmVjdGlvblwiKTtcbiAgY29uc3QgcmVzaXplSGFuZGxlcyA9IGdldFJlc2l6ZUhhbmRsZXNGb3JHcm91cChncm91cElkKTtcbiAgaWYgKGRpcmVjdGlvbiA9PT0gXCJob3Jpem9udGFsXCIpIHtcbiAgICByZXR1cm4gcGFuZWxHcm91cEVsZW1lbnQub2Zmc2V0V2lkdGggLSByZXNpemVIYW5kbGVzLnJlZHVjZSgoYWNjdW11bGF0ZWQsIGhhbmRsZSkgPT4ge1xuICAgICAgcmV0dXJuIGFjY3VtdWxhdGVkICsgaGFuZGxlLm9mZnNldFdpZHRoO1xuICAgIH0sIDApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwYW5lbEdyb3VwRWxlbWVudC5vZmZzZXRIZWlnaHQgLSByZXNpemVIYW5kbGVzLnJlZHVjZSgoYWNjdW11bGF0ZWQsIGhhbmRsZSkgPT4ge1xuICAgICAgcmV0dXJuIGFjY3VtdWxhdGVkICsgaGFuZGxlLm9mZnNldEhlaWdodDtcbiAgICB9LCAwKTtcbiAgfVxufVxuXG4vLyBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbnVtYmVyIGJldHdlZW4gMSBhbmQgMTAwIHJlcHJlc2VudGluZ1xuLy8gdGhlICUgb2YgdGhlIGdyb3VwJ3Mgb3ZlcmFsbCBzcGFjZSB0aGlzIHBhbmVsIHNob3VsZCBvY2N1cHkuXG5mdW5jdGlvbiBnZXRGbGV4R3JvdyhwYW5lbHMsIGlkLCBzaXplcykge1xuICBpZiAocGFuZWxzLnNpemUgPT09IDEpIHtcbiAgICByZXR1cm4gXCIxMDBcIjtcbiAgfVxuICBjb25zdCBwYW5lbHNBcnJheSA9IHBhbmVsc01hcFRvU29ydGVkQXJyYXkocGFuZWxzKTtcbiAgY29uc3QgaW5kZXggPSBwYW5lbHNBcnJheS5maW5kSW5kZXgocGFuZWwgPT4gcGFuZWwuY3VycmVudC5pZCA9PT0gaWQpO1xuICBjb25zdCBzaXplID0gc2l6ZXNbaW5kZXhdO1xuICBpZiAoc2l6ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFwiMFwiO1xuICB9XG4gIHJldHVybiBzaXplLnRvUHJlY2lzaW9uKFBSRUNJU0lPTik7XG59XG5mdW5jdGlvbiBnZXRQYW5lbChpZCkge1xuICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgW2RhdGEtcGFuZWwtaWQ9XCIke2lkfVwiXWApO1xuICBpZiAoZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0UGFuZWxHcm91cChpZCkge1xuICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgW2RhdGEtcGFuZWwtZ3JvdXAtaWQ9XCIke2lkfVwiXWApO1xuICBpZiAoZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0UmVzaXplSGFuZGxlKGlkKSB7XG4gIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBbZGF0YS1wYW5lbC1yZXNpemUtaGFuZGxlLWlkPVwiJHtpZH1cIl1gKTtcbiAgaWYgKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldFJlc2l6ZUhhbmRsZUluZGV4KGlkKSB7XG4gIGNvbnN0IGhhbmRsZXMgPSBnZXRSZXNpemVIYW5kbGVzKCk7XG4gIGNvbnN0IGluZGV4ID0gaGFuZGxlcy5maW5kSW5kZXgoaGFuZGxlID0+IGhhbmRsZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBhbmVsLXJlc2l6ZS1oYW5kbGUtaWRcIikgPT09IGlkKTtcbiAgcmV0dXJuIGluZGV4ID8/IG51bGw7XG59XG5mdW5jdGlvbiBnZXRSZXNpemVIYW5kbGVzKCkge1xuICByZXR1cm4gQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGBbZGF0YS1wYW5lbC1yZXNpemUtaGFuZGxlLWlkXWApKTtcbn1cbmZ1bmN0aW9uIGdldFJlc2l6ZUhhbmRsZXNGb3JHcm91cChncm91cElkKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYFtkYXRhLXBhbmVsLXJlc2l6ZS1oYW5kbGUtaWRdW2RhdGEtcGFuZWwtZ3JvdXAtaWQ9XCIke2dyb3VwSWR9XCJdYCkpO1xufVxuZnVuY3Rpb24gZ2V0UmVzaXplSGFuZGxlUGFuZWxJZHMoZ3JvdXBJZCwgaGFuZGxlSWQsIHBhbmVsc0FycmF5KSB7XG4gIGNvbnN0IGhhbmRsZSA9IGdldFJlc2l6ZUhhbmRsZShoYW5kbGVJZCk7XG4gIGNvbnN0IGhhbmRsZXMgPSBnZXRSZXNpemVIYW5kbGVzRm9yR3JvdXAoZ3JvdXBJZCk7XG4gIGNvbnN0IGluZGV4ID0gaGFuZGxlID8gaGFuZGxlcy5pbmRleE9mKGhhbmRsZSkgOiAtMTtcbiAgY29uc3QgaWRCZWZvcmUgPSBwYW5lbHNBcnJheVtpbmRleF0/LmN1cnJlbnQ/LmlkID8/IG51bGw7XG4gIGNvbnN0IGlkQWZ0ZXIgPSBwYW5lbHNBcnJheVtpbmRleCArIDFdPy5jdXJyZW50Py5pZCA/PyBudWxsO1xuICByZXR1cm4gW2lkQmVmb3JlLCBpZEFmdGVyXTtcbn1cbmZ1bmN0aW9uIHBhbmVsc01hcFRvU29ydGVkQXJyYXkocGFuZWxzKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKHBhbmVscy52YWx1ZXMoKSkuc29ydCgocGFuZWxBLCBwYW5lbEIpID0+IHtcbiAgICBjb25zdCBvcmRlckEgPSBwYW5lbEEuY3VycmVudC5vcmRlcjtcbiAgICBjb25zdCBvcmRlckIgPSBwYW5lbEIuY3VycmVudC5vcmRlcjtcbiAgICBpZiAob3JkZXJBID09IG51bGwgJiYgb3JkZXJCID09IG51bGwpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZSBpZiAob3JkZXJBID09IG51bGwpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9IGVsc2UgaWYgKG9yZGVyQiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG9yZGVyQSAtIG9yZGVyQjtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gc2FmZVJlc2l6ZVBhbmVsKHVuaXRzLCBncm91cFNpemVQaXhlbHMsIHBhbmVsLCBwcmV2U2l6ZSwgbmV4dFNpemUsIGV2ZW50ID0gbnVsbCkge1xuICBsZXQge1xuICAgIGNvbGxhcHNlZFNpemUsXG4gICAgY29sbGFwc2libGUsXG4gICAgbWF4U2l6ZSxcbiAgICBtaW5TaXplXG4gIH0gPSBwYW5lbC5jdXJyZW50O1xuICBpZiAodW5pdHMgPT09IFwicGl4ZWxzXCIpIHtcbiAgICBjb2xsYXBzZWRTaXplID0gY29sbGFwc2VkU2l6ZSAvIGdyb3VwU2l6ZVBpeGVscyAqIDEwMDtcbiAgICBpZiAobWF4U2l6ZSAhPSBudWxsKSB7XG4gICAgICBtYXhTaXplID0gbWF4U2l6ZSAvIGdyb3VwU2l6ZVBpeGVscyAqIDEwMDtcbiAgICB9XG4gICAgbWluU2l6ZSA9IG1pblNpemUgLyBncm91cFNpemVQaXhlbHMgKiAxMDA7XG4gIH1cbiAgaWYgKGNvbGxhcHNpYmxlKSB7XG4gICAgaWYgKHByZXZTaXplID4gY29sbGFwc2VkU2l6ZSkge1xuICAgICAgLy8gTWltaWMgVlMgQ09kZSBiZWhhdmlvcjsgY29sbGFwc2UgYSBwYW5lbCBpZiBpdCdzIHNtYWxsZXIgdGhhbiBoYWxmIG9mIGl0cyBtaW4tc2l6ZVxuICAgICAgaWYgKG5leHRTaXplIDw9IG1pblNpemUgLyAyICsgY29sbGFwc2VkU2l6ZSkge1xuICAgICAgICByZXR1cm4gY29sbGFwc2VkU2l6ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaXNLZXlib2FyZEV2ZW50ID0gZXZlbnQ/LnR5cGU/LnN0YXJ0c1dpdGgoXCJrZXlcIik7XG4gICAgICBpZiAoIWlzS2V5Ym9hcmRFdmVudCkge1xuICAgICAgICAvLyBLZXlib2FyZCBldmVudHMgc2hvdWxkIGV4cGFuZCBhIGNvbGxhcHNlZCBwYW5lbCB0byB0aGUgbWluIHNpemUsXG4gICAgICAgIC8vIGJ1dCBtb3VzZSBldmVudHMgc2hvdWxkIHdhaXQgdW50aWwgdGhlIHBhbmVsIGhhcyByZWFjaGVkIGl0cyBtaW4gc2l6ZVxuICAgICAgICAvLyB0byBhdm9pZCBhIHZpc3VhbCBmbGlja2VyaW5nIHdoZW4gZHJhZ2dpbmcgYmV0d2VlbiBjb2xsYXBzZWQgYW5kIG1pbiBzaXplLlxuICAgICAgICBpZiAobmV4dFNpemUgPCBtaW5TaXplKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbGxhcHNlZFNpemU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIE1hdGgubWluKG1heFNpemUgIT0gbnVsbCA/IG1heFNpemUgOiAxMDAsIE1hdGgubWF4KG1pblNpemUsIG5leHRTaXplKSk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVBhbmVsUHJvcHModW5pdHMsIHBhbmVsRGF0YSkge1xuICBjb25zdCB7XG4gICAgY29sbGFwc2libGUsXG4gICAgZGVmYXVsdFNpemUsXG4gICAgbWF4U2l6ZSxcbiAgICBtaW5TaXplXG4gIH0gPSBwYW5lbERhdGEuY3VycmVudDtcblxuICAvLyBCYXNpYyBwcm9wcyB2YWxpZGF0aW9uXG4gIGlmIChtaW5TaXplIDwgMCB8fCB1bml0cyA9PT0gXCJwZXJjZW50YWdlc1wiICYmIG1pblNpemUgPiAxMDApIHtcbiAgICB7XG4gICAgICBjb25zb2xlLmVycm9yKGBJbnZhbGlkIFBhbmVsIG1pblNpemUgcHJvdmlkZWQsICR7bWluU2l6ZX1gKTtcbiAgICB9XG4gICAgcGFuZWxEYXRhLmN1cnJlbnQubWluU2l6ZSA9IDA7XG4gIH1cbiAgaWYgKG1heFNpemUgIT0gbnVsbCkge1xuICAgIGlmIChtYXhTaXplIDwgMCB8fCB1bml0cyA9PT0gXCJwZXJjZW50YWdlc1wiICYmIG1heFNpemUgPiAxMDApIHtcbiAgICAgIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgSW52YWxpZCBQYW5lbCBtYXhTaXplIHByb3ZpZGVkLCAke21heFNpemV9YCk7XG4gICAgICB9XG4gICAgICBwYW5lbERhdGEuY3VycmVudC5tYXhTaXplID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgaWYgKGRlZmF1bHRTaXplICE9PSBudWxsKSB7XG4gICAgaWYgKGRlZmF1bHRTaXplIDwgMCB8fCB1bml0cyA9PT0gXCJwZXJjZW50YWdlc1wiICYmIGRlZmF1bHRTaXplID4gMTAwKSB7XG4gICAgICB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEludmFsaWQgUGFuZWwgZGVmYXVsdFNpemUgcHJvdmlkZWQsICR7ZGVmYXVsdFNpemV9YCk7XG4gICAgICB9XG4gICAgICBwYW5lbERhdGEuY3VycmVudC5kZWZhdWx0U2l6ZSA9IG51bGw7XG4gICAgfSBlbHNlIGlmIChkZWZhdWx0U2l6ZSA8IG1pblNpemUgJiYgIWNvbGxhcHNpYmxlKSB7XG4gICAgICB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFBhbmVsIG1pblNpemUgKCR7bWluU2l6ZX0pIGNhbm5vdCBiZSBncmVhdGVyIHRoYW4gZGVmYXVsdFNpemUgKCR7ZGVmYXVsdFNpemV9KWApO1xuICAgICAgfVxuICAgICAgcGFuZWxEYXRhLmN1cnJlbnQuZGVmYXVsdFNpemUgPSBtaW5TaXplO1xuICAgIH0gZWxzZSBpZiAobWF4U2l6ZSAhPSBudWxsICYmIGRlZmF1bHRTaXplID4gbWF4U2l6ZSkge1xuICAgICAge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBQYW5lbCBtYXhTaXplICgke21heFNpemV9KSBjYW5ub3QgYmUgbGVzcyB0aGFuIGRlZmF1bHRTaXplICgke2RlZmF1bHRTaXplfSlgKTtcbiAgICAgIH1cbiAgICAgIHBhbmVsRGF0YS5jdXJyZW50LmRlZmF1bHRTaXplID0gbWF4U2l6ZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUGFuZWxHcm91cExheW91dCh7XG4gIGdyb3VwSWQsXG4gIHBhbmVscyxcbiAgbmV4dFNpemVzLFxuICBwcmV2U2l6ZXMsXG4gIHVuaXRzXG59KSB7XG4gIC8vIENsb25lIGJlY2F1c2UgdGhpcyBtZXRob2QgbW9kaWZpZXNcbiAgbmV4dFNpemVzID0gWy4uLm5leHRTaXplc107XG4gIGNvbnN0IHBhbmVsc0FycmF5ID0gcGFuZWxzTWFwVG9Tb3J0ZWRBcnJheShwYW5lbHMpO1xuICBjb25zdCBncm91cFNpemVQaXhlbHMgPSB1bml0cyA9PT0gXCJwaXhlbHNcIiA/IGdldEF2YWlsYWJsZUdyb3VwU2l6ZVBpeGVscyhncm91cElkKSA6IE5hTjtcbiAgbGV0IHJlbWFpbmluZ1NpemUgPSAwO1xuXG4gIC8vIEZpcnN0LCBjaGVjayBhbGwgb2YgdGhlIHByb3Bvc2VkIHNpemVzIGFnYWluc3QgdGhlIG1pbi9tYXggY29uc3RyYWludHNcbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHBhbmVsc0FycmF5Lmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGNvbnN0IHBhbmVsID0gcGFuZWxzQXJyYXlbaW5kZXhdO1xuICAgIGNvbnN0IHByZXZTaXplID0gcHJldlNpemVzW2luZGV4XTtcbiAgICBjb25zdCBuZXh0U2l6ZSA9IG5leHRTaXplc1tpbmRleF07XG4gICAgY29uc3Qgc2FmZU5leHRTaXplID0gc2FmZVJlc2l6ZVBhbmVsKHVuaXRzLCBncm91cFNpemVQaXhlbHMsIHBhbmVsLCBwcmV2U2l6ZSwgbmV4dFNpemUpO1xuICAgIGlmIChuZXh0U2l6ZSAhPSBzYWZlTmV4dFNpemUpIHtcbiAgICAgIHJlbWFpbmluZ1NpemUgKz0gbmV4dFNpemUgLSBzYWZlTmV4dFNpemU7XG4gICAgICBuZXh0U2l6ZXNbaW5kZXhdID0gc2FmZU5leHRTaXplO1xuICAgICAge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBJbnZhbGlkIHNpemUgKCR7bmV4dFNpemV9KSBzcGVjaWZpZWQgZm9yIFBhbmVsIFwiJHtwYW5lbC5jdXJyZW50LmlkfVwiIGdpdmVuIHRoZSBwYW5lbCdzIG1pbi9tYXggc2l6ZSBjb25zdHJhaW50c2ApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIElmIHRoZXJlIGlzIGFkZGl0aW9uYWwsIGxlZnQgb3ZlciBzcGFjZSwgYXNzaWduIGl0IHRvIGFueSBwYW5lbChzKSB0aGF0IHBlcm1pdHMgaXRcbiAgLy8gKEl0J3Mgbm90IHdvcnRoIHRha2luZyBtdWx0aXBsZSBhZGRpdGlvbmFsIHBhc3NlcyB0byBldmVubHkgZGlzdHJpYnV0ZSlcbiAgaWYgKHJlbWFpbmluZ1NpemUudG9GaXhlZCgzKSAhPT0gXCIwLjAwMFwiKSB7XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHBhbmVsc0FycmF5Lmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgY29uc3QgcGFuZWwgPSBwYW5lbHNBcnJheVtpbmRleF07XG4gICAgICBsZXQge1xuICAgICAgICBtYXhTaXplLFxuICAgICAgICBtaW5TaXplXG4gICAgICB9ID0gcGFuZWwuY3VycmVudDtcbiAgICAgIGlmICh1bml0cyA9PT0gXCJwaXhlbHNcIikge1xuICAgICAgICBtaW5TaXplID0gbWluU2l6ZSAvIGdyb3VwU2l6ZVBpeGVscyAqIDEwMDtcbiAgICAgICAgaWYgKG1heFNpemUgIT0gbnVsbCkge1xuICAgICAgICAgIG1heFNpemUgPSBtYXhTaXplIC8gZ3JvdXBTaXplUGl4ZWxzICogMTAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBzaXplID0gTWF0aC5taW4obWF4U2l6ZSAhPSBudWxsID8gbWF4U2l6ZSA6IDEwMCwgTWF0aC5tYXgobWluU2l6ZSwgbmV4dFNpemVzW2luZGV4XSArIHJlbWFpbmluZ1NpemUpKTtcbiAgICAgIGlmIChzaXplICE9PSBuZXh0U2l6ZXNbaW5kZXhdKSB7XG4gICAgICAgIHJlbWFpbmluZ1NpemUgLT0gc2l6ZSAtIG5leHRTaXplc1tpbmRleF07XG4gICAgICAgIG5leHRTaXplc1tpbmRleF0gPSBzaXplO1xuXG4gICAgICAgIC8vIEZ1enp5IGNvbXBhcmlzb24gdG8gYWNjb3VudCBmb3IgaW1wcmVjaXNlIGZsb2F0aW5nIHBvaW50IG1hdGhcbiAgICAgICAgaWYgKE1hdGguYWJzKHJlbWFpbmluZ1NpemUpLnRvRml4ZWQoMykgPT09IFwiMC4wMDBcIikge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgd2Ugc3RpbGwgaGF2ZSByZW1haW5kZXIsIHRoZSByZXF1ZXN0ZWQgbGF5b3V0IHdhc24ndCB2YWxpZCBhbmQgd2Ugc2hvdWxkIHdhcm4gYWJvdXQgaXRcbiAgaWYgKHJlbWFpbmluZ1NpemUudG9GaXhlZCgzKSAhPT0gXCIwLjAwMFwiKSB7XG4gICAge1xuICAgICAgY29uc29sZS5lcnJvcihgXCJJbnZhbGlkIHBhbmVsIGdyb3VwIGNvbmZpZ3VyYXRpb247IGRlZmF1bHQgcGFuZWwgc2l6ZXMgc2hvdWxkIHRvdGFsIDEwMCUgYnV0IHdhcyAkezEwMCAtIHJlbWFpbmluZ1NpemV9JWApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV4dFNpemVzO1xufVxuXG5mdW5jdGlvbiBhc3NlcnQoZXhwZWN0ZWRDb25kaXRpb24sIG1lc3NhZ2UgPSBcIkFzc2VydGlvbiBmYWlsZWQhXCIpIHtcbiAgaWYgKCFleHBlY3RlZENvbmRpdGlvbikge1xuICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgdGhyb3cgRXJyb3IobWVzc2FnZSk7XG4gIH1cbn1cblxuLy8gaHR0cHM6Ly93d3cudzMub3JnL1dBSS9BUklBL2FwZy9wYXR0ZXJucy93aW5kb3dzcGxpdHRlci9cblxuZnVuY3Rpb24gdXNlV2luZG93U3BsaXR0ZXJQYW5lbEdyb3VwQmVoYXZpb3Ioe1xuICBjb21taXR0ZWRWYWx1ZXNSZWYsXG4gIGdyb3VwSWQsXG4gIHBhbmVscyxcbiAgc2V0U2l6ZXMsXG4gIHNpemVzLFxuICBwYW5lbFNpemVCZWZvcmVDb2xsYXBzZVxufSkge1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGRpcmVjdGlvbixcbiAgICAgIHBhbmVsc1xuICAgIH0gPSBjb21taXR0ZWRWYWx1ZXNSZWYuY3VycmVudDtcbiAgICBjb25zdCBncm91cEVsZW1lbnQgPSBnZXRQYW5lbEdyb3VwKGdyb3VwSWQpO1xuICAgIGFzc2VydChncm91cEVsZW1lbnQgIT0gbnVsbCwgYE5vIGdyb3VwIGZvdW5kIGZvciBpZCBcIiR7Z3JvdXBJZH1cImApO1xuICAgIGNvbnN0IHtcbiAgICAgIGhlaWdodCxcbiAgICAgIHdpZHRoXG4gICAgfSA9IGdyb3VwRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBoYW5kbGVzID0gZ2V0UmVzaXplSGFuZGxlc0Zvckdyb3VwKGdyb3VwSWQpO1xuICAgIGNvbnN0IGNsZWFudXBGdW5jdGlvbnMgPSBoYW5kbGVzLm1hcChoYW5kbGUgPT4ge1xuICAgICAgY29uc3QgaGFuZGxlSWQgPSBoYW5kbGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1wYW5lbC1yZXNpemUtaGFuZGxlLWlkXCIpO1xuICAgICAgY29uc3QgcGFuZWxzQXJyYXkgPSBwYW5lbHNNYXBUb1NvcnRlZEFycmF5KHBhbmVscyk7XG4gICAgICBjb25zdCBbaWRCZWZvcmUsIGlkQWZ0ZXJdID0gZ2V0UmVzaXplSGFuZGxlUGFuZWxJZHMoZ3JvdXBJZCwgaGFuZGxlSWQsIHBhbmVsc0FycmF5KTtcbiAgICAgIGlmIChpZEJlZm9yZSA9PSBudWxsIHx8IGlkQWZ0ZXIgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gKCkgPT4ge307XG4gICAgICB9XG4gICAgICBsZXQgY3VycmVudE1pblNpemUgPSAwO1xuICAgICAgbGV0IGN1cnJlbnRNYXhTaXplID0gMTAwO1xuICAgICAgbGV0IHRvdGFsTWluU2l6ZSA9IDA7XG4gICAgICBsZXQgdG90YWxNYXhTaXplID0gMDtcblxuICAgICAgLy8gQSBwYW5lbCdzIGVmZmVjdGl2ZSBtaW4vbWF4IHNpemVzIGFsc28gbmVlZCB0byBhY2NvdW50IGZvciBvdGhlciBwYW5lbCdzIHNpemVzLlxuICAgICAgcGFuZWxzQXJyYXkuZm9yRWFjaChwYW5lbERhdGEgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgaWQsXG4gICAgICAgICAgbWF4U2l6ZSxcbiAgICAgICAgICBtaW5TaXplXG4gICAgICAgIH0gPSBwYW5lbERhdGEuY3VycmVudDtcbiAgICAgICAgaWYgKGlkID09PSBpZEJlZm9yZSkge1xuICAgICAgICAgIGN1cnJlbnRNaW5TaXplID0gbWluU2l6ZTtcbiAgICAgICAgICBjdXJyZW50TWF4U2l6ZSA9IG1heFNpemUgIT0gbnVsbCA/IG1heFNpemUgOiAxMDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG90YWxNaW5TaXplICs9IG1pblNpemU7XG4gICAgICAgICAgdG90YWxNYXhTaXplICs9IG1heFNpemUgIT0gbnVsbCA/IG1heFNpemUgOiAxMDA7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29uc3QgYXJpYVZhbHVlTWF4ID0gTWF0aC5taW4oY3VycmVudE1heFNpemUsIDEwMCAtIHRvdGFsTWluU2l6ZSk7XG4gICAgICBjb25zdCBhcmlhVmFsdWVNaW4gPSBNYXRoLm1heChjdXJyZW50TWluU2l6ZSwgKHBhbmVsc0FycmF5Lmxlbmd0aCAtIDEpICogMTAwIC0gdG90YWxNYXhTaXplKTtcbiAgICAgIGNvbnN0IGZsZXhHcm93ID0gZ2V0RmxleEdyb3cocGFuZWxzLCBpZEJlZm9yZSwgc2l6ZXMpO1xuICAgICAgaGFuZGxlLnNldEF0dHJpYnV0ZShcImFyaWEtdmFsdWVtYXhcIiwgXCJcIiArIE1hdGgucm91bmQoYXJpYVZhbHVlTWF4KSk7XG4gICAgICBoYW5kbGUuc2V0QXR0cmlidXRlKFwiYXJpYS12YWx1ZW1pblwiLCBcIlwiICsgTWF0aC5yb3VuZChhcmlhVmFsdWVNaW4pKTtcbiAgICAgIGhhbmRsZS5zZXRBdHRyaWJ1dGUoXCJhcmlhLXZhbHVlbm93XCIsIFwiXCIgKyBNYXRoLnJvdW5kKHBhcnNlSW50KGZsZXhHcm93KSkpO1xuICAgICAgY29uc3Qgb25LZXlEb3duID0gZXZlbnQgPT4ge1xuICAgICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGV2ZW50LmtleSkge1xuICAgICAgICAgIGNhc2UgXCJFbnRlclwiOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHBhbmVsc0FycmF5LmZpbmRJbmRleChwYW5lbCA9PiBwYW5lbC5jdXJyZW50LmlkID09PSBpZEJlZm9yZSk7XG4gICAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFuZWxEYXRhID0gcGFuZWxzQXJyYXlbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpemUgPSBzaXplc1tpbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKHNpemUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgbGV0IGRlbHRhID0gMDtcbiAgICAgICAgICAgICAgICAgIGlmIChzaXplLnRvUHJlY2lzaW9uKFBSRUNJU0lPTikgPD0gcGFuZWxEYXRhLmN1cnJlbnQubWluU2l6ZS50b1ByZWNpc2lvbihQUkVDSVNJT04pKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbHRhID0gZGlyZWN0aW9uID09PSBcImhvcml6b250YWxcIiA/IHdpZHRoIDogaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsdGEgPSAtKGRpcmVjdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgPyB3aWR0aCA6IGhlaWdodCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjb25zdCBuZXh0U2l6ZXMgPSBhZGp1c3RCeURlbHRhKGV2ZW50LCBjb21taXR0ZWRWYWx1ZXNSZWYuY3VycmVudCwgaWRCZWZvcmUsIGlkQWZ0ZXIsIGRlbHRhLCBzaXplcywgcGFuZWxTaXplQmVmb3JlQ29sbGFwc2UuY3VycmVudCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICBpZiAoc2l6ZXMgIT09IG5leHRTaXplcykge1xuICAgICAgICAgICAgICAgICAgICBzZXRTaXplcyhuZXh0U2l6ZXMpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGhhbmRsZS5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBvbktleURvd24pO1xuICAgICAgY29uc3QgcGFuZWxCZWZvcmUgPSBnZXRQYW5lbChpZEJlZm9yZSk7XG4gICAgICBpZiAocGFuZWxCZWZvcmUgIT0gbnVsbCkge1xuICAgICAgICBoYW5kbGUuc2V0QXR0cmlidXRlKFwiYXJpYS1jb250cm9sc1wiLCBwYW5lbEJlZm9yZS5pZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBoYW5kbGUucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS12YWx1ZW1heFwiKTtcbiAgICAgICAgaGFuZGxlLnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtdmFsdWVtaW5cIik7XG4gICAgICAgIGhhbmRsZS5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLXZhbHVlbm93XCIpO1xuICAgICAgICBoYW5kbGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgb25LZXlEb3duKTtcbiAgICAgICAgaWYgKHBhbmVsQmVmb3JlICE9IG51bGwpIHtcbiAgICAgICAgICBoYW5kbGUucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1jb250cm9sc1wiKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2xlYW51cEZ1bmN0aW9ucy5mb3JFYWNoKGNsZWFudXBGdW5jdGlvbiA9PiBjbGVhbnVwRnVuY3Rpb24oKSk7XG4gICAgfTtcbiAgfSwgW2NvbW1pdHRlZFZhbHVlc1JlZiwgZ3JvdXBJZCwgcGFuZWxzLCBwYW5lbFNpemVCZWZvcmVDb2xsYXBzZSwgc2V0U2l6ZXMsIHNpemVzXSk7XG59XG5mdW5jdGlvbiB1c2VXaW5kb3dTcGxpdHRlclJlc2l6ZUhhbmRsZXJCZWhhdmlvcih7XG4gIGRpc2FibGVkLFxuICBoYW5kbGVJZCxcbiAgcmVzaXplSGFuZGxlclxufSkge1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChkaXNhYmxlZCB8fCByZXNpemVIYW5kbGVyID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaGFuZGxlRWxlbWVudCA9IGdldFJlc2l6ZUhhbmRsZShoYW5kbGVJZCk7XG4gICAgaWYgKGhhbmRsZUVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvbktleURvd24gPSBldmVudCA9PiB7XG4gICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGV2ZW50LmtleSkge1xuICAgICAgICBjYXNlIFwiQXJyb3dEb3duXCI6XG4gICAgICAgIGNhc2UgXCJBcnJvd0xlZnRcIjpcbiAgICAgICAgY2FzZSBcIkFycm93UmlnaHRcIjpcbiAgICAgICAgY2FzZSBcIkFycm93VXBcIjpcbiAgICAgICAgY2FzZSBcIkVuZFwiOlxuICAgICAgICBjYXNlIFwiSG9tZVwiOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXNpemVIYW5kbGVyKGV2ZW50KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBcIkY2XCI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXMgPSBnZXRSZXNpemVIYW5kbGVzKCk7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGdldFJlc2l6ZUhhbmRsZUluZGV4KGhhbmRsZUlkKTtcbiAgICAgICAgICAgIGFzc2VydChpbmRleCAhPT0gbnVsbCk7XG4gICAgICAgICAgICBjb25zdCBuZXh0SW5kZXggPSBldmVudC5zaGlmdEtleSA/IGluZGV4ID4gMCA/IGluZGV4IC0gMSA6IGhhbmRsZXMubGVuZ3RoIC0gMSA6IGluZGV4ICsgMSA8IGhhbmRsZXMubGVuZ3RoID8gaW5kZXggKyAxIDogMDtcbiAgICAgICAgICAgIGNvbnN0IG5leHRIYW5kbGUgPSBoYW5kbGVzW25leHRJbmRleF07XG4gICAgICAgICAgICBuZXh0SGFuZGxlLmZvY3VzKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBoYW5kbGVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIG9uS2V5RG93bik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGhhbmRsZUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgb25LZXlEb3duKTtcbiAgICB9O1xuICB9LCBbZGlzYWJsZWQsIGhhbmRsZUlkLCByZXNpemVIYW5kbGVyXSk7XG59XG5cbmZ1bmN0aW9uIGFyZUVxdWFsKGFycmF5QSwgYXJyYXlCKSB7XG4gIGlmIChhcnJheUEubGVuZ3RoICE9PSBhcnJheUIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBhcnJheUEubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgaWYgKGFycmF5QVtpbmRleF0gIT09IGFycmF5QltpbmRleF0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGdldERyYWdPZmZzZXQoZXZlbnQsIGhhbmRsZUlkLCBkaXJlY3Rpb24sIGluaXRpYWxPZmZzZXQgPSAwLCBpbml0aWFsSGFuZGxlRWxlbWVudFJlY3QgPSBudWxsKSB7XG4gIGNvbnN0IGlzSG9yaXpvbnRhbCA9IGRpcmVjdGlvbiA9PT0gXCJob3Jpem9udGFsXCI7XG4gIGxldCBwb2ludGVyT2Zmc2V0ID0gMDtcbiAgaWYgKGlzTW91c2VFdmVudChldmVudCkpIHtcbiAgICBwb2ludGVyT2Zmc2V0ID0gaXNIb3Jpem9udGFsID8gZXZlbnQuY2xpZW50WCA6IGV2ZW50LmNsaWVudFk7XG4gIH0gZWxzZSBpZiAoaXNUb3VjaEV2ZW50KGV2ZW50KSkge1xuICAgIGNvbnN0IGZpcnN0VG91Y2ggPSBldmVudC50b3VjaGVzWzBdO1xuICAgIHBvaW50ZXJPZmZzZXQgPSBpc0hvcml6b250YWwgPyBmaXJzdFRvdWNoLnNjcmVlblggOiBmaXJzdFRvdWNoLnNjcmVlblk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgY29uc3QgaGFuZGxlRWxlbWVudCA9IGdldFJlc2l6ZUhhbmRsZShoYW5kbGVJZCk7XG4gIGNvbnN0IHJlY3QgPSBpbml0aWFsSGFuZGxlRWxlbWVudFJlY3QgfHwgaGFuZGxlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3QgZWxlbWVudE9mZnNldCA9IGlzSG9yaXpvbnRhbCA/IHJlY3QubGVmdCA6IHJlY3QudG9wO1xuICByZXR1cm4gcG9pbnRlck9mZnNldCAtIGVsZW1lbnRPZmZzZXQgLSBpbml0aWFsT2Zmc2V0O1xufVxuXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTW91c2VFdmVudC9tb3ZlbWVudFhcbmZ1bmN0aW9uIGdldE1vdmVtZW50KGV2ZW50LCBncm91cElkLCBoYW5kbGVJZCwgcGFuZWxzQXJyYXksIGRpcmVjdGlvbiwgcHJldlNpemVzLCBpbml0aWFsRHJhZ1N0YXRlKSB7XG4gIGNvbnN0IHtcbiAgICBkcmFnT2Zmc2V0ID0gMCxcbiAgICBkcmFnSGFuZGxlUmVjdCxcbiAgICBzaXplczogaW5pdGlhbFNpemVzXG4gIH0gPSBpbml0aWFsRHJhZ1N0YXRlIHx8IHt9O1xuXG4gIC8vIElmIHdlJ3JlIHJlc2l6aW5nIGJ5IG1vdXNlIG9yIHRvdWNoLCB1c2UgdGhlIGluaXRpYWwgc2l6ZXMgYXMgYSBiYXNlLlxuICAvLyBUaGlzIGhhcyB0aGUgYmVuZWZpdCBvZiBjYXVzaW5nIGZvcmNlLWNvbGxhcHNlZCBwYW5lbHMgdG8gc3ByaW5nIGJhY2sgb3BlbiBpZiBkcmFnIGlzIHJldmVyc2VkLlxuICBjb25zdCBiYXNlU2l6ZXMgPSBpbml0aWFsU2l6ZXMgfHwgcHJldlNpemVzO1xuICBpZiAoaXNLZXlEb3duKGV2ZW50KSkge1xuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IGRpcmVjdGlvbiA9PT0gXCJob3Jpem9udGFsXCI7XG4gICAgY29uc3QgZ3JvdXBFbGVtZW50ID0gZ2V0UGFuZWxHcm91cChncm91cElkKTtcbiAgICBjb25zdCByZWN0ID0gZ3JvdXBFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IGdyb3VwU2l6ZUluUGl4ZWxzID0gaXNIb3Jpem9udGFsID8gcmVjdC53aWR0aCA6IHJlY3QuaGVpZ2h0O1xuICAgIGNvbnN0IGRlbm9taW5hdG9yID0gZXZlbnQuc2hpZnRLZXkgPyAxMCA6IDEwMDtcbiAgICBjb25zdCBkZWx0YSA9IGdyb3VwU2l6ZUluUGl4ZWxzIC8gZGVub21pbmF0b3I7XG4gICAgbGV0IG1vdmVtZW50ID0gMDtcbiAgICBzd2l0Y2ggKGV2ZW50LmtleSkge1xuICAgICAgY2FzZSBcIkFycm93RG93blwiOlxuICAgICAgICBtb3ZlbWVudCA9IGlzSG9yaXpvbnRhbCA/IDAgOiBkZWx0YTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiQXJyb3dMZWZ0XCI6XG4gICAgICAgIG1vdmVtZW50ID0gaXNIb3Jpem9udGFsID8gLWRlbHRhIDogMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiQXJyb3dSaWdodFwiOlxuICAgICAgICBtb3ZlbWVudCA9IGlzSG9yaXpvbnRhbCA/IGRlbHRhIDogMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiQXJyb3dVcFwiOlxuICAgICAgICBtb3ZlbWVudCA9IGlzSG9yaXpvbnRhbCA/IDAgOiAtZGVsdGE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkVuZFwiOlxuICAgICAgICBtb3ZlbWVudCA9IGdyb3VwU2l6ZUluUGl4ZWxzO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJIb21lXCI6XG4gICAgICAgIG1vdmVtZW50ID0gLWdyb3VwU2l6ZUluUGl4ZWxzO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgUGFuZWwgYmVpbmcgcmVzaXplZCBpcyBjb2xsYXBzaWJsZSxcbiAgICAvLyB3ZSBuZWVkIHRvIHNwZWNpYWwgY2FzZSByZXNpemluZyBhcm91bmQgdGhlIG1pblNpemUgYm91bmRhcnkuXG4gICAgLy8gSWYgY29udHJhY3RpbmcsIFBhbmVscyBzaG91bGQgc2hyaW5rIHRvIHRoZWlyIG1pblNpemUgYW5kIHRoZW4gc25hcCB0byBmdWxseSBjb2xsYXBzZWQuXG4gICAgLy8gSWYgZXhwYW5kaW5nIGZyb20gY29sbGFwc2VkLCB0aGV5IHNob3VsZCBzbmFwIGJhY2sgdG8gdGhlaXIgbWluU2l6ZS5cbiAgICBjb25zdCBbaWRCZWZvcmUsIGlkQWZ0ZXJdID0gZ2V0UmVzaXplSGFuZGxlUGFuZWxJZHMoZ3JvdXBJZCwgaGFuZGxlSWQsIHBhbmVsc0FycmF5KTtcbiAgICBjb25zdCB0YXJnZXRQYW5lbElkID0gbW92ZW1lbnQgPCAwID8gaWRCZWZvcmUgOiBpZEFmdGVyO1xuICAgIGNvbnN0IHRhcmdldFBhbmVsSW5kZXggPSBwYW5lbHNBcnJheS5maW5kSW5kZXgocGFuZWwgPT4gcGFuZWwuY3VycmVudC5pZCA9PT0gdGFyZ2V0UGFuZWxJZCk7XG4gICAgY29uc3QgdGFyZ2V0UGFuZWwgPSBwYW5lbHNBcnJheVt0YXJnZXRQYW5lbEluZGV4XTtcbiAgICBpZiAodGFyZ2V0UGFuZWwuY3VycmVudC5jb2xsYXBzaWJsZSkge1xuICAgICAgY29uc3QgYmFzZVNpemUgPSBiYXNlU2l6ZXNbdGFyZ2V0UGFuZWxJbmRleF07XG4gICAgICBpZiAoYmFzZVNpemUgPT09IDAgfHwgYmFzZVNpemUudG9QcmVjaXNpb24oUFJFQ0lTSU9OKSA9PT0gdGFyZ2V0UGFuZWwuY3VycmVudC5taW5TaXplLnRvUHJlY2lzaW9uKFBSRUNJU0lPTikpIHtcbiAgICAgICAgbW92ZW1lbnQgPSBtb3ZlbWVudCA8IDAgPyAtdGFyZ2V0UGFuZWwuY3VycmVudC5taW5TaXplICogZ3JvdXBTaXplSW5QaXhlbHMgOiB0YXJnZXRQYW5lbC5jdXJyZW50Lm1pblNpemUgKiBncm91cFNpemVJblBpeGVscztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1vdmVtZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZXREcmFnT2Zmc2V0KGV2ZW50LCBoYW5kbGVJZCwgZGlyZWN0aW9uLCBkcmFnT2Zmc2V0LCBkcmFnSGFuZGxlUmVjdCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzS2V5RG93bihldmVudCkge1xuICByZXR1cm4gZXZlbnQudHlwZSA9PT0gXCJrZXlkb3duXCI7XG59XG5mdW5jdGlvbiBpc01vdXNlRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50LnR5cGUuc3RhcnRzV2l0aChcIm1vdXNlXCIpO1xufVxuZnVuY3Rpb24gaXNUb3VjaEV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBldmVudC50eXBlLnN0YXJ0c1dpdGgoXCJ0b3VjaFwiKTtcbn1cblxubGV0IGN1cnJlbnRTdGF0ZSA9IG51bGw7XG5sZXQgZWxlbWVudCA9IG51bGw7XG5mdW5jdGlvbiBnZXRDdXJzb3JTdHlsZShzdGF0ZSkge1xuICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgY2FzZSBcImhvcml6b250YWxcIjpcbiAgICAgIHJldHVybiBcImV3LXJlc2l6ZVwiO1xuICAgIGNhc2UgXCJob3Jpem9udGFsLW1heFwiOlxuICAgICAgcmV0dXJuIFwidy1yZXNpemVcIjtcbiAgICBjYXNlIFwiaG9yaXpvbnRhbC1taW5cIjpcbiAgICAgIHJldHVybiBcImUtcmVzaXplXCI7XG4gICAgY2FzZSBcInZlcnRpY2FsXCI6XG4gICAgICByZXR1cm4gXCJucy1yZXNpemVcIjtcbiAgICBjYXNlIFwidmVydGljYWwtbWF4XCI6XG4gICAgICByZXR1cm4gXCJuLXJlc2l6ZVwiO1xuICAgIGNhc2UgXCJ2ZXJ0aWNhbC1taW5cIjpcbiAgICAgIHJldHVybiBcInMtcmVzaXplXCI7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc2V0R2xvYmFsQ3Vyc29yU3R5bGUoKSB7XG4gIGlmIChlbGVtZW50ICE9PSBudWxsKSB7XG4gICAgZG9jdW1lbnQuaGVhZC5yZW1vdmVDaGlsZChlbGVtZW50KTtcbiAgICBjdXJyZW50U3RhdGUgPSBudWxsO1xuICAgIGVsZW1lbnQgPSBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBzZXRHbG9iYWxDdXJzb3JTdHlsZShzdGF0ZSkge1xuICBpZiAoY3VycmVudFN0YXRlID09PSBzdGF0ZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjdXJyZW50U3RhdGUgPSBzdGF0ZTtcbiAgY29uc3Qgc3R5bGUgPSBnZXRDdXJzb3JTdHlsZShzdGF0ZSk7XG4gIGlmIChlbGVtZW50ID09PSBudWxsKSB7XG4gICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICB9XG4gIGVsZW1lbnQuaW5uZXJIVE1MID0gYCp7Y3Vyc29yOiAke3N0eWxlfSFpbXBvcnRhbnQ7fWA7XG59XG5cbmZ1bmN0aW9uIGRlYm91bmNlKGNhbGxiYWNrLCBkdXJhdGlvbk1zID0gMTApIHtcbiAgbGV0IHRpbWVvdXRJZCA9IG51bGw7XG4gIGxldCBjYWxsYWJsZSA9ICguLi5hcmdzKSA9PiB7XG4gICAgaWYgKHRpbWVvdXRJZCAhPT0gbnVsbCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgfVxuICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgY2FsbGJhY2soLi4uYXJncyk7XG4gICAgfSwgZHVyYXRpb25Ncyk7XG4gIH07XG4gIHJldHVybiBjYWxsYWJsZTtcbn1cblxuLy8gTm90ZSB0aGF0IFBhbmVsIGlkcyBtaWdodCBiZSB1c2VyLXByb3ZpZGVkIChzdGFibGUpIG9yIHVzZUlkIGdlbmVyYXRlZCAobm9uLWRldGVybWluaXN0aWMpXG4vLyBzbyB0aGV5IHNob3VsZCBub3QgYmUgdXNlZCBhcyBwYXJ0IG9mIHRoZSBzZXJpYWxpemF0aW9uIGtleS5cbi8vIFVzaW5nIGFuIGF0dHJpYnV0ZSBsaWtlIG1pblNpemUgaW5zdGVhZCBzaG91bGQgd29yayB3ZWxsIGVub3VnaC5cbi8vIFByZS1zb3J0aW5nIGJ5IG1pblNpemUgYWxsb3dzIHJlbWVtYmVyaW5nIGxheW91dHMgZXZlbiBpZiBwYW5lbHMgYXJlIHJlLW9yZGVyZWQvZHJhZ2dlZC5cbmZ1bmN0aW9uIGdldFNlcmlhbGl6YXRpb25LZXkocGFuZWxzKSB7XG4gIHJldHVybiBwYW5lbHMubWFwKHBhbmVsID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBtaW5TaXplLFxuICAgICAgb3JkZXJcbiAgICB9ID0gcGFuZWwuY3VycmVudDtcbiAgICByZXR1cm4gb3JkZXIgPyBgJHtvcmRlcn06JHttaW5TaXplfWAgOiBgJHttaW5TaXplfWA7XG4gIH0pLnNvcnQoKGEsIGIpID0+IGEubG9jYWxlQ29tcGFyZShiKSkuam9pbihcIixcIik7XG59XG5mdW5jdGlvbiBsb2FkU2VyaWFsaXplZFBhbmVsR3JvdXBTdGF0ZShhdXRvU2F2ZUlkLCBzdG9yYWdlKSB7XG4gIHRyeSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IHN0b3JhZ2UuZ2V0SXRlbShgUGFuZWxHcm91cDpzaXplczoke2F1dG9TYXZlSWR9YCk7XG4gICAgaWYgKHNlcmlhbGl6ZWQpIHtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2Uoc2VyaWFsaXplZCk7XG4gICAgICBpZiAodHlwZW9mIHBhcnNlZCA9PT0gXCJvYmplY3RcIiAmJiBwYXJzZWQgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHt9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gbG9hZFBhbmVsTGF5b3V0KGF1dG9TYXZlSWQsIHBhbmVscywgc3RvcmFnZSkge1xuICBjb25zdCBzdGF0ZSA9IGxvYWRTZXJpYWxpemVkUGFuZWxHcm91cFN0YXRlKGF1dG9TYXZlSWQsIHN0b3JhZ2UpO1xuICBpZiAoc3RhdGUpIHtcbiAgICBjb25zdCBrZXkgPSBnZXRTZXJpYWxpemF0aW9uS2V5KHBhbmVscyk7XG4gICAgcmV0dXJuIHN0YXRlW2tleV0gPz8gbnVsbDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHNhdmVQYW5lbEdyb3VwTGF5b3V0KGF1dG9TYXZlSWQsIHBhbmVscywgc2l6ZXMsIHN0b3JhZ2UpIHtcbiAgY29uc3Qga2V5ID0gZ2V0U2VyaWFsaXphdGlvbktleShwYW5lbHMpO1xuICBjb25zdCBzdGF0ZSA9IGxvYWRTZXJpYWxpemVkUGFuZWxHcm91cFN0YXRlKGF1dG9TYXZlSWQsIHN0b3JhZ2UpIHx8IHt9O1xuICBzdGF0ZVtrZXldID0gc2l6ZXM7XG4gIHRyeSB7XG4gICAgc3RvcmFnZS5zZXRJdGVtKGBQYW5lbEdyb3VwOnNpemVzOiR7YXV0b1NhdmVJZH1gLCBKU09OLnN0cmluZ2lmeShzdGF0ZSkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICB9XG59XG5cbmNvbnN0IGRlYm91bmNlTWFwID0ge307XG5cbi8vIFBhbmVsR3JvdXAgbWlnaHQgYmUgcmVuZGVyaW5nIGluIGEgc2VydmVyLXNpZGUgZW52aXJvbm1lbnQgd2hlcmUgbG9jYWxTdG9yYWdlIGlzIG5vdCBhdmFpbGFibGVcbi8vIG9yIG9uIGEgYnJvd3NlciB3aXRoIGNvb2tpZXMvc3RvcmFnZSBkaXNhYmxlZC5cbi8vIEluIGVpdGhlciBjYXNlLCB0aGlzIGZ1bmN0aW9uIGF2b2lkcyBhY2Nlc3NpbmcgbG9jYWxTdG9yYWdlIHVudGlsIG5lZWRlZCxcbi8vIGFuZCBhdm9pZHMgdGhyb3dpbmcgdXNlci12aXNpYmxlIGVycm9ycy5cbmZ1bmN0aW9uIGluaXRpYWxpemVEZWZhdWx0U3RvcmFnZShzdG9yYWdlT2JqZWN0KSB7XG4gIHRyeSB7XG4gICAgaWYgKHR5cGVvZiBsb2NhbFN0b3JhZ2UgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIC8vIEJ5cGFzcyB0aGlzIGNoZWNrIGZvciBmdXR1cmUgY2FsbHNcbiAgICAgIHN0b3JhZ2VPYmplY3QuZ2V0SXRlbSA9IG5hbWUgPT4ge1xuICAgICAgICByZXR1cm4gbG9jYWxTdG9yYWdlLmdldEl0ZW0obmFtZSk7XG4gICAgICB9O1xuICAgICAgc3RvcmFnZU9iamVjdC5zZXRJdGVtID0gKG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKG5hbWUsIHZhbHVlKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImxvY2FsU3RvcmFnZSBub3Qgc3VwcG9ydGVkIGluIHRoaXMgZW52aXJvbm1lbnRcIik7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIHN0b3JhZ2VPYmplY3QuZ2V0SXRlbSA9ICgpID0+IG51bGw7XG4gICAgc3RvcmFnZU9iamVjdC5zZXRJdGVtID0gKCkgPT4ge307XG4gIH1cbn1cbmNvbnN0IGRlZmF1bHRTdG9yYWdlID0ge1xuICBnZXRJdGVtOiBuYW1lID0+IHtcbiAgICBpbml0aWFsaXplRGVmYXVsdFN0b3JhZ2UoZGVmYXVsdFN0b3JhZ2UpO1xuICAgIHJldHVybiBkZWZhdWx0U3RvcmFnZS5nZXRJdGVtKG5hbWUpO1xuICB9LFxuICBzZXRJdGVtOiAobmFtZSwgdmFsdWUpID0+IHtcbiAgICBpbml0aWFsaXplRGVmYXVsdFN0b3JhZ2UoZGVmYXVsdFN0b3JhZ2UpO1xuICAgIGRlZmF1bHRTdG9yYWdlLnNldEl0ZW0obmFtZSwgdmFsdWUpO1xuICB9XG59O1xuXG4vLyBJbml0aWFsIGRyYWcgc3RhdGUgc2VydmVzIGEgZmV3IHB1cnBvc2VzOlxuLy8gKiBkcmFnT2Zmc2V0OlxuLy8gICBSZXNpemUgaXMgY2FsY3VsYXRlZCBieSB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgY3VycmVudCBwb2ludGVyIGV2ZW50IGFuZCB0aGUgcmVzaXplIGhhbmRsZSBiZWluZyBcImRyYWdnZWRcIlxuLy8gICBUaGlzIHZhbHVlIGFjY291bnRzIGZvciB0aGUgaW5pdGlhbCBvZmZzZXQgd2hlbiB0aGUgdG91Y2gvY2xpY2sgc3RhcnRzLCBzbyB0aGUgaGFuZGxlIGRvZXNuJ3QgYXBwZWFyIHRvIFwianVtcFwiXG4vLyAqIGRyYWdIYW5kbGVSZWN0LCBzaXplczpcbi8vICAgV2hlbiByZXNpemluZyBpcyBkb25lIHZpYSBtb3VzZS90b3VjaCBldmVudOKAkyBzb21lIGluaXRpYWwgc3RhdGUgaXMgc3RvcmVkXG4vLyAgIHNvIHRoYXQgYW55IHBhbmVscyB0aGF0IGNvbnRyYWN0IHdpbGwgYWxzbyBleHBhbmQgaWYgZHJhZyBkaXJlY3Rpb24gaXMgcmV2ZXJzZWQuXG5mdW5jdGlvbiBQYW5lbEdyb3VwV2l0aEZvcndhcmRlZFJlZih7XG4gIGF1dG9TYXZlSWQsXG4gIGNoaWxkcmVuID0gbnVsbCxcbiAgY2xhc3NOYW1lOiBjbGFzc05hbWVGcm9tUHJvcHMgPSBcIlwiLFxuICBkaXJlY3Rpb24sXG4gIGRpc2FibGVQb2ludGVyRXZlbnRzRHVyaW5nUmVzaXplID0gZmFsc2UsXG4gIGZvcndhcmRlZFJlZixcbiAgaWQ6IGlkRnJvbVByb3BzID0gbnVsbCxcbiAgb25MYXlvdXQsXG4gIHN0b3JhZ2UgPSBkZWZhdWx0U3RvcmFnZSxcbiAgc3R5bGU6IHN0eWxlRnJvbVByb3BzID0ge30sXG4gIHRhZ05hbWU6IFR5cGUgPSBcImRpdlwiLFxuICB1bml0cyA9IFwicGVyY2VudGFnZXNcIlxufSkge1xuICBjb25zdCBncm91cElkID0gdXNlVW5pcXVlSWQoaWRGcm9tUHJvcHMpO1xuICBjb25zdCBbYWN0aXZlSGFuZGxlSWQsIHNldEFjdGl2ZUhhbmRsZUlkXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBbcGFuZWxzLCBzZXRQYW5lbHNdID0gdXNlU3RhdGUobmV3IE1hcCgpKTtcblxuICAvLyBXaGVuIHJlc2l6aW5nIGlzIGRvbmUgdmlhIG1vdXNlL3RvdWNoIGV2ZW504oCTXG4gIC8vIFdlIHN0b3JlIHRoZSBpbml0aWFsIFBhbmVsIHNpemVzIGluIHRoaXMgcmVmLCBhbmQgYXBwbHkgbW92ZSBkZWx0YXMgdG8gdGhlbSBpbnN0ZWFkIG9mIHRvIHRoZSBjdXJyZW50IHNpemVzLlxuICAvLyBUaGlzIGhhcyB0aGUgYmVuZWZpdCBvZiBjYXVzaW5nIGZvcmNlLWNvbGxhcHNlZCBwYW5lbHMgdG8gc3ByaW5nIGJhY2sgb3BlbiBpZiBkcmFnIGlzIHJldmVyc2VkLlxuICBjb25zdCBpbml0aWFsRHJhZ1N0YXRlUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBkZXZXYXJuaW5nc1JlZiA9IHVzZVJlZih7XG4gICAgZGlkTG9nRGVmYXVsdFNpemVXYXJuaW5nOiBmYWxzZSxcbiAgICBkaWRMb2dJZEFuZE9yZGVyV2FybmluZzogZmFsc2UsXG4gICAgZGlkTG9nSW52YWxpZExheW91dFdhcm5pbmc6IGZhbHNlLFxuICAgIHByZXZQYW5lbElkczogW11cbiAgfSk7XG5cbiAgLy8gVXNlIGEgcmVmIHRvIGd1YXJkIGFnYWluc3QgdXNlcnMgcGFzc2luZyBpbmxpbmUgcHJvcHNcbiAgY29uc3QgY2FsbGJhY2tzUmVmID0gdXNlUmVmKHtcbiAgICBvbkxheW91dFxuICB9KTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjYWxsYmFja3NSZWYuY3VycmVudC5vbkxheW91dCA9IG9uTGF5b3V0O1xuICB9KTtcbiAgY29uc3QgcGFuZWxJZFRvTGFzdE5vdGlmaWVkU2l6ZU1hcFJlZiA9IHVzZVJlZih7fSk7XG5cbiAgLy8gMC0xIHZhbHVlcyByZXByZXNlbnRpbmcgdGhlIHJlbGF0aXZlIHNpemUgb2YgZWFjaCBwYW5lbC5cbiAgY29uc3QgW3NpemVzLCBzZXRTaXplc10gPSB1c2VTdGF0ZShbXSk7XG5cbiAgLy8gVXNlZCB0byBzdXBwb3J0IGltcGVyYXRpdmUgY29sbGFwc2UvZXhwYW5kIEFQSS5cbiAgY29uc3QgcGFuZWxTaXplQmVmb3JlQ29sbGFwc2UgPSB1c2VSZWYobmV3IE1hcCgpKTtcbiAgY29uc3QgcHJldkRlbHRhUmVmID0gdXNlUmVmKDApO1xuXG4gIC8vIFN0b3JlIGNvbW1pdHRlZCB2YWx1ZXMgdG8gYXZvaWQgdW5uZWNlc3NhcmlseSByZS1ydW5uaW5nIG1lbW9pemF0aW9uL2VmZmVjdHMgZnVuY3Rpb25zLlxuICBjb25zdCBjb21taXR0ZWRWYWx1ZXNSZWYgPSB1c2VSZWYoe1xuICAgIGRpcmVjdGlvbixcbiAgICBpZDogZ3JvdXBJZCxcbiAgICBwYW5lbHMsXG4gICAgc2l6ZXMsXG4gICAgdW5pdHNcbiAgfSk7XG4gIHVzZUltcGVyYXRpdmVIYW5kbGUoZm9yd2FyZGVkUmVmLCAoKSA9PiAoe1xuICAgIGdldElkOiAoKSA9PiBncm91cElkLFxuICAgIGdldExheW91dDogdW5pdHNGcm9tUGFyYW1zID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2l6ZXMsXG4gICAgICAgIHVuaXRzOiB1bml0c0Zyb21Qcm9wc1xuICAgICAgfSA9IGNvbW1pdHRlZFZhbHVlc1JlZi5jdXJyZW50O1xuICAgICAgY29uc3QgdW5pdHMgPSB1bml0c0Zyb21QYXJhbXMgPz8gdW5pdHNGcm9tUHJvcHM7XG4gICAgICBpZiAodW5pdHMgPT09IFwicGl4ZWxzXCIpIHtcbiAgICAgICAgY29uc3QgZ3JvdXBTaXplUGl4ZWxzID0gZ2V0QXZhaWxhYmxlR3JvdXBTaXplUGl4ZWxzKGdyb3VwSWQpO1xuICAgICAgICByZXR1cm4gc2l6ZXMubWFwKHNpemUgPT4gc2l6ZSAvIDEwMCAqIGdyb3VwU2l6ZVBpeGVscyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2l6ZXM7XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXRMYXlvdXQ6IChzaXplcywgdW5pdHNGcm9tUGFyYW1zKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGlkOiBncm91cElkLFxuICAgICAgICBwYW5lbHMsXG4gICAgICAgIHNpemVzOiBwcmV2U2l6ZXMsXG4gICAgICAgIHVuaXRzXG4gICAgICB9ID0gY29tbWl0dGVkVmFsdWVzUmVmLmN1cnJlbnQ7XG4gICAgICBpZiAoKHVuaXRzRnJvbVBhcmFtcyB8fCB1bml0cykgPT09IFwicGl4ZWxzXCIpIHtcbiAgICAgICAgY29uc3QgZ3JvdXBTaXplUGl4ZWxzID0gZ2V0QXZhaWxhYmxlR3JvdXBTaXplUGl4ZWxzKGdyb3VwSWQpO1xuICAgICAgICBzaXplcyA9IHNpemVzLm1hcChzaXplID0+IHNpemUgLyBncm91cFNpemVQaXhlbHMgKiAxMDApO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFuZWxJZFRvTGFzdE5vdGlmaWVkU2l6ZU1hcCA9IHBhbmVsSWRUb0xhc3ROb3RpZmllZFNpemVNYXBSZWYuY3VycmVudDtcbiAgICAgIGNvbnN0IHBhbmVsc0FycmF5ID0gcGFuZWxzTWFwVG9Tb3J0ZWRBcnJheShwYW5lbHMpO1xuICAgICAgY29uc3QgbmV4dFNpemVzID0gdmFsaWRhdGVQYW5lbEdyb3VwTGF5b3V0KHtcbiAgICAgICAgZ3JvdXBJZCxcbiAgICAgICAgcGFuZWxzLFxuICAgICAgICBuZXh0U2l6ZXM6IHNpemVzLFxuICAgICAgICBwcmV2U2l6ZXMsXG4gICAgICAgIHVuaXRzXG4gICAgICB9KTtcbiAgICAgIGlmICghYXJlRXF1YWwocHJldlNpemVzLCBuZXh0U2l6ZXMpKSB7XG4gICAgICAgIHNldFNpemVzKG5leHRTaXplcyk7XG4gICAgICAgIGNhbGxQYW5lbENhbGxiYWNrcyhwYW5lbHNBcnJheSwgbmV4dFNpemVzLCBwYW5lbElkVG9MYXN0Tm90aWZpZWRTaXplTWFwKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pLCBbZ3JvdXBJZF0pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBjb21taXR0ZWRWYWx1ZXNSZWYuY3VycmVudC5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgY29tbWl0dGVkVmFsdWVzUmVmLmN1cnJlbnQuaWQgPSBncm91cElkO1xuICAgIGNvbW1pdHRlZFZhbHVlc1JlZi5jdXJyZW50LnBhbmVscyA9IHBhbmVscztcbiAgICBjb21taXR0ZWRWYWx1ZXNSZWYuY3VycmVudC5zaXplcyA9IHNpemVzO1xuICAgIGNvbW1pdHRlZFZhbHVlc1JlZi5jdXJyZW50LnVuaXRzID0gdW5pdHM7XG4gIH0pO1xuICB1c2VXaW5kb3dTcGxpdHRlclBhbmVsR3JvdXBCZWhhdmlvcih7XG4gICAgY29tbWl0dGVkVmFsdWVzUmVmLFxuICAgIGdyb3VwSWQsXG4gICAgcGFuZWxzLFxuICAgIHNldFNpemVzLFxuICAgIHNpemVzLFxuICAgIHBhbmVsU2l6ZUJlZm9yZUNvbGxhcHNlXG4gIH0pO1xuXG4gIC8vIE5vdGlmeSBleHRlcm5hbCBjb2RlIHdoZW4gc2l6ZXMgaGF2ZSBjaGFuZ2VkLlxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIG9uTGF5b3V0XG4gICAgfSA9IGNhbGxiYWNrc1JlZi5jdXJyZW50O1xuICAgIGNvbnN0IHtcbiAgICAgIHBhbmVscyxcbiAgICAgIHNpemVzXG4gICAgfSA9IGNvbW1pdHRlZFZhbHVlc1JlZi5jdXJyZW50O1xuXG4gICAgLy8gRG9uJ3QgY29tbWl0IGxheW91dCB1bnRpbCBhbGwgcGFuZWxzIGhhdmUgcmVnaXN0ZXJlZCBhbmQgcmUtcmVuZGVyZWQgd2l0aCB0aGVpciBhY3R1YWwgc2l6ZXMuXG4gICAgaWYgKHNpemVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmIChvbkxheW91dCkge1xuICAgICAgICBvbkxheW91dChzaXplcyk7XG4gICAgICB9XG4gICAgICBjb25zdCBwYW5lbElkVG9MYXN0Tm90aWZpZWRTaXplTWFwID0gcGFuZWxJZFRvTGFzdE5vdGlmaWVkU2l6ZU1hcFJlZi5jdXJyZW50O1xuXG4gICAgICAvLyBXaGVuIHBvc3NpYmxlLCB3ZSBub3RpZnkgYmVmb3JlIHRoZSBuZXh0IHJlbmRlciBzbyB0aGF0IHJlbmRlcmluZyB3b3JrIGNhbiBiZSBiYXRjaGVkIHRvZ2V0aGVyLlxuICAgICAgLy8gU29tZSBjYXNlcyBhcmUgZGlmZmljdWx0IHRvIGRldGVjdCB0aG91Z2gsXG4gICAgICAvLyBmb3IgZXhhbXBsZeKAkyBwYW5lbHMgdGhhdCBhcmUgY29uZGl0aW9uYWxseSByZW5kZXJlZCBjYW4gYWZmZWN0IHRoZSBzaXplIG9mIG5laWdoYm9yaW5nIHBhbmVscy5cbiAgICAgIC8vIEluIHRoaXMgY2FzZSwgdGhlIGJlc3Qgd2UgY2FuIGRvIGlzIG5vdGlmeSBvbiBjb21taXQuXG4gICAgICAvLyBUaGUgY2FsbFBhbmVsQ2FsbGJhY2tzKCkgdXNlcyBpdHMgb3duIG1lbW9pemF0aW9uIHRvIGF2b2lkIG5vdGlmeWluZyBwYW5lbHMgdHdpY2UgaW4gdGhlc2UgY2FzZXMuXG4gICAgICBjb25zdCBwYW5lbHNBcnJheSA9IHBhbmVsc01hcFRvU29ydGVkQXJyYXkocGFuZWxzKTtcbiAgICAgIGNhbGxQYW5lbENhbGxiYWNrcyhwYW5lbHNBcnJheSwgc2l6ZXMsIHBhbmVsSWRUb0xhc3ROb3RpZmllZFNpemVNYXApO1xuICAgIH1cbiAgfSwgW3NpemVzXSk7XG5cbiAgLy8gT25jZSBhbGwgcGFuZWxzIGhhdmUgcmVnaXN0ZXJlZCB0aGVtc2VsdmVzLFxuICAvLyBDb21wdXRlIHRoZSBpbml0aWFsIHNpemVzIGJhc2VkIG9uIGRlZmF1bHQgd2VpZ2h0cy5cbiAgLy8gVGhpcyBhc3N1bWVzIHRoYXQgcGFuZWxzIHJlZ2lzdGVyIGR1cmluZyBpbml0aWFsIG1vdW50IChubyBjb25kaXRpb25hbCByZW5kZXJpbmcpIVxuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBpZDogZ3JvdXBJZCxcbiAgICAgIHNpemVzLFxuICAgICAgdW5pdHNcbiAgICB9ID0gY29tbWl0dGVkVmFsdWVzUmVmLmN1cnJlbnQ7XG4gICAgaWYgKHNpemVzLmxlbmd0aCA9PT0gcGFuZWxzLnNpemUpIHtcbiAgICAgIC8vIE9ubHkgY29tcHV0ZSAob3IgcmVzdG9yZSkgZGVmYXVsdCBzaXplcyBvbmNlIHBlciBwYW5lbCBjb25maWd1cmF0aW9uLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIHRoaXMgcGFuZWwgaGFzIGJlZW4gY29uZmlndXJlZCB0byBwZXJzaXN0IHNpemluZyBpbmZvcm1hdGlvbixcbiAgICAvLyBkZWZhdWx0IHNpemUgc2hvdWxkIGJlIHJlc3RvcmVkIGZyb20gbG9jYWwgc3RvcmFnZSBpZiBwb3NzaWJsZS5cbiAgICBsZXQgZGVmYXVsdFNpemVzID0gbnVsbDtcbiAgICBpZiAoYXV0b1NhdmVJZCkge1xuICAgICAgY29uc3QgcGFuZWxzQXJyYXkgPSBwYW5lbHNNYXBUb1NvcnRlZEFycmF5KHBhbmVscyk7XG4gICAgICBkZWZhdWx0U2l6ZXMgPSBsb2FkUGFuZWxMYXlvdXQoYXV0b1NhdmVJZCwgcGFuZWxzQXJyYXksIHN0b3JhZ2UpO1xuICAgIH1cbiAgICBpZiAoZGVmYXVsdFNpemVzICE9IG51bGwpIHtcbiAgICAgIC8vIFZhbGlkYXRlIHNhdmVkIHNpemVzIGluIGNhc2Ugc29tZXRoaW5nIGhhcyBjaGFuZ2VkIHNpbmNlIGxhc3QgcmVuZGVyXG4gICAgICAvLyBlLmcuIGZvciBwaXhlbCBncm91cHMsIHRoaXMgY291bGQgYmUgdGhlIHNpemUgb2YgdGhlIHdpbmRvd1xuICAgICAgY29uc3QgdmFsaWRhdGVkU2l6ZXMgPSB2YWxpZGF0ZVBhbmVsR3JvdXBMYXlvdXQoe1xuICAgICAgICBncm91cElkLFxuICAgICAgICBwYW5lbHMsXG4gICAgICAgIG5leHRTaXplczogZGVmYXVsdFNpemVzLFxuICAgICAgICBwcmV2U2l6ZXM6IGRlZmF1bHRTaXplcyxcbiAgICAgICAgdW5pdHNcbiAgICAgIH0pO1xuICAgICAgc2V0U2l6ZXModmFsaWRhdGVkU2l6ZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzaXplcyA9IGNhbGN1bGF0ZURlZmF1bHRMYXlvdXQoe1xuICAgICAgICBncm91cElkLFxuICAgICAgICBwYW5lbHMsXG4gICAgICAgIHVuaXRzXG4gICAgICB9KTtcbiAgICAgIHNldFNpemVzKHNpemVzKTtcbiAgICB9XG4gIH0sIFthdXRvU2F2ZUlkLCBwYW5lbHMsIHN0b3JhZ2VdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBJZiB0aGlzIHBhbmVsIGhhcyBiZWVuIGNvbmZpZ3VyZWQgdG8gcGVyc2lzdCBzaXppbmcgaW5mb3JtYXRpb24sIHNhdmUgc2l6ZXMgdG8gbG9jYWwgc3RvcmFnZS5cbiAgICBpZiAoYXV0b1NhdmVJZCkge1xuICAgICAgaWYgKHNpemVzLmxlbmd0aCA9PT0gMCB8fCBzaXplcy5sZW5ndGggIT09IHBhbmVscy5zaXplKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhbmVsc0FycmF5ID0gcGFuZWxzTWFwVG9Tb3J0ZWRBcnJheShwYW5lbHMpO1xuXG4gICAgICAvLyBMaW1pdCB0aGUgZnJlcXVlbmN5IG9mIGxvY2FsU3RvcmFnZSB1cGRhdGVzLlxuICAgICAgaWYgKCFkZWJvdW5jZU1hcFthdXRvU2F2ZUlkXSkge1xuICAgICAgICBkZWJvdW5jZU1hcFthdXRvU2F2ZUlkXSA9IGRlYm91bmNlKHNhdmVQYW5lbEdyb3VwTGF5b3V0LCAxMDApO1xuICAgICAgfVxuICAgICAgZGVib3VuY2VNYXBbYXV0b1NhdmVJZF0oYXV0b1NhdmVJZCwgcGFuZWxzQXJyYXksIHNpemVzLCBzdG9yYWdlKTtcbiAgICB9XG4gICAge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkaWRMb2dJZEFuZE9yZGVyV2FybmluZyxcbiAgICAgICAgcHJldlBhbmVsSWRzXG4gICAgICB9ID0gZGV2V2FybmluZ3NSZWYuY3VycmVudDtcbiAgICAgIGlmICghZGlkTG9nSWRBbmRPcmRlcldhcm5pbmcpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHBhbmVsc1xuICAgICAgICB9ID0gY29tbWl0dGVkVmFsdWVzUmVmLmN1cnJlbnQ7XG4gICAgICAgIGNvbnN0IHBhbmVsSWRzID0gQXJyYXkuZnJvbShwYW5lbHMua2V5cygpKTtcbiAgICAgICAgZGV2V2FybmluZ3NSZWYuY3VycmVudC5wcmV2UGFuZWxJZHMgPSBwYW5lbElkcztcbiAgICAgICAgY29uc3QgcGFuZWxzSGF2ZUNoYW5nZWQgPSBwcmV2UGFuZWxJZHMubGVuZ3RoID4gMCAmJiAhYXJlRXF1YWwocHJldlBhbmVsSWRzLCBwYW5lbElkcyk7XG4gICAgICAgIGlmIChwYW5lbHNIYXZlQ2hhbmdlZCkge1xuICAgICAgICAgIGlmIChBcnJheS5mcm9tKHBhbmVscy52YWx1ZXMoKSkuZmluZChwYW5lbCA9PiBwYW5lbC5jdXJyZW50LmlkV2FzQXV0b0dlbmVyYXRlZCB8fCBwYW5lbC5jdXJyZW50Lm9yZGVyID09IG51bGwpKSB7XG4gICAgICAgICAgICBkZXZXYXJuaW5nc1JlZi5jdXJyZW50LmRpZExvZ0lkQW5kT3JkZXJXYXJuaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgV0FSTklORzogUGFuZWwgaWQgYW5kIG9yZGVyIHByb3BzIHJlY29tbWVuZGVkIHdoZW4gcGFuZWxzIGFyZSBkeW5hbWljYWxseSByZW5kZXJlZGApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwgW2F1dG9TYXZlSWQsIHBhbmVscywgc2l6ZXMsIHN0b3JhZ2VdKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgLy8gUGl4ZWwgcGFuZWwgY29uc3RyYWludHMgbmVlZCB0byBiZSByZWFzc2Vzc2VkIGFmdGVyIGEgZ3JvdXAgcmVzaXplXG4gICAgLy8gV2UgY2FuIGF2b2lkIHRoZSBSZXNpemVPYnNlcnZlciBvdmVyaGVhZCBmb3IgcmVsYXRpdmUgbGF5b3V0c1xuICAgIGlmICh1bml0cyA9PT0gXCJwaXhlbHNcIikge1xuICAgICAgY29uc3QgcmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKCkgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcGFuZWxzLFxuICAgICAgICAgIHNpemVzOiBwcmV2U2l6ZXNcbiAgICAgICAgfSA9IGNvbW1pdHRlZFZhbHVlc1JlZi5jdXJyZW50O1xuICAgICAgICBjb25zdCBuZXh0U2l6ZXMgPSB2YWxpZGF0ZVBhbmVsR3JvdXBMYXlvdXQoe1xuICAgICAgICAgIGdyb3VwSWQsXG4gICAgICAgICAgcGFuZWxzLFxuICAgICAgICAgIG5leHRTaXplczogcHJldlNpemVzLFxuICAgICAgICAgIHByZXZTaXplcyxcbiAgICAgICAgICB1bml0c1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFhcmVFcXVhbChwcmV2U2l6ZXMsIG5leHRTaXplcykpIHtcbiAgICAgICAgICBzZXRTaXplcyhuZXh0U2l6ZXMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJlc2l6ZU9ic2VydmVyLm9ic2VydmUoZ2V0UGFuZWxHcm91cChncm91cElkKSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICByZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW2dyb3VwSWQsIHVuaXRzXSk7XG4gIGNvbnN0IGdldFBhbmVsU2l6ZSA9IHVzZUNhbGxiYWNrKChpZCwgdW5pdHNGcm9tUGFyYW1zKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgcGFuZWxzLFxuICAgICAgdW5pdHM6IHVuaXRzRnJvbVByb3BzXG4gICAgfSA9IGNvbW1pdHRlZFZhbHVlc1JlZi5jdXJyZW50O1xuICAgIGNvbnN0IHBhbmVsc0FycmF5ID0gcGFuZWxzTWFwVG9Tb3J0ZWRBcnJheShwYW5lbHMpO1xuICAgIGNvbnN0IGluZGV4ID0gcGFuZWxzQXJyYXkuZmluZEluZGV4KHBhbmVsID0+IHBhbmVsLmN1cnJlbnQuaWQgPT09IGlkKTtcbiAgICBjb25zdCBzaXplID0gc2l6ZXNbaW5kZXhdO1xuICAgIGNvbnN0IHVuaXRzID0gdW5pdHNGcm9tUGFyYW1zID8/IHVuaXRzRnJvbVByb3BzO1xuICAgIGlmICh1bml0cyA9PT0gXCJwaXhlbHNcIikge1xuICAgICAgY29uc3QgZ3JvdXBTaXplUGl4ZWxzID0gZ2V0QXZhaWxhYmxlR3JvdXBTaXplUGl4ZWxzKGdyb3VwSWQpO1xuICAgICAgcmV0dXJuIHNpemUgLyAxMDAgKiBncm91cFNpemVQaXhlbHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzaXplO1xuICAgIH1cbiAgfSwgW2dyb3VwSWQsIHNpemVzXSk7XG4gIGNvbnN0IGdldFBhbmVsU3R5bGUgPSB1c2VDYWxsYmFjaygoaWQsIGRlZmF1bHRTaXplKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgcGFuZWxzXG4gICAgfSA9IGNvbW1pdHRlZFZhbHVlc1JlZi5jdXJyZW50O1xuXG4gICAgLy8gQmVmb3JlIG1vdW50aW5nLCBQYW5lbHMgd2lsbCBub3QgeWV0IGhhdmUgcmVnaXN0ZXJlZCB0aGVtc2VsdmVzLlxuICAgIC8vIFRoaXMgaW5jbHVkZXMgc2VydmVyIHJlbmRlcmluZy5cbiAgICAvLyBBdCB0aGlzIHBvaW50IHRoZSBiZXN0IHdlIGNhbiBkbyBpcyByZW5kZXIgZXZlcnl0aGluZyB3aXRoIHRoZSBzYW1lIHNpemUuXG4gICAgaWYgKHBhbmVscy5zaXplID09PSAwKSB7XG4gICAgICB7XG4gICAgICAgIGlmICghZGV2V2FybmluZ3NSZWYuY3VycmVudC5kaWRMb2dEZWZhdWx0U2l6ZVdhcm5pbmcpIDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGZsZXhCYXNpczogMCxcbiAgICAgICAgZmxleEdyb3c6IGRlZmF1bHRTaXplICE9IG51bGwgPyBkZWZhdWx0U2l6ZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgZmxleFNocmluazogMSxcbiAgICAgICAgLy8gV2l0aG91dCB0aGlzLCBQYW5lbCBzaXplcyBtYXkgYmUgdW5pbnRlbnRpb25hbGx5IG92ZXJyaWRkZW4gYnkgdGhlaXIgY29udGVudC5cbiAgICAgICAgb3ZlcmZsb3c6IFwiaGlkZGVuXCJcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGZsZXhHcm93ID0gZ2V0RmxleEdyb3cocGFuZWxzLCBpZCwgc2l6ZXMpO1xuICAgIHJldHVybiB7XG4gICAgICBmbGV4QmFzaXM6IDAsXG4gICAgICBmbGV4R3JvdyxcbiAgICAgIGZsZXhTaHJpbms6IDEsXG4gICAgICAvLyBXaXRob3V0IHRoaXMsIFBhbmVsIHNpemVzIG1heSBiZSB1bmludGVudGlvbmFsbHkgb3ZlcnJpZGRlbiBieSB0aGVpciBjb250ZW50LlxuICAgICAgb3ZlcmZsb3c6IFwiaGlkZGVuXCIsXG4gICAgICAvLyBEaXNhYmxlIHBvaW50ZXIgZXZlbnRzIGluc2lkZSBvZiBhIHBhbmVsIGR1cmluZyByZXNpemUuXG4gICAgICAvLyBUaGlzIGF2b2lkIGVkZ2UgY2FzZXMgbGlrZSBuZXN0ZWQgaWZyYW1lcy5cbiAgICAgIHBvaW50ZXJFdmVudHM6IGRpc2FibGVQb2ludGVyRXZlbnRzRHVyaW5nUmVzaXplICYmIGFjdGl2ZUhhbmRsZUlkICE9PSBudWxsID8gXCJub25lXCIgOiB1bmRlZmluZWRcbiAgICB9O1xuICB9LCBbYWN0aXZlSGFuZGxlSWQsIGRpc2FibGVQb2ludGVyRXZlbnRzRHVyaW5nUmVzaXplLCBzaXplc10pO1xuICBjb25zdCByZWdpc3RlclBhbmVsID0gdXNlQ2FsbGJhY2soKGlkLCBwYW5lbFJlZikgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHVuaXRzXG4gICAgfSA9IGNvbW1pdHRlZFZhbHVlc1JlZi5jdXJyZW50O1xuICAgIHZhbGlkYXRlUGFuZWxQcm9wcyh1bml0cywgcGFuZWxSZWYpO1xuICAgIHNldFBhbmVscyhwcmV2UGFuZWxzID0+IHtcbiAgICAgIGlmIChwcmV2UGFuZWxzLmhhcyhpZCkpIHtcbiAgICAgICAgcmV0dXJuIHByZXZQYW5lbHM7XG4gICAgICB9XG4gICAgICBjb25zdCBuZXh0UGFuZWxzID0gbmV3IE1hcChwcmV2UGFuZWxzKTtcbiAgICAgIG5leHRQYW5lbHMuc2V0KGlkLCBwYW5lbFJlZik7XG4gICAgICByZXR1cm4gbmV4dFBhbmVscztcbiAgICB9KTtcbiAgfSwgW10pO1xuICBjb25zdCByZWdpc3RlclJlc2l6ZUhhbmRsZSA9IHVzZUNhbGxiYWNrKGhhbmRsZUlkID0+IHtcbiAgICBjb25zdCByZXNpemVIYW5kbGVyID0gZXZlbnQgPT4ge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGlyZWN0aW9uLFxuICAgICAgICBwYW5lbHMsXG4gICAgICAgIHNpemVzOiBwcmV2U2l6ZXNcbiAgICAgIH0gPSBjb21taXR0ZWRWYWx1ZXNSZWYuY3VycmVudDtcbiAgICAgIGNvbnN0IHBhbmVsc0FycmF5ID0gcGFuZWxzTWFwVG9Tb3J0ZWRBcnJheShwYW5lbHMpO1xuICAgICAgY29uc3QgW2lkQmVmb3JlLCBpZEFmdGVyXSA9IGdldFJlc2l6ZUhhbmRsZVBhbmVsSWRzKGdyb3VwSWQsIGhhbmRsZUlkLCBwYW5lbHNBcnJheSk7XG4gICAgICBpZiAoaWRCZWZvcmUgPT0gbnVsbCB8fCBpZEFmdGVyID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IG1vdmVtZW50ID0gZ2V0TW92ZW1lbnQoZXZlbnQsIGdyb3VwSWQsIGhhbmRsZUlkLCBwYW5lbHNBcnJheSwgZGlyZWN0aW9uLCBwcmV2U2l6ZXMsIGluaXRpYWxEcmFnU3RhdGVSZWYuY3VycmVudCk7XG4gICAgICBpZiAobW92ZW1lbnQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZ3JvdXBFbGVtZW50ID0gZ2V0UGFuZWxHcm91cChncm91cElkKTtcbiAgICAgIGNvbnN0IHJlY3QgPSBncm91cEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBpc0hvcml6b250YWwgPSBkaXJlY3Rpb24gPT09IFwiaG9yaXpvbnRhbFwiO1xuXG4gICAgICAvLyBTdXBwb3J0IFJUTCBsYXlvdXRzXG4gICAgICBpZiAoZG9jdW1lbnQuZGlyID09PSBcInJ0bFwiICYmIGlzSG9yaXpvbnRhbCkge1xuICAgICAgICBtb3ZlbWVudCA9IC1tb3ZlbWVudDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNpemUgPSBpc0hvcml6b250YWwgPyByZWN0LndpZHRoIDogcmVjdC5oZWlnaHQ7XG4gICAgICBjb25zdCBkZWx0YSA9IG1vdmVtZW50IC8gc2l6ZSAqIDEwMDtcblxuICAgICAgLy8gSWYgYSB2YWxpZGF0ZUxheW91dCBtZXRob2QgaGFzIGJlZW4gcHJvdmlkZWRcbiAgICAgIC8vIGl0J3MgaW1wb3J0YW50IHRvIHVzZSBpdCBiZWZvcmUgdXBkYXRpbmcgdGhlIG1vdXNlIGN1cnNvclxuICAgICAgY29uc3QgbmV4dFNpemVzID0gYWRqdXN0QnlEZWx0YShldmVudCwgY29tbWl0dGVkVmFsdWVzUmVmLmN1cnJlbnQsIGlkQmVmb3JlLCBpZEFmdGVyLCBkZWx0YSwgcHJldlNpemVzLCBwYW5lbFNpemVCZWZvcmVDb2xsYXBzZS5jdXJyZW50LCBpbml0aWFsRHJhZ1N0YXRlUmVmLmN1cnJlbnQpO1xuICAgICAgY29uc3Qgc2l6ZXNDaGFuZ2VkID0gIWFyZUVxdWFsKHByZXZTaXplcywgbmV4dFNpemVzKTtcblxuICAgICAgLy8gRG9uJ3QgdXBkYXRlIGN1cnNvciBmb3IgcmVzaXplcyB0cmlnZ2VyZWQgYnkga2V5Ym9hcmQgaW50ZXJhY3Rpb25zLlxuICAgICAgaWYgKGlzTW91c2VFdmVudChldmVudCkgfHwgaXNUb3VjaEV2ZW50KGV2ZW50KSkge1xuICAgICAgICAvLyBXYXRjaCBmb3IgbXVsdGlwbGUgc3Vic2VxdWVudCBkZWx0YXM7IHRoaXMgbWlnaHQgb2NjdXIgZm9yIHRpbnkgY3Vyc29yIG1vdmVtZW50cy5cbiAgICAgICAgLy8gSW4gdGhpcyBjYXNlLCBQYW5lbCBzaXplcyBtaWdodCBub3QgY2hhbmdl4oCTXG4gICAgICAgIC8vIGJ1dCB1cGRhdGluZyBjdXJzb3IgaW4gdGhpcyBzY2VuYXJpbyB3b3VsZCBjYXVzZSBhIGZsaWNrZXIuXG4gICAgICAgIGlmIChwcmV2RGVsdGFSZWYuY3VycmVudCAhPSBkZWx0YSkge1xuICAgICAgICAgIGlmICghc2l6ZXNDaGFuZ2VkKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgcG9pbnRlciBoYXMgbW92ZWQgdG9vIGZhciB0byByZXNpemUgdGhlIHBhbmVsIGFueSBmdXJ0aGVyLFxuICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBjdXJzb3Igc3R5bGUgZm9yIGEgdmlzdWFsIGNsdWUuXG4gICAgICAgICAgICAvLyBUaGlzIG1pbWljcyBWUyBDb2RlIGJlaGF2aW9yLlxuXG4gICAgICAgICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgIHNldEdsb2JhbEN1cnNvclN0eWxlKG1vdmVtZW50IDwgMCA/IFwiaG9yaXpvbnRhbC1taW5cIiA6IFwiaG9yaXpvbnRhbC1tYXhcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZXRHbG9iYWxDdXJzb3JTdHlsZShtb3ZlbWVudCA8IDAgPyBcInZlcnRpY2FsLW1pblwiIDogXCJ2ZXJ0aWNhbC1tYXhcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBjdXJzb3Igc3R5bGUgdG8gdGhlIHRoZSBub3JtYWwgcmVzaXplIGN1cnNvci5cbiAgICAgICAgICAgIHNldEdsb2JhbEN1cnNvclN0eWxlKGlzSG9yaXpvbnRhbCA/IFwiaG9yaXpvbnRhbFwiIDogXCJ2ZXJ0aWNhbFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzaXplc0NoYW5nZWQpIHtcbiAgICAgICAgY29uc3QgcGFuZWxJZFRvTGFzdE5vdGlmaWVkU2l6ZU1hcCA9IHBhbmVsSWRUb0xhc3ROb3RpZmllZFNpemVNYXBSZWYuY3VycmVudDtcblxuICAgICAgICAvLyBJdCdzIG9rYXkgdG8gYnlwYXNzIGluIHRoaXMgY2FzZSBiZWNhdXNlIHdlIGFscmVhZHkgdmFsaWRhdGVkIGFib3ZlXG4gICAgICAgIHNldFNpemVzKG5leHRTaXplcyk7XG5cbiAgICAgICAgLy8gSWYgcmVzaXplIGNoYW5nZSBoYW5kbGVycyBoYXZlIGJlZW4gZGVjbGFyZWQsIHRoaXMgaXMgdGhlIHRpbWUgdG8gY2FsbCB0aGVtLlxuICAgICAgICAvLyBUcmlnZ2VyIHVzZXIgY2FsbGJhY2tzIGFmdGVyIHVwZGF0aW5nIHN0YXRlLCBzbyB0aGF0IHVzZXIgY29kZSBjYW4gb3ZlcnJpZGUgdGhlIHNpemVzLlxuICAgICAgICBjYWxsUGFuZWxDYWxsYmFja3MocGFuZWxzQXJyYXksIG5leHRTaXplcywgcGFuZWxJZFRvTGFzdE5vdGlmaWVkU2l6ZU1hcCk7XG4gICAgICB9XG4gICAgICBwcmV2RGVsdGFSZWYuY3VycmVudCA9IGRlbHRhO1xuICAgIH07XG4gICAgcmV0dXJuIHJlc2l6ZUhhbmRsZXI7XG4gIH0sIFtncm91cElkXSk7XG4gIGNvbnN0IHVucmVnaXN0ZXJQYW5lbCA9IHVzZUNhbGxiYWNrKGlkID0+IHtcbiAgICBzZXRQYW5lbHMocHJldlBhbmVscyA9PiB7XG4gICAgICBpZiAoIXByZXZQYW5lbHMuaGFzKGlkKSkge1xuICAgICAgICByZXR1cm4gcHJldlBhbmVscztcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5leHRQYW5lbHMgPSBuZXcgTWFwKHByZXZQYW5lbHMpO1xuICAgICAgbmV4dFBhbmVscy5kZWxldGUoaWQpO1xuICAgICAgcmV0dXJuIG5leHRQYW5lbHM7XG4gICAgfSk7XG4gIH0sIFtdKTtcbiAgY29uc3QgY29sbGFwc2VQYW5lbCA9IHVzZUNhbGxiYWNrKGlkID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBwYW5lbHMsXG4gICAgICBzaXplczogcHJldlNpemVzXG4gICAgfSA9IGNvbW1pdHRlZFZhbHVlc1JlZi5jdXJyZW50O1xuICAgIGNvbnN0IHBhbmVsID0gcGFuZWxzLmdldChpZCk7XG4gICAgaWYgKHBhbmVsID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgY29sbGFwc2VkU2l6ZSxcbiAgICAgIGNvbGxhcHNpYmxlXG4gICAgfSA9IHBhbmVsLmN1cnJlbnQ7XG4gICAgaWYgKCFjb2xsYXBzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwYW5lbHNBcnJheSA9IHBhbmVsc01hcFRvU29ydGVkQXJyYXkocGFuZWxzKTtcbiAgICBjb25zdCBpbmRleCA9IHBhbmVsc0FycmF5LmluZGV4T2YocGFuZWwpO1xuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFNpemUgPSBwcmV2U2l6ZXNbaW5kZXhdO1xuICAgIGlmIChjdXJyZW50U2l6ZSA9PT0gY29sbGFwc2VkU2l6ZSkge1xuICAgICAgLy8gUGFuZWwgaXMgYWxyZWFkeSBjb2xsYXBzZWQuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHBhbmVsU2l6ZUJlZm9yZUNvbGxhcHNlLmN1cnJlbnQuc2V0KGlkLCBjdXJyZW50U2l6ZSk7XG4gICAgY29uc3QgW2lkQmVmb3JlLCBpZEFmdGVyXSA9IGdldEJlZm9yZUFuZEFmdGVySWRzKGlkLCBwYW5lbHNBcnJheSk7XG4gICAgaWYgKGlkQmVmb3JlID09IG51bGwgfHwgaWRBZnRlciA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGlzTGFzdFBhbmVsID0gaW5kZXggPT09IHBhbmVsc0FycmF5Lmxlbmd0aCAtIDE7XG4gICAgY29uc3QgZGVsdGEgPSBpc0xhc3RQYW5lbCA/IGN1cnJlbnRTaXplIDogY29sbGFwc2VkU2l6ZSAtIGN1cnJlbnRTaXplO1xuICAgIGNvbnN0IG5leHRTaXplcyA9IGFkanVzdEJ5RGVsdGEobnVsbCwgY29tbWl0dGVkVmFsdWVzUmVmLmN1cnJlbnQsIGlkQmVmb3JlLCBpZEFmdGVyLCBkZWx0YSwgcHJldlNpemVzLCBwYW5lbFNpemVCZWZvcmVDb2xsYXBzZS5jdXJyZW50LCBudWxsKTtcbiAgICBpZiAocHJldlNpemVzICE9PSBuZXh0U2l6ZXMpIHtcbiAgICAgIGNvbnN0IHBhbmVsSWRUb0xhc3ROb3RpZmllZFNpemVNYXAgPSBwYW5lbElkVG9MYXN0Tm90aWZpZWRTaXplTWFwUmVmLmN1cnJlbnQ7XG4gICAgICBzZXRTaXplcyhuZXh0U2l6ZXMpO1xuXG4gICAgICAvLyBJZiByZXNpemUgY2hhbmdlIGhhbmRsZXJzIGhhdmUgYmVlbiBkZWNsYXJlZCwgdGhpcyBpcyB0aGUgdGltZSB0byBjYWxsIHRoZW0uXG4gICAgICAvLyBUcmlnZ2VyIHVzZXIgY2FsbGJhY2tzIGFmdGVyIHVwZGF0aW5nIHN0YXRlLCBzbyB0aGF0IHVzZXIgY29kZSBjYW4gb3ZlcnJpZGUgdGhlIHNpemVzLlxuICAgICAgY2FsbFBhbmVsQ2FsbGJhY2tzKHBhbmVsc0FycmF5LCBuZXh0U2l6ZXMsIHBhbmVsSWRUb0xhc3ROb3RpZmllZFNpemVNYXApO1xuICAgIH1cbiAgfSwgW10pO1xuICBjb25zdCBleHBhbmRQYW5lbCA9IHVzZUNhbGxiYWNrKGlkID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBwYW5lbHMsXG4gICAgICBzaXplczogcHJldlNpemVzXG4gICAgfSA9IGNvbW1pdHRlZFZhbHVlc1JlZi5jdXJyZW50O1xuICAgIGNvbnN0IHBhbmVsID0gcGFuZWxzLmdldChpZCk7XG4gICAgaWYgKHBhbmVsID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgY29sbGFwc2VkU2l6ZSxcbiAgICAgIG1pblNpemVcbiAgICB9ID0gcGFuZWwuY3VycmVudDtcbiAgICBjb25zdCBzaXplQmVmb3JlQ29sbGFwc2UgPSBwYW5lbFNpemVCZWZvcmVDb2xsYXBzZS5jdXJyZW50LmdldChpZCkgfHwgbWluU2l6ZTtcbiAgICBpZiAoIXNpemVCZWZvcmVDb2xsYXBzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwYW5lbHNBcnJheSA9IHBhbmVsc01hcFRvU29ydGVkQXJyYXkocGFuZWxzKTtcbiAgICBjb25zdCBpbmRleCA9IHBhbmVsc0FycmF5LmluZGV4T2YocGFuZWwpO1xuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFNpemUgPSBwcmV2U2l6ZXNbaW5kZXhdO1xuICAgIGlmIChjdXJyZW50U2l6ZSAhPT0gY29sbGFwc2VkU2l6ZSkge1xuICAgICAgLy8gUGFuZWwgaXMgYWxyZWFkeSBleHBhbmRlZC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgW2lkQmVmb3JlLCBpZEFmdGVyXSA9IGdldEJlZm9yZUFuZEFmdGVySWRzKGlkLCBwYW5lbHNBcnJheSk7XG4gICAgaWYgKGlkQmVmb3JlID09IG51bGwgfHwgaWRBZnRlciA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGlzTGFzdFBhbmVsID0gaW5kZXggPT09IHBhbmVsc0FycmF5Lmxlbmd0aCAtIDE7XG4gICAgY29uc3QgZGVsdGEgPSBpc0xhc3RQYW5lbCA/IGNvbGxhcHNlZFNpemUgLSBzaXplQmVmb3JlQ29sbGFwc2UgOiBzaXplQmVmb3JlQ29sbGFwc2U7XG4gICAgY29uc3QgbmV4dFNpemVzID0gYWRqdXN0QnlEZWx0YShudWxsLCBjb21taXR0ZWRWYWx1ZXNSZWYuY3VycmVudCwgaWRCZWZvcmUsIGlkQWZ0ZXIsIGRlbHRhLCBwcmV2U2l6ZXMsIHBhbmVsU2l6ZUJlZm9yZUNvbGxhcHNlLmN1cnJlbnQsIG51bGwpO1xuICAgIGlmIChwcmV2U2l6ZXMgIT09IG5leHRTaXplcykge1xuICAgICAgY29uc3QgcGFuZWxJZFRvTGFzdE5vdGlmaWVkU2l6ZU1hcCA9IHBhbmVsSWRUb0xhc3ROb3RpZmllZFNpemVNYXBSZWYuY3VycmVudDtcbiAgICAgIHNldFNpemVzKG5leHRTaXplcyk7XG5cbiAgICAgIC8vIElmIHJlc2l6ZSBjaGFuZ2UgaGFuZGxlcnMgaGF2ZSBiZWVuIGRlY2xhcmVkLCB0aGlzIGlzIHRoZSB0aW1lIHRvIGNhbGwgdGhlbS5cbiAgICAgIC8vIFRyaWdnZXIgdXNlciBjYWxsYmFja3MgYWZ0ZXIgdXBkYXRpbmcgc3RhdGUsIHNvIHRoYXQgdXNlciBjb2RlIGNhbiBvdmVycmlkZSB0aGUgc2l6ZXMuXG4gICAgICBjYWxsUGFuZWxDYWxsYmFja3MocGFuZWxzQXJyYXksIG5leHRTaXplcywgcGFuZWxJZFRvTGFzdE5vdGlmaWVkU2l6ZU1hcCk7XG4gICAgfVxuICB9LCBbXSk7XG4gIGNvbnN0IHJlc2l6ZVBhbmVsID0gdXNlQ2FsbGJhY2soKGlkLCBuZXh0U2l6ZSwgdW5pdHNGcm9tUGFyYW1zKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgaWQ6IGdyb3VwSWQsXG4gICAgICBwYW5lbHMsXG4gICAgICBzaXplczogcHJldlNpemVzLFxuICAgICAgdW5pdHNcbiAgICB9ID0gY29tbWl0dGVkVmFsdWVzUmVmLmN1cnJlbnQ7XG4gICAgaWYgKCh1bml0c0Zyb21QYXJhbXMgfHwgdW5pdHMpID09PSBcInBpeGVsc1wiKSB7XG4gICAgICBjb25zdCBncm91cFNpemVQaXhlbHMgPSBnZXRBdmFpbGFibGVHcm91cFNpemVQaXhlbHMoZ3JvdXBJZCk7XG4gICAgICBuZXh0U2l6ZSA9IG5leHRTaXplIC8gZ3JvdXBTaXplUGl4ZWxzICogMTAwO1xuICAgIH1cbiAgICBjb25zdCBwYW5lbCA9IHBhbmVscy5nZXQoaWQpO1xuICAgIGlmIChwYW5lbCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCB7XG4gICAgICBjb2xsYXBzZWRTaXplLFxuICAgICAgY29sbGFwc2libGUsXG4gICAgICBtYXhTaXplLFxuICAgICAgbWluU2l6ZVxuICAgIH0gPSBwYW5lbC5jdXJyZW50O1xuICAgIGlmICh1bml0cyA9PT0gXCJwaXhlbHNcIikge1xuICAgICAgY29uc3QgZ3JvdXBTaXplUGl4ZWxzID0gZ2V0QXZhaWxhYmxlR3JvdXBTaXplUGl4ZWxzKGdyb3VwSWQpO1xuICAgICAgbWluU2l6ZSA9IG1pblNpemUgLyBncm91cFNpemVQaXhlbHMgKiAxMDA7XG4gICAgICBpZiAobWF4U2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIG1heFNpemUgPSBtYXhTaXplIC8gZ3JvdXBTaXplUGl4ZWxzICogMTAwO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwYW5lbHNBcnJheSA9IHBhbmVsc01hcFRvU29ydGVkQXJyYXkocGFuZWxzKTtcbiAgICBjb25zdCBpbmRleCA9IHBhbmVsc0FycmF5LmluZGV4T2YocGFuZWwpO1xuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFNpemUgPSBwcmV2U2l6ZXNbaW5kZXhdO1xuICAgIGlmIChjdXJyZW50U2l6ZSA9PT0gbmV4dFNpemUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNvbGxhcHNpYmxlICYmIG5leHRTaXplID09PSBjb2xsYXBzZWRTaXplKSA7IGVsc2Uge1xuICAgICAgY29uc3QgdW5zYWZlTmV4dFNpemUgPSBuZXh0U2l6ZTtcbiAgICAgIG5leHRTaXplID0gTWF0aC5taW4obWF4U2l6ZSAhPSBudWxsID8gbWF4U2l6ZSA6IDEwMCwgTWF0aC5tYXgobWluU2l6ZSwgbmV4dFNpemUpKTtcbiAgICAgIHtcbiAgICAgICAgaWYgKHVuc2FmZU5leHRTaXplICE9PSBuZXh0U2l6ZSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEludmFsaWQgc2l6ZSAoJHt1bnNhZmVOZXh0U2l6ZX0pIHNwZWNpZmllZCBmb3IgUGFuZWwgXCIke3BhbmVsLmN1cnJlbnQuaWR9XCIgZ2l2ZW4gdGhlIHBhbmVsJ3MgbWluL21heCBzaXplIGNvbnN0cmFpbnRzYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgW2lkQmVmb3JlLCBpZEFmdGVyXSA9IGdldEJlZm9yZUFuZEFmdGVySWRzKGlkLCBwYW5lbHNBcnJheSk7XG4gICAgaWYgKGlkQmVmb3JlID09IG51bGwgfHwgaWRBZnRlciA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGlzTGFzdFBhbmVsID0gaW5kZXggPT09IHBhbmVsc0FycmF5Lmxlbmd0aCAtIDE7XG4gICAgY29uc3QgZGVsdGEgPSBpc0xhc3RQYW5lbCA/IGN1cnJlbnRTaXplIC0gbmV4dFNpemUgOiBuZXh0U2l6ZSAtIGN1cnJlbnRTaXplO1xuICAgIGNvbnN0IG5leHRTaXplcyA9IGFkanVzdEJ5RGVsdGEobnVsbCwgY29tbWl0dGVkVmFsdWVzUmVmLmN1cnJlbnQsIGlkQmVmb3JlLCBpZEFmdGVyLCBkZWx0YSwgcHJldlNpemVzLCBwYW5lbFNpemVCZWZvcmVDb2xsYXBzZS5jdXJyZW50LCBudWxsKTtcbiAgICBpZiAocHJldlNpemVzICE9PSBuZXh0U2l6ZXMpIHtcbiAgICAgIGNvbnN0IHBhbmVsSWRUb0xhc3ROb3RpZmllZFNpemVNYXAgPSBwYW5lbElkVG9MYXN0Tm90aWZpZWRTaXplTWFwUmVmLmN1cnJlbnQ7XG4gICAgICBzZXRTaXplcyhuZXh0U2l6ZXMpO1xuXG4gICAgICAvLyBJZiByZXNpemUgY2hhbmdlIGhhbmRsZXJzIGhhdmUgYmVlbiBkZWNsYXJlZCwgdGhpcyBpcyB0aGUgdGltZSB0byBjYWxsIHRoZW0uXG4gICAgICAvLyBUcmlnZ2VyIHVzZXIgY2FsbGJhY2tzIGFmdGVyIHVwZGF0aW5nIHN0YXRlLCBzbyB0aGF0IHVzZXIgY29kZSBjYW4gb3ZlcnJpZGUgdGhlIHNpemVzLlxuICAgICAgY2FsbFBhbmVsQ2FsbGJhY2tzKHBhbmVsc0FycmF5LCBuZXh0U2l6ZXMsIHBhbmVsSWRUb0xhc3ROb3RpZmllZFNpemVNYXApO1xuICAgIH1cbiAgfSwgW10pO1xuICBjb25zdCBjb250ZXh0ID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIGFjdGl2ZUhhbmRsZUlkLFxuICAgIGNvbGxhcHNlUGFuZWwsXG4gICAgZGlyZWN0aW9uLFxuICAgIGV4cGFuZFBhbmVsLFxuICAgIGdldFBhbmVsU2l6ZSxcbiAgICBnZXRQYW5lbFN0eWxlLFxuICAgIGdyb3VwSWQsXG4gICAgcmVnaXN0ZXJQYW5lbCxcbiAgICByZWdpc3RlclJlc2l6ZUhhbmRsZSxcbiAgICByZXNpemVQYW5lbCxcbiAgICBzdGFydERyYWdnaW5nOiAoaWQsIGV2ZW50KSA9PiB7XG4gICAgICBzZXRBY3RpdmVIYW5kbGVJZChpZCk7XG4gICAgICBpZiAoaXNNb3VzZUV2ZW50KGV2ZW50KSB8fCBpc1RvdWNoRXZlbnQoZXZlbnQpKSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZUVsZW1lbnQgPSBnZXRSZXNpemVIYW5kbGUoaWQpO1xuICAgICAgICBpbml0aWFsRHJhZ1N0YXRlUmVmLmN1cnJlbnQgPSB7XG4gICAgICAgICAgZHJhZ0hhbmRsZVJlY3Q6IGhhbmRsZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgZHJhZ09mZnNldDogZ2V0RHJhZ09mZnNldChldmVudCwgaWQsIGRpcmVjdGlvbiksXG4gICAgICAgICAgc2l6ZXM6IGNvbW1pdHRlZFZhbHVlc1JlZi5jdXJyZW50LnNpemVzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgICBzdG9wRHJhZ2dpbmc6ICgpID0+IHtcbiAgICAgIHJlc2V0R2xvYmFsQ3Vyc29yU3R5bGUoKTtcbiAgICAgIHNldEFjdGl2ZUhhbmRsZUlkKG51bGwpO1xuICAgICAgaW5pdGlhbERyYWdTdGF0ZVJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9LFxuICAgIHVuaXRzLFxuICAgIHVucmVnaXN0ZXJQYW5lbFxuICB9KSwgW2FjdGl2ZUhhbmRsZUlkLCBjb2xsYXBzZVBhbmVsLCBkaXJlY3Rpb24sIGV4cGFuZFBhbmVsLCBnZXRQYW5lbFNpemUsIGdldFBhbmVsU3R5bGUsIGdyb3VwSWQsIHJlZ2lzdGVyUGFuZWwsIHJlZ2lzdGVyUmVzaXplSGFuZGxlLCByZXNpemVQYW5lbCwgdW5pdHMsIHVucmVnaXN0ZXJQYW5lbF0pO1xuICBjb25zdCBzdHlsZSA9IHtcbiAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICBmbGV4RGlyZWN0aW9uOiBkaXJlY3Rpb24gPT09IFwiaG9yaXpvbnRhbFwiID8gXCJyb3dcIiA6IFwiY29sdW1uXCIsXG4gICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICBvdmVyZmxvdzogXCJoaWRkZW5cIixcbiAgICB3aWR0aDogXCIxMDAlXCJcbiAgfTtcbiAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoUGFuZWxHcm91cENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICBjaGlsZHJlbjogY3JlYXRlRWxlbWVudChUeXBlLCB7XG4gICAgICBjaGlsZHJlbixcbiAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lRnJvbVByb3BzLFxuICAgICAgXCJkYXRhLXBhbmVsLWdyb3VwXCI6IFwiXCIsXG4gICAgICBcImRhdGEtcGFuZWwtZ3JvdXAtZGlyZWN0aW9uXCI6IGRpcmVjdGlvbixcbiAgICAgIFwiZGF0YS1wYW5lbC1ncm91cC1pZFwiOiBncm91cElkLFxuICAgICAgXCJkYXRhLXBhbmVsLWdyb3VwLXVuaXRzXCI6IHVuaXRzLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgLi4uc3R5bGUsXG4gICAgICAgIC4uLnN0eWxlRnJvbVByb3BzXG4gICAgICB9XG4gICAgfSksXG4gICAgdmFsdWU6IGNvbnRleHRcbiAgfSk7XG59XG5jb25zdCBQYW5lbEdyb3VwID0gZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4gY3JlYXRlRWxlbWVudChQYW5lbEdyb3VwV2l0aEZvcndhcmRlZFJlZiwge1xuICAuLi5wcm9wcyxcbiAgZm9yd2FyZGVkUmVmOiByZWZcbn0pKTtcblBhbmVsR3JvdXBXaXRoRm9yd2FyZGVkUmVmLmRpc3BsYXlOYW1lID0gXCJQYW5lbEdyb3VwXCI7XG5QYW5lbEdyb3VwLmRpc3BsYXlOYW1lID0gXCJmb3J3YXJkUmVmKFBhbmVsR3JvdXApXCI7XG5cbmZ1bmN0aW9uIFBhbmVsUmVzaXplSGFuZGxlKHtcbiAgY2hpbGRyZW4gPSBudWxsLFxuICBjbGFzc05hbWU6IGNsYXNzTmFtZUZyb21Qcm9wcyA9IFwiXCIsXG4gIGRpc2FibGVkID0gZmFsc2UsXG4gIGlkOiBpZEZyb21Qcm9wcyA9IG51bGwsXG4gIG9uRHJhZ2dpbmcsXG4gIHN0eWxlOiBzdHlsZUZyb21Qcm9wcyA9IHt9LFxuICB0YWdOYW1lOiBUeXBlID0gXCJkaXZcIlxufSkge1xuICBjb25zdCBkaXZFbGVtZW50UmVmID0gdXNlUmVmKG51bGwpO1xuXG4gIC8vIFVzZSBhIHJlZiB0byBndWFyZCBhZ2FpbnN0IHVzZXJzIHBhc3NpbmcgaW5saW5lIHByb3BzXG4gIGNvbnN0IGNhbGxiYWNrc1JlZiA9IHVzZVJlZih7XG4gICAgb25EcmFnZ2luZ1xuICB9KTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjYWxsYmFja3NSZWYuY3VycmVudC5vbkRyYWdnaW5nID0gb25EcmFnZ2luZztcbiAgfSk7XG4gIGNvbnN0IHBhbmVsR3JvdXBDb250ZXh0ID0gdXNlQ29udGV4dChQYW5lbEdyb3VwQ29udGV4dCk7XG4gIGlmIChwYW5lbEdyb3VwQ29udGV4dCA9PT0gbnVsbCkge1xuICAgIHRocm93IEVycm9yKGBQYW5lbFJlc2l6ZUhhbmRsZSBjb21wb25lbnRzIG11c3QgYmUgcmVuZGVyZWQgd2l0aGluIGEgUGFuZWxHcm91cCBjb250YWluZXJgKTtcbiAgfVxuICBjb25zdCB7XG4gICAgYWN0aXZlSGFuZGxlSWQsXG4gICAgZGlyZWN0aW9uLFxuICAgIGdyb3VwSWQsXG4gICAgcmVnaXN0ZXJSZXNpemVIYW5kbGUsXG4gICAgc3RhcnREcmFnZ2luZyxcbiAgICBzdG9wRHJhZ2dpbmdcbiAgfSA9IHBhbmVsR3JvdXBDb250ZXh0O1xuICBjb25zdCByZXNpemVIYW5kbGVJZCA9IHVzZVVuaXF1ZUlkKGlkRnJvbVByb3BzKTtcbiAgY29uc3QgaXNEcmFnZ2luZyA9IGFjdGl2ZUhhbmRsZUlkID09PSByZXNpemVIYW5kbGVJZDtcbiAgY29uc3QgW2lzRm9jdXNlZCwgc2V0SXNGb2N1c2VkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3Jlc2l6ZUhhbmRsZXIsIHNldFJlc2l6ZUhhbmRsZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IHN0b3BEcmFnZ2luZ0FuZEJsdXIgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgLy8gQ2xpY2tpbmcgb24gdGhlIGRyYWcgaGFuZGxlIHNob3VsZG4ndCBsZWF2ZSBpdCBmb2N1c2VkO1xuICAgIC8vIFRoYXQgd291bGQgY2F1c2UgdGhlIFBhbmVsR3JvdXAgdG8gdGhpbmsgaXQgd2FzIHN0aWxsIGFjdGl2ZS5cbiAgICBjb25zdCBkaXYgPSBkaXZFbGVtZW50UmVmLmN1cnJlbnQ7XG4gICAgZGl2LmJsdXIoKTtcbiAgICBzdG9wRHJhZ2dpbmcoKTtcbiAgICBjb25zdCB7XG4gICAgICBvbkRyYWdnaW5nXG4gICAgfSA9IGNhbGxiYWNrc1JlZi5jdXJyZW50O1xuICAgIGlmIChvbkRyYWdnaW5nKSB7XG4gICAgICBvbkRyYWdnaW5nKGZhbHNlKTtcbiAgICB9XG4gIH0sIFtzdG9wRHJhZ2dpbmddKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgIHNldFJlc2l6ZUhhbmRsZXIobnVsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJlc2l6ZUhhbmRsZXIgPSByZWdpc3RlclJlc2l6ZUhhbmRsZShyZXNpemVIYW5kbGVJZCk7XG4gICAgICBzZXRSZXNpemVIYW5kbGVyKCgpID0+IHJlc2l6ZUhhbmRsZXIpO1xuICAgIH1cbiAgfSwgW2Rpc2FibGVkLCByZXNpemVIYW5kbGVJZCwgcmVnaXN0ZXJSZXNpemVIYW5kbGVdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQgfHwgcmVzaXplSGFuZGxlciA9PSBudWxsIHx8ICFpc0RyYWdnaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9uTW92ZSA9IGV2ZW50ID0+IHtcbiAgICAgIHJlc2l6ZUhhbmRsZXIoZXZlbnQpO1xuICAgIH07XG4gICAgY29uc3Qgb25Nb3VzZUxlYXZlID0gZXZlbnQgPT4ge1xuICAgICAgcmVzaXplSGFuZGxlcihldmVudCk7XG4gICAgfTtcbiAgICBjb25zdCBkaXZFbGVtZW50ID0gZGl2RWxlbWVudFJlZi5jdXJyZW50O1xuICAgIGNvbnN0IHRhcmdldERvY3VtZW50ID0gZGl2RWxlbWVudC5vd25lckRvY3VtZW50O1xuICAgIHRhcmdldERvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIHN0b3BEcmFnZ2luZ0FuZEJsdXIpO1xuICAgIHRhcmdldERvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBvbk1vdmUpO1xuICAgIHRhcmdldERvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCBvbk1vdmUpO1xuICAgIHRhcmdldERvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgb25Nb3VzZUxlYXZlKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgc3RvcERyYWdnaW5nQW5kQmx1cik7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBzdG9wRHJhZ2dpbmdBbmRCbHVyKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdGFyZ2V0RG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgc3RvcERyYWdnaW5nQW5kQmx1cik7XG4gICAgICB0YXJnZXREb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgb25Nb3ZlKTtcbiAgICAgIHRhcmdldERvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCBvbk1vdmUpO1xuICAgICAgdGFyZ2V0RG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCBvbk1vdXNlTGVhdmUpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHN0b3BEcmFnZ2luZ0FuZEJsdXIpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBzdG9wRHJhZ2dpbmdBbmRCbHVyKTtcbiAgICB9O1xuICB9LCBbZGlyZWN0aW9uLCBkaXNhYmxlZCwgaXNEcmFnZ2luZywgcmVzaXplSGFuZGxlciwgc3RvcERyYWdnaW5nQW5kQmx1cl0pO1xuICB1c2VXaW5kb3dTcGxpdHRlclJlc2l6ZUhhbmRsZXJCZWhhdmlvcih7XG4gICAgZGlzYWJsZWQsXG4gICAgaGFuZGxlSWQ6IHJlc2l6ZUhhbmRsZUlkLFxuICAgIHJlc2l6ZUhhbmRsZXJcbiAgfSk7XG4gIGNvbnN0IHN0eWxlID0ge1xuICAgIGN1cnNvcjogZ2V0Q3Vyc29yU3R5bGUoZGlyZWN0aW9uKSxcbiAgICB0b3VjaEFjdGlvbjogXCJub25lXCIsXG4gICAgdXNlclNlbGVjdDogXCJub25lXCJcbiAgfTtcbiAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoVHlwZSwge1xuICAgIGNoaWxkcmVuLFxuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lRnJvbVByb3BzLFxuICAgIFwiZGF0YS1yZXNpemUtaGFuZGxlLWFjdGl2ZVwiOiBpc0RyYWdnaW5nID8gXCJwb2ludGVyXCIgOiBpc0ZvY3VzZWQgPyBcImtleWJvYXJkXCIgOiB1bmRlZmluZWQsXG4gICAgXCJkYXRhLXBhbmVsLWdyb3VwLWRpcmVjdGlvblwiOiBkaXJlY3Rpb24sXG4gICAgXCJkYXRhLXBhbmVsLWdyb3VwLWlkXCI6IGdyb3VwSWQsXG4gICAgXCJkYXRhLXBhbmVsLXJlc2l6ZS1oYW5kbGUtZW5hYmxlZFwiOiAhZGlzYWJsZWQsXG4gICAgXCJkYXRhLXBhbmVsLXJlc2l6ZS1oYW5kbGUtaWRcIjogcmVzaXplSGFuZGxlSWQsXG4gICAgb25CbHVyOiAoKSA9PiBzZXRJc0ZvY3VzZWQoZmFsc2UpLFxuICAgIG9uRm9jdXM6ICgpID0+IHNldElzRm9jdXNlZCh0cnVlKSxcbiAgICBvbk1vdXNlRG93bjogZXZlbnQgPT4ge1xuICAgICAgc3RhcnREcmFnZ2luZyhyZXNpemVIYW5kbGVJZCwgZXZlbnQubmF0aXZlRXZlbnQpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBvbkRyYWdnaW5nXG4gICAgICB9ID0gY2FsbGJhY2tzUmVmLmN1cnJlbnQ7XG4gICAgICBpZiAob25EcmFnZ2luZykge1xuICAgICAgICBvbkRyYWdnaW5nKHRydWUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgb25Nb3VzZVVwOiBzdG9wRHJhZ2dpbmdBbmRCbHVyLFxuICAgIG9uVG91Y2hDYW5jZWw6IHN0b3BEcmFnZ2luZ0FuZEJsdXIsXG4gICAgb25Ub3VjaEVuZDogc3RvcERyYWdnaW5nQW5kQmx1cixcbiAgICBvblRvdWNoU3RhcnQ6IGV2ZW50ID0+IHtcbiAgICAgIHN0YXJ0RHJhZ2dpbmcocmVzaXplSGFuZGxlSWQsIGV2ZW50Lm5hdGl2ZUV2ZW50KTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb25EcmFnZ2luZ1xuICAgICAgfSA9IGNhbGxiYWNrc1JlZi5jdXJyZW50O1xuICAgICAgaWYgKG9uRHJhZ2dpbmcpIHtcbiAgICAgICAgb25EcmFnZ2luZyh0cnVlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlZjogZGl2RWxlbWVudFJlZixcbiAgICByb2xlOiBcInNlcGFyYXRvclwiLFxuICAgIHN0eWxlOiB7XG4gICAgICAuLi5zdHlsZSxcbiAgICAgIC4uLnN0eWxlRnJvbVByb3BzXG4gICAgfSxcbiAgICB0YWJJbmRleDogMFxuICB9KTtcbn1cblBhbmVsUmVzaXplSGFuZGxlLmRpc3BsYXlOYW1lID0gXCJQYW5lbFJlc2l6ZUhhbmRsZVwiO1xuXG5leHBvcnQgeyBQYW5lbCwgUGFuZWxHcm91cCwgUGFuZWxSZXNpemVIYW5kbGUsIGdldEF2YWlsYWJsZUdyb3VwU2l6ZVBpeGVscyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/react-resizable-panels@0.0.55_react-dom@18.2.0_react@18.2.0/node_modules/react-resizable-panels/dist/react-resizable-panels.browser.development.esm.js\n"));

/***/ })

}]);